webpackJsonp([1],{

/***/ 131:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(process) {var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n  * vue-router v2.7.0\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"[vue-router] \" + message);\n  }\n}\n\nfunction warn(condition, message) {\n  if (process.env.NODE_ENV !== 'production' && !condition) {\n    typeof console !== 'undefined' && console.warn(\"[vue-router] \" + message);\n  }\n}\n\nfunction isError(err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1;\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render(_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children);\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h();\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (val && current !== vm || !val && current === vm) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also regiseter instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children);\n  }\n};\n\nfunction resolveProps(route, config) {\n  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {\n    case 'undefined':\n      return;\n    case 'object':\n      return config;\n    case 'function':\n      return config(route);\n    case 'boolean':\n      return config ? route.params : undefined;\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"props in \\\"\" + route.path + \"\\\" is a \" + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + \", \" + \"expecting an object, function or boolean.\");\n      }\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n};\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function encode(str) {\n  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');\n};\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery(query, extraQuery, _parseQuery) {\n  if (extraQuery === void 0) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && warn(false, e.message);\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    var val = extraQuery[key];\n    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;\n  }\n  return parsedQuery;\n}\n\nfunction parseQuery(query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res;\n}\n\nfunction stringifyQuery(obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return '';\n    }\n\n    if (val === null) {\n      return encode(key);\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return;\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&');\n    }\n\n    return encode(key) + '=' + encode(val);\n  }).filter(function (x) {\n    return x.length > 0;\n  }).join('&') : null;\n  return res ? \"?\" + res : '';\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute(record, location, redirectedFrom, router) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n  var route = {\n    name: location.name || record && record.name,\n    meta: record && record.meta || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n  return Object.freeze(route);\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch(record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res;\n}\n\nfunction getFullPath(ref, _stringifyQuery) {\n  var path = ref.path;\n  var query = ref.query;if (query === void 0) query = {};\n  var hash = ref.hash;if (hash === void 0) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash;\n}\n\nfunction isSameRoute(a, b) {\n  if (b === START) {\n    return a === b;\n  } else if (!b) {\n    return false;\n  } else if (a.path && b.path) {\n    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);\n  } else if (a.name && b.name) {\n    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);\n  } else {\n    return false;\n  }\n}\n\nfunction isObjectEqual(a, b) {\n  if (a === void 0) a = {};\n  if (b === void 0) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key];\n    // check nested equality\n    if ((typeof aVal === 'undefined' ? 'undefined' : _typeof(aVal)) === 'object' && (typeof bVal === 'undefined' ? 'undefined' : _typeof(bVal)) === 'object') {\n      return isObjectEqual(aVal, bVal);\n    }\n    return String(aVal) === String(bVal);\n  });\n}\n\nfunction isIncludedRoute(current, target) {\n  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);\n}\n\nfunction queryIncludes(current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;\n    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;\n    var compareTarget = location.path ? createRoute(null, location, null, router) : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);\n\n    var handler = function handler(e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) {\n        on[e] = handler;\n      });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default);\n  }\n};\n\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {\n    return;\n  }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) {\n    return;\n  }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) {\n    return;\n  }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) {\n      return;\n    }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true;\n}\n\nfunction findAnchor(children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child;\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child;\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install(Vue) {\n  if (install.installed) {\n    return;\n  }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function isDef(v) {\n    return v !== undefined;\n  };\n\n  var registerInstance = function registerInstance(vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate() {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = this.$parent && this.$parent._routerRoot || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed() {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get() {\n      return this._routerRoot._router;\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get() {\n      return this._routerRoot._route;\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath(relative, base, append) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative;\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative;\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/');\n}\n\nfunction parsePath(path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction cleanPath(path) {\n  return path.replace(/\\/\\//g, '/');\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)',\n// Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (_typeof(tokens[i]) === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (index$1(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags(options) {\n  return options.sensitive ? '' : 'i';\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys);\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp(path, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */keys);\n  }\n\n  if (index$1(path)) {\n    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);\n  }\n\n  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams(path, params, routeMsg) {\n  try {\n    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true });\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"missing param for \" + routeMsg + \": \" + e.message);\n    }\n    return '';\n  }\n}\n\n/*  */\n\nfunction createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  };\n}\n\nfunction addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(typeof route.component !== 'string', \"route config \\\"component\\\" for path: \" + String(path || name) + \" cannot be a \" + \"string id. Use an actual component instead.\");\n  }\n\n  var normalizedPath = normalizePath(path, parent);\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null ? {} : route.components ? route.props : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && !route.redirect && route.children.some(function (child) {\n        return (/^\\/?$/.test(child.path)\n        );\n      })) {\n        warn(false, \"Named Route '\" + route.name + \"' has a default child route. \" + \"When navigating to this named route (:to=\\\"{name: '\" + route.name + \"'\\\"), \" + \"the default child route will not be rendered. Remove the name from \" + \"this route and use the name of the default child route for named \" + \"links instead.\");\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs ? cleanPath(matchAs + \"/\" + child.path) : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(false, \"Duplicate named routes definition: \" + \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + record.path + \"\\\" }\");\n    }\n  }\n}\n\nfunction compileRouteRegex(path, pathToRegexpOptions) {\n  var regex = index(path, [], pathToRegexpOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    var keys = {};\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], \"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\");\n      keys[key.name] = true;\n    });\n  }\n  return regex;\n}\n\nfunction normalizePath(path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') {\n    return path;\n  }\n  if (parent == null) {\n    return path;\n  }\n  return cleanPath(parent.path + \"/\" + path);\n}\n\n/*  */\n\nfunction normalizeLocation(raw, current, append, router) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next;\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, \"path \" + current.path);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next;\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = current && current.path || '/';\n  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;\n\n  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction assign(a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a;\n}\n\n/*  */\n\nfunction createMatcher(routes, router) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes(routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match(raw, currentRoute, redirectedFrom) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        warn(record, \"Route with name '\" + name + \"' does not exist\");\n      }\n      if (!record) {\n        return _createRoute(null, location);\n      }\n      var paramNames = record.regex.keys.filter(function (key) {\n        return !key.optional;\n      }).map(function (key) {\n        return key.name;\n      });\n\n      if (_typeof(location.params) !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && _typeof(currentRoute.params) === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, \"named route \\\"\" + name + \"\\\"\");\n        return _createRoute(record, location, redirectedFrom);\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom);\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location);\n  }\n\n  function redirect(record, location) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n      return _createRoute(null, location);\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, \"redirect failed: named route \\\"\" + name + \"\\\" not found.\");\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location);\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, \"redirect route with path \\\"\" + rawPath + \"\\\"\");\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location);\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n      return _createRoute(null, location);\n    }\n  }\n\n  function alias(record, location, matchAs) {\n    var aliasedPath = fillParams(matchAs, location.params, \"aliased route with path \\\"\" + matchAs + \"\\\"\");\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location);\n    }\n    return _createRoute(null, location);\n  }\n\n  function _createRoute(record, location, redirectedFrom) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location);\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs);\n    }\n    return createRoute(record, location, redirectedFrom, router);\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  };\n}\n\nfunction matchRoute(regex, path, params) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false;\n  } else if (!params) {\n    return true;\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) {\n      params[key.name] = val;\n    }\n  }\n\n  return true;\n}\n\nfunction resolveRecordPath(path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true);\n}\n\n/*  */\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll() {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll(router, to, from, isPop) {\n  if (!router.app) {\n    return;\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return;\n    }\n    var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};\n        offset = normalizeOffset(offset);\n        position = getElementPosition(el, offset);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition() {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition() {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key];\n  }\n}\n\nfunction getElementPosition(el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  };\n}\n\nfunction isValidPosition(obj) {\n  return isNumber(obj.x) || isNumber(obj.y);\n}\n\nfunction normalizePosition(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  };\n}\n\nfunction normalizeOffset(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  };\n}\n\nfunction isNumber(v) {\n  return typeof v === 'number';\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && function () {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n\n  return window.history && 'pushState' in window.history;\n}();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;\n\nvar _key = genKey();\n\nfunction genKey() {\n  return Time.now().toFixed(3);\n}\n\nfunction getStateKey() {\n  return _key;\n}\n\nfunction setStateKey(key) {\n  _key = key;\n}\n\nfunction pushState(url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState(url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue(queue, fn, cb) {\n  var step = function step(index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\nfunction resolveAsyncComponents(matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (resolvedDef.__esModule && resolvedDef.default) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n          process.env.NODE_ENV !== 'production' && warn(false, msg);\n          if (!error) {\n            error = isError(reason) ? reason : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) {\n      next();\n    }\n  };\n}\n\nfunction flatMapComponents(matched, fn) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return fn(m.components[key], m.instances[key], m, key);\n    });\n  }));\n}\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once(fn) {\n  var called = false;\n  return function () {\n    var args = [],\n        len = arguments.length;\n    while (len--) {\n      args[len] = arguments[len];\n    }if (called) {\n      return;\n    }\n    called = true;\n    return fn.apply(this, args);\n  };\n}\n\n/*  */\n\nvar History = function History(router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen(cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady(cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError(errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n  var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) {\n        cb(err);\n      });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {\n  var this$1 = this;\n\n  var current = this.current;\n  var abort = function abort(err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) {\n          cb(err);\n        });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  if (isSameRoute(route, current) &&\n  // in the case the route map has been dynamically appended to\n  route.matched.length === current.matched.length) {\n    this.ensureURL();\n    return abort();\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n  var updated = ref.updated;\n  var deactivated = ref.deactivated;\n  var activated = ref.activated;\n\n  var queue = [].concat(\n  // in-component leave guards\n  extractLeaveGuards(deactivated),\n  // global before hooks\n  this.router.beforeHooks,\n  // in-component update hooks\n  extractUpdateHooks(updated),\n  // in-config enter guards\n  activated.map(function (m) {\n    return m.beforeEnter;\n  }),\n  // async components\n  resolveAsyncComponents(activated));\n\n  this.pending = route;\n  var iterator = function iterator(hook, next) {\n    if (this$1.pending !== route) {\n      return abort();\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function isValid() {\n      return this$1.current === route;\n    };\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort();\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) {\n            cb();\n          });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute(route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase(base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '');\n}\n\nfunction resolveQueue(current, next) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break;\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  };\n}\n\nfunction extractGuards(records, name, bind, reverse) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard) ? guard.map(function (guard) {\n        return bind(guard, instance, match, key);\n      }) : bind(guard, instance, match, key);\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards);\n}\n\nfunction extractGuard(def, key) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key];\n}\n\nfunction extractLeaveGuards(deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);\n}\n\nfunction extractUpdateHooks(updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);\n}\n\nfunction bindGuard(guard, instance) {\n  if (instance) {\n    return function boundRouteGuard() {\n      return guard.apply(instance, arguments);\n    };\n  }\n}\n\nfunction extractEnterGuards(activated, cbs, isValid) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid);\n  });\n}\n\nfunction bindEnterGuard(guard, match, key, cbs, isValid) {\n  return function routeEnterGuard(to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    });\n  };\n}\n\nfunction poll(cb, // somehow flow cannot infer this is a function\ninstances, key, isValid) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\n/*  */\n\nvar HTML5History = function (History$$1) {\n  function HTML5History(router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current;\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if (History$$1) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL(push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getLocation(this.base);\n  };\n\n  return HTML5History;\n}(History);\n\nfunction getLocation(base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash;\n}\n\n/*  */\n\nvar HashHistory = function (History$$1) {\n  function HashHistory(router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return;\n    }\n    ensureSlash();\n  }\n\n  if (History$$1) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners() {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return;\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push(location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL(push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getHash();\n  };\n\n  return HashHistory;\n}(History);\n\nfunction checkFallback(base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location));\n    return true;\n  }\n}\n\nfunction ensureSlash() {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true;\n  }\n  replaceHash('/' + path);\n  return false;\n}\n\nfunction getHash() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1);\n}\n\nfunction pushHash(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash(path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  window.location.replace(base + \"#\" + path);\n}\n\n/*  */\n\nvar AbstractHistory = function (History$$1) {\n  function AbstractHistory(router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if (History$$1) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go(n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return;\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/';\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL() {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History);\n\n/*  */\n\nvar VueRouter = function VueRouter(options) {\n  if (options === void 0) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break;\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break;\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break;\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        assert(false, \"invalid mode: \" + mode);\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match(raw, current, redirectedFrom) {\n  return this.matcher.match(raw, current, redirectedFrom);\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current;\n};\n\nVueRouter.prototype.init = function init(app /* Vue component instance */) {\n  var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(install.installed, \"not installed. Make sure to call `Vue.use(VueRouter)` \" + \"before creating root instance.\");\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return;\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function setupHashListener() {\n      history.setupListeners();\n    };\n    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach(fn) {\n  return registerHook(this.beforeHooks, fn);\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve(fn) {\n  return registerHook(this.resolveHooks, fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach(fn) {\n  return registerHook(this.afterHooks, fn);\n};\n\nVueRouter.prototype.onReady = function onReady(cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError(errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push(location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace(location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go(n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back() {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward() {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {\n  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;\n  if (!route) {\n    return [];\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key];\n    });\n  }));\n};\n\nVueRouter.prototype.resolve = function resolve(to, current, append) {\n  var location = normalizeLocation(to, current || this.history.current, append, this);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  };\n};\n\nVueRouter.prototype.addRoutes = function addRoutes(routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties(VueRouter.prototype, prototypeAccessors);\n\nfunction registerHook(list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) {\n      list.splice(i, 1);\n    }\n  };\n}\n\nfunction createHref(base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path;\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.7.0';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VueRouter);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(66)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L192dWUtcm91dGVyQDIuNy4wQHZ1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcz82ZWM0Il0sIm5hbWVzIjpbImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsIndhcm4iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwiaXNFcnJvciIsImVyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImluZGV4T2YiLCJWaWV3IiwibmFtZSIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwicmVuZGVyIiwiXyIsInJlZiIsImNoaWxkcmVuIiwicGFyZW50IiwiZGF0YSIsInJvdXRlclZpZXciLCJoIiwiJGNyZWF0ZUVsZW1lbnQiLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCJfcm91dGVyUm9vdCIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwidmFsIiwiY3VycmVudCIsImluc3RhbmNlcyIsImhvb2siLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJyZXNvbHZlUHJvcHMiLCJjb25maWciLCJwYXJhbXMiLCJ1bmRlZmluZWQiLCJwYXRoIiwiZW5jb2RlUmVzZXJ2ZVJFIiwiZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyIiwiYyIsImNoYXJDb2RlQXQiLCJjb21tYVJFIiwiZW5jb2RlIiwic3RyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlc29sdmVRdWVyeSIsInF1ZXJ5IiwiZXh0cmFRdWVyeSIsIl9wYXJzZVF1ZXJ5IiwicGFyc2UiLCJwYXJzZVF1ZXJ5IiwicGFyc2VkUXVlcnkiLCJlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJyZXMiLCJ0cmltIiwic3BsaXQiLCJmb3JFYWNoIiwicGFyYW0iLCJwYXJ0cyIsInNoaWZ0IiwibGVuZ3RoIiwiam9pbiIsInB1c2giLCJzdHJpbmdpZnlRdWVyeSIsIm9iaiIsImtleXMiLCJtYXAiLCJyZXN1bHQiLCJ2YWwyIiwiZmlsdGVyIiwieCIsInRyYWlsaW5nU2xhc2hSRSIsImNyZWF0ZVJvdXRlIiwicmVjb3JkIiwibG9jYXRpb24iLCJyZWRpcmVjdGVkRnJvbSIsInJvdXRlciIsInN0cmluZ2lmeVF1ZXJ5JCQxIiwib3B0aW9ucyIsIm1ldGEiLCJoYXNoIiwiZnVsbFBhdGgiLCJnZXRGdWxsUGF0aCIsImZvcm1hdE1hdGNoIiwiZnJlZXplIiwiU1RBUlQiLCJ1bnNoaWZ0IiwiX3N0cmluZ2lmeVF1ZXJ5Iiwic3RyaW5naWZ5IiwiaXNTYW1lUm91dGUiLCJhIiwiYiIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJhVmFsIiwiYlZhbCIsImlzSW5jbHVkZWRSb3V0ZSIsInRhcmdldCIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJ0byIsInJlcXVpcmVkIiwidGFnIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwiYWN0aXZlQ2xhc3MiLCJleGFjdEFjdGl2ZUNsYXNzIiwiZXZlbnQiLCJ0aGlzJDEiLCIkcm91dGVyIiwicmVzb2x2ZSIsImhyZWYiLCJjbGFzc2VzIiwiZ2xvYmFsQWN0aXZlQ2xhc3MiLCJsaW5rQWN0aXZlQ2xhc3MiLCJnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzIiwibGlua0V4YWN0QWN0aXZlQ2xhc3MiLCJhY3RpdmVDbGFzc0ZhbGxiYWNrIiwiZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrIiwiY29tcGFyZVRhcmdldCIsImhhbmRsZXIiLCJndWFyZEV2ZW50Iiwib24iLCJjbGljayIsImNsYXNzIiwiYXR0cnMiLCJmaW5kQW5jaG9yIiwiJHNsb3RzIiwiaXNTdGF0aWMiLCJleHRlbmQiLCJfVnVlIiwidXRpbCIsImFEYXRhIiwiYUF0dHJzIiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidXR0b24iLCJjdXJyZW50VGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsInByZXZlbnREZWZhdWx0IiwiY2hpbGQiLCJpIiwiaW5zdGFsbCIsIlZ1ZSIsImluc3RhbGxlZCIsImlzRGVmIiwidiIsInJlZ2lzdGVySW5zdGFuY2UiLCJjYWxsVmFsIiwiJG9wdGlvbnMiLCJfcGFyZW50Vm5vZGUiLCJtaXhpbiIsImJlZm9yZUNyZWF0ZSIsIl9yb3V0ZXIiLCJpbml0IiwiZGVmaW5lUmVhY3RpdmUiLCJoaXN0b3J5IiwiZGVzdHJveWVkIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJfcm91dGUiLCJzdHJhdHMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJiZWZvcmVSb3V0ZUVudGVyIiwiYmVmb3JlUm91dGVMZWF2ZSIsImJlZm9yZVJvdXRlVXBkYXRlIiwiY3JlYXRlZCIsImluQnJvd3NlciIsIndpbmRvdyIsInJlc29sdmVQYXRoIiwicmVsYXRpdmUiLCJiYXNlIiwiZmlyc3RDaGFyIiwiY2hhckF0Iiwic3RhY2siLCJwb3AiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJzZVBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwiaW5kZXgkMSIsImFyciIsImluZGV4IiwicGF0aFRvUmVnZXhwIiwicGFyc2VfMSIsImNvbXBpbGVfMSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uXzEiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHBfMSIsInRva2Vuc1RvUmVnRXhwIiwiUEFUSF9SRUdFWFAiLCJSZWdFeHAiLCJ0b2tlbnMiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsInZhbHVlIiwiVHlwZUVycm9yIiwiSlNPTiIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwic291cmNlIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImNyZWF0ZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsImNyZWF0ZVJvdXRlTWFwIiwicm91dGVzIiwib2xkUGF0aExpc3QiLCJvbGRQYXRoTWFwIiwib2xkTmFtZU1hcCIsInBhdGhMaXN0IiwicGF0aE1hcCIsIm5hbWVNYXAiLCJhZGRSb3V0ZVJlY29yZCIsImwiLCJzcGxpY2UiLCJtYXRjaEFzIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVQYXRoIiwicGF0aFRvUmVnZXhwT3B0aW9ucyIsImNhc2VTZW5zaXRpdmUiLCJyZWdleCIsImNvbXBpbGVSb3V0ZVJlZ2V4IiwicmVkaXJlY3QiLCJiZWZvcmVFbnRlciIsInNvbWUiLCJjaGlsZE1hdGNoQXMiLCJhbGlhcyIsImFsaWFzZXMiLCJhbGlhc1JvdXRlIiwibm9ybWFsaXplTG9jYXRpb24iLCJyYXciLCJfbm9ybWFsaXplZCIsImFzc2lnbiIsInJhd1BhdGgiLCJwYXJzZWRQYXRoIiwiYmFzZVBhdGgiLCJjcmVhdGVNYXRjaGVyIiwiYWRkUm91dGVzIiwiY3VycmVudFJvdXRlIiwiX2NyZWF0ZVJvdXRlIiwicGFyYW1OYW1lcyIsInJlY29yZCQxIiwibWF0Y2hSb3V0ZSIsIm9yaWdpbmFsUmVkaXJlY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInRhcmdldFJlY29yZCIsInJlc29sdmVSZWNvcmRQYXRoIiwicmVzb2x2ZWRQYXRoIiwiYWxpYXNlZFBhdGgiLCJhbGlhc2VkTWF0Y2giLCJhbGlhc2VkUmVjb3JkIiwibGVuIiwicG9zaXRpb25TdG9yZSIsInNldHVwU2Nyb2xsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInN0YXRlIiwic2V0U3RhdGVLZXkiLCJoYW5kbGVTY3JvbGwiLCJmcm9tIiwiaXNQb3AiLCJhcHAiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwiJG5leHRUaWNrIiwicG9zaXRpb24iLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNob3VsZFNjcm9sbCIsImlzT2JqZWN0Iiwic2VsZWN0b3IiLCJlbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm5vcm1hbGl6ZU9mZnNldCIsImdldEVsZW1lbnRQb3NpdGlvbiIsImlzVmFsaWRQb3NpdGlvbiIsIm5vcm1hbGl6ZVBvc2l0aW9uIiwic2Nyb2xsVG8iLCJ5IiwiZ2V0U3RhdGVLZXkiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiZG9jRWwiLCJkb2N1bWVudEVsZW1lbnQiLCJkb2NSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxSZWN0IiwibGVmdCIsInRvcCIsImlzTnVtYmVyIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJfa2V5IiwiZ2VuS2V5IiwidG9GaXhlZCIsInB1c2hTdGF0ZSIsInVybCIsInJlcGxhY2VTdGF0ZSIsInJ1blF1ZXVlIiwicXVldWUiLCJmbiIsImNiIiwic3RlcCIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJoYXNBc3luYyIsInBlbmRpbmciLCJlcnJvciIsImZsYXRNYXBDb21wb25lbnRzIiwiZGVmIiwiY2lkIiwib25jZSIsInJlc29sdmVkRGVmIiwiX19lc01vZHVsZSIsInJlc29sdmVkIiwicmVqZWN0IiwicmVhc29uIiwibXNnIiwidGhlbiIsImNvbXAiLCJmbGF0dGVuIiwiY29uY2F0IiwiYXBwbHkiLCJjYWxsZWQiLCJhcmdzIiwiYXJndW1lbnRzIiwiSGlzdG9yeSIsIm5vcm1hbGl6ZUJhc2UiLCJyZWFkeSIsInJlYWR5Q2JzIiwicmVhZHlFcnJvckNicyIsImVycm9yQ2JzIiwibGlzdGVuIiwib25SZWFkeSIsImVycm9yQ2IiLCJvbkVycm9yIiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsIml0ZXJhdG9yIiwicG9zdEVudGVyQ2JzIiwiaXNWYWxpZCIsImVudGVyR3VhcmRzIiwiZXh0cmFjdEVudGVyR3VhcmRzIiwicmVzb2x2ZUhvb2tzIiwicHJldiIsImFmdGVySG9va3MiLCJiYXNlRWwiLCJtYXgiLCJNYXRoIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJiaW5kIiwicmV2ZXJzZSIsImd1YXJkcyIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJjYnMiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJzZXRUaW1lb3V0IiwiSFRNTDVIaXN0b3J5IiwiSGlzdG9yeSQkMSIsImV4cGVjdFNjcm9sbCIsImdldExvY2F0aW9uIiwiX19wcm90b19fIiwiY29uc3RydWN0b3IiLCJnbyIsIm4iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsIkhhc2hIaXN0b3J5IiwiZmFsbGJhY2siLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsImdldEhhc2giLCJyZXBsYWNlSGFzaCIsInB1c2hIYXNoIiwiQWJzdHJhY3RIaXN0b3J5IiwidGFyZ2V0SW5kZXgiLCJWdWVSb3V0ZXIiLCJhcHBzIiwibWF0Y2hlciIsIm1vZGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJzZXR1cEhhc2hMaXN0ZW5lciIsImJlZm9yZUVhY2giLCJyZWdpc3Rlckhvb2siLCJiZWZvcmVSZXNvbHZlIiwiYWZ0ZXJFYWNoIiwiYmFjayIsImZvcndhcmQiLCJnZXRNYXRjaGVkQ29tcG9uZW50cyIsImNyZWF0ZUhyZWYiLCJub3JtYWxpemVkVG8iLCJkZWZpbmVQcm9wZXJ0aWVzIiwibGlzdCIsInZlcnNpb24iLCJ1c2UiXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7OztBQUtBOztBQUVBLFNBQVNBLE1BQVQsQ0FBaUJDLFNBQWpCLEVBQTRCQyxPQUE1QixFQUFxQztBQUNuQyxNQUFJLENBQUNELFNBQUwsRUFBZ0I7QUFDZCxVQUFNLElBQUlFLEtBQUosQ0FBVyxrQkFBa0JELE9BQTdCLENBQU47QUFDRDtBQUNGOztBQUVELFNBQVNFLElBQVQsQ0FBZUgsU0FBZixFQUEwQkMsT0FBMUIsRUFBbUM7QUFDakMsTUFBSUcsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDLENBQUNOLFNBQTlDLEVBQXlEO0FBQ3ZELFdBQU9PLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NBLFFBQVFKLElBQVIsQ0FBYyxrQkFBa0JGLE9BQWhDLENBQWxDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTTyxPQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNy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LEdBQXhCLEVBQTZCO0FBQzNCeUIsU0FBT3pCLEdBQVAsQ0FBV2dVLEdBQVgsQ0FBZWxCLFNBQWY7QUFDRDs7QUFFRCwrREFBZUEsU0FBZixFIiwiZmlsZSI6IjEzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAqIHZ1ZS1yb3V0ZXIgdjIuNy4wXG4gICogKGMpIDIwMTcgRXZhbiBZb3VcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qICAqL1xuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmRpdGlvbikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4oKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IgKGVycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikuaW5kZXhPZignRXJyb3InKSA+IC0xXG59XG5cbnZhciBWaWV3ID0ge1xuICBuYW1lOiAncm91dGVyLXZpZXcnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKF8sIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgIGRhdGEucm91dGVyVmlldyA9IHRydWU7XG5cbiAgICAvLyBkaXJlY3RseSB1c2UgcGFyZW50IGNvbnRleHQncyBjcmVhdGVFbGVtZW50KCkgZnVuY3Rpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBvbmVudHMgcmVuZGVyZWQgYnkgcm91dGVyLXZpZXcgY2FuIHJlc29sdmUgbmFtZWQgc2xvdHNcbiAgICB2YXIgaCA9IHBhcmVudC4kY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gICAgdmFyIHJvdXRlID0gcGFyZW50LiRyb3V0ZTtcbiAgICB2YXIgY2FjaGUgPSBwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSB8fCAocGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgPSB7fSk7XG5cbiAgICAvLyBkZXRlcm1pbmUgY3VycmVudCB2aWV3IGRlcHRoLCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHJlZVxuICAgIC8vIGhhcyBiZWVuIHRvZ2dsZWQgaW5hY3RpdmUgYnV0IGtlcHQtYWxpdmUuXG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB2YXIgaW5hY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5fcm91dGVyUm9vdCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LiR2bm9kZSAmJiBwYXJlbnQuJHZub2RlLmRhdGEucm91dGVyVmlldykge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5faW5hY3RpdmUpIHtcbiAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIGRhdGEucm91dGVyVmlld0RlcHRoID0gZGVwdGg7XG5cbiAgICAvLyByZW5kZXIgcHJldmlvdXMgdmlldyBpZiB0aGUgdHJlZSBpcyBpbmFjdGl2ZSBhbmQga2VwdC1hbGl2ZVxuICAgIGlmIChpbmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGgoY2FjaGVbbmFtZV0sIGRhdGEsIGNoaWxkcmVuKVxuICAgIH1cblxuICAgIHZhciBtYXRjaGVkID0gcm91dGUubWF0Y2hlZFtkZXB0aF07XG4gICAgLy8gcmVuZGVyIGVtcHR5IG5vZGUgaWYgbm8gbWF0Y2hlZCByb3V0ZVxuICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgY2FjaGVbbmFtZV0gPSBudWxsO1xuICAgICAgcmV0dXJuIGgoKVxuICAgIH1cblxuICAgIHZhciBjb21wb25lbnQgPSBjYWNoZVtuYW1lXSA9IG1hdGNoZWQuY29tcG9uZW50c1tuYW1lXTtcblxuICAgIC8vIGF0dGFjaCBpbnN0YW5jZSByZWdpc3RyYXRpb24gaG9va1xuICAgIC8vIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGluc3RhbmNlJ3MgaW5qZWN0ZWQgbGlmZWN5Y2xlIGhvb2tzXG4gICAgZGF0YS5yZWdpc3RlclJvdXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIHZhbCkge1xuICAgICAgLy8gdmFsIGNvdWxkIGJlIHVuZGVmaW5lZCBmb3IgdW5yZWdpc3RyYXRpb25cbiAgICAgIHZhciBjdXJyZW50ID0gbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgICh2YWwgJiYgY3VycmVudCAhPT0gdm0pIHx8XG4gICAgICAgICghdmFsICYmIGN1cnJlbnQgPT09IHZtKVxuICAgICAgKSB7XG4gICAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsc28gcmVnaXNldGVyIGluc3RhbmNlIGluIHByZXBhdGNoIGhvb2tcbiAgICAvLyBpbiBjYXNlIHRoZSBzYW1lIGNvbXBvbmVudCBpbnN0YW5jZSBpcyByZXVzZWQgYWNyb3NzIGRpZmZlcmVudCByb3V0ZXNcbiAgICA7KGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pKS5wcmVwYXRjaCA9IGZ1bmN0aW9uIChfLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgLy8gcmVzb2x2ZSBwcm9wc1xuICAgIGRhdGEucHJvcHMgPSByZXNvbHZlUHJvcHMocm91dGUsIG1hdGNoZWQucHJvcHMgJiYgbWF0Y2hlZC5wcm9wc1tuYW1lXSk7XG5cbiAgICByZXR1cm4gaChjb21wb25lbnQsIGRhdGEsIGNoaWxkcmVuKVxuICB9XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlUHJvcHMgKHJvdXRlLCBjb25maWcpIHtcbiAgc3dpdGNoICh0eXBlb2YgY29uZmlnKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVyblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gY29uZmlnXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGNvbmZpZyhyb3V0ZSlcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjb25maWcgPyByb3V0ZS5wYXJhbXMgOiB1bmRlZmluZWRcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIFwiICtcbiAgICAgICAgICBcImV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XG52YXIgY29tbWFSRSA9IC8lMkMvZztcblxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29uZm9ybWFudCB0byBSRkMzOTg2OlxuLy8gLSBlc2NhcGVzIFshJygpKl1cbi8vIC0gcHJlc2VydmUgY29tbWFzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgLnJlcGxhY2UoZW5jb2RlUmVzZXJ2ZVJFLCBlbmNvZGVSZXNlcnZlUmVwbGFjZXIpXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG4gIHF1ZXJ5LFxuICBleHRyYVF1ZXJ5LFxuICBfcGFyc2VRdWVyeVxuKSB7XG4gIGlmICggZXh0cmFRdWVyeSA9PT0gdm9pZCAwICkgZXh0cmFRdWVyeSA9IHt9O1xuXG4gIHZhciBwYXJzZSA9IF9wYXJzZVF1ZXJ5IHx8IHBhcnNlUXVlcnk7XG4gIHZhciBwYXJzZWRRdWVyeTtcbiAgdHJ5IHtcbiAgICBwYXJzZWRRdWVyeSA9IHBhcnNlKHF1ZXJ5IHx8ICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcbiAgICBwYXJzZWRRdWVyeSA9IHt9O1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XG4gICAgdmFyIHZhbCA9IGV4dHJhUXVlcnlba2V5XTtcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsLnNsaWNlKCkgOiB2YWw7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFF1ZXJ5XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkgKHF1ZXJ5KSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xuICAgIHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwXG4gICAgICA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAocmVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc1trZXldKSkge1xuICAgICAgcmVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNba2V5XSA9IFtyZXNba2V5XSwgdmFsXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkgKG9iaikge1xuICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcbiAgICAgICAgaWYgKHZhbDIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbDIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKVxuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwpXG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9KS5qb2luKCcmJykgOiBudWxsO1xuICByZXR1cm4gcmVzID8gKFwiP1wiICsgcmVzKSA6ICcnXG59XG5cbi8qICAqL1xuXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tLFxuICByb3V0ZXJcbikge1xuICB2YXIgc3RyaW5naWZ5UXVlcnkkJDEgPSByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG4gIHZhciByb3V0ZSA9IHtcbiAgICBuYW1lOiBsb2NhdGlvbi5uYW1lIHx8IChyZWNvcmQgJiYgcmVjb3JkLm5hbWUpLFxuICAgIG1ldGE6IChyZWNvcmQgJiYgcmVjb3JkLm1ldGEpIHx8IHt9LFxuICAgIHBhdGg6IGxvY2F0aW9uLnBhdGggfHwgJy8nLFxuICAgIGhhc2g6IGxvY2F0aW9uLmhhc2ggfHwgJycsXG4gICAgcXVlcnk6IGxvY2F0aW9uLnF1ZXJ5IHx8IHt9LFxuICAgIHBhcmFtczogbG9jYXRpb24ucGFyYW1zIHx8IHt9LFxuICAgIGZ1bGxQYXRoOiBnZXRGdWxsUGF0aChsb2NhdGlvbiwgc3RyaW5naWZ5UXVlcnkkJDEpLFxuICAgIG1hdGNoZWQ6IHJlY29yZCA/IGZvcm1hdE1hdGNoKHJlY29yZCkgOiBbXVxuICB9O1xuICBpZiAocmVkaXJlY3RlZEZyb20pIHtcbiAgICByb3V0ZS5yZWRpcmVjdGVkRnJvbSA9IGdldEZ1bGxQYXRoKHJlZGlyZWN0ZWRGcm9tLCBzdHJpbmdpZnlRdWVyeSQkMSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAoXG4gIHJlZixcbiAgX3N0cmluZ2lmeVF1ZXJ5XG4pIHtcbiAgdmFyIHBhdGggPSByZWYucGF0aDtcbiAgdmFyIHF1ZXJ5ID0gcmVmLnF1ZXJ5OyBpZiAoIHF1ZXJ5ID09PSB2b2lkIDAgKSBxdWVyeSA9IHt9O1xuICB2YXIgaGFzaCA9IHJlZi5oYXNoOyBpZiAoIGhhc2ggPT09IHZvaWQgMCApIGhhc2ggPSAnJztcblxuICB2YXIgc3RyaW5naWZ5ID0gX3N0cmluZ2lmeVF1ZXJ5IHx8IHN0cmluZ2lmeVF1ZXJ5O1xuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHN0cmluZ2lmeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGFWYWwgPSBhW2tleV07XG4gICAgdmFyIGJWYWwgPSBiW2tleV07XG4gICAgLy8gY2hlY2sgbmVzdGVkIGVxdWFsaXR5XG4gICAgaWYgKHR5cGVvZiBhVmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYlZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYVZhbCkgPT09IFN0cmluZyhiVmFsKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIExpbmsgPSB7XG4gIG5hbWU6ICdyb3V0ZXItbGluaycsXG4gIHByb3BzOiB7XG4gICAgdG86IHtcbiAgICAgIHR5cGU6IHRvVHlwZXMsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYSdcbiAgICB9LFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBldmVudFR5cGVzLFxuICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZTtcbiAgICB2YXIgcmVmID0gcm91dGVyLnJlc29sdmUodGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpO1xuICAgIHZhciBsb2NhdGlvbiA9IHJlZi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcblxuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgdmFyIGdsb2JhbEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3M7XG4gICAgLy8gU3VwcG9ydCBnbG9iYWwgZW1wdHkgYWN0aXZlIGNsYXNzXG4gICAgdmFyIGFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWV4YWN0LWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gYWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzID0gdGhpcy5leGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGhcbiAgICAgID8gY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcilcbiAgICAgIDogcm91dGU7XG5cbiAgICBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdID0gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgPSBleHRlbmQoe30sIGEuZGF0YSk7XG4gICAgICAgIGFEYXRhLm9uID0gb247XG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcbiAgICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59O1xuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICB2YXIgaXNEZWYgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9O1xuXG4gIHZhciByZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCBjYWxsVmFsKSB7XG4gICAgdmFyIGkgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLmRhdGEpICYmIGlzRGVmKGkgPSBpLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSkpIHtcbiAgICAgIGkodm0sIGNhbGxWYWwpO1xuICAgIH1cbiAgfTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmIChpc0RlZih0aGlzLiRvcHRpb25zLnJvdXRlcikpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuJG9wdGlvbnMucm91dGVyO1xuICAgICAgICB0aGlzLl9yb3V0ZXIuaW5pdCh0aGlzKTtcbiAgICAgICAgVnVlLnV0aWwuZGVmaW5lUmVhY3RpdmUodGhpcywgJ19yb3V0ZScsIHRoaXMuX3JvdXRlci5oaXN0b3J5LmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9ICh0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50Ll9yb3V0ZXJSb290KSB8fCB0aGlzO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCB0aGlzKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGUgfVxuICB9KTtcblxuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItdmlldycsIFZpZXcpO1xuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItbGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxuICByZWxhdGl2ZSxcbiAgYmFzZSxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGZpcnN0Q2hhciA9IHJlbGF0aXZlLmNoYXJBdCgwKTtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlXG4gIH1cblxuICBpZiAoZmlyc3RDaGFyID09PSAnPycgfHwgZmlyc3RDaGFyID09PSAnIycpIHtcbiAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlXG4gIH1cblxuICB2YXIgc3RhY2sgPSBiYXNlLnNwbGl0KCcvJyk7XG5cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlZ21lbnQgaWY6XG4gIC8vIC0gbm90IGFwcGVuZGluZ1xuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICBpZiAoIWFwcGVuZCB8fCAhc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuICBpZiAoc3RhY2tbMF0gIT09ICcnKSB7XG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gIH1cblxuICByZXR1cm4gc3RhY2suam9pbignLycpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgcXVlcnkgPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxdWVyeUluZGV4ID49IDApIHtcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHF1ZXJ5SW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5QYXRoIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXG59XG5cbnZhciBpbmRleCQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbnZhciBpbmRleCA9IHBhdGhUb1JlZ2V4cDtcbnZhciBwYXJzZV8xID0gcGFyc2U7XG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcbnZhciB0b2tlbnNUb0Z1bmN0aW9uXzEgPSB0b2tlbnNUb0Z1bmN0aW9uO1xudmFyIHRva2Vuc1RvUmVnRXhwXzEgPSB0b2tlbnNUb1JlZ0V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIga2V5ID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHBhdGggPSAnJztcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJztcbiAgdmFyIHJlcztcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdO1xuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXg7XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldCk7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV07XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XTtcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xuICAgIHZhciBuYW1lID0gcmVzWzNdO1xuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdO1xuICAgIHZhciBncm91cCA9IHJlc1s1XTtcbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl07XG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddO1xuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgICBwYXRoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4O1xuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlcjtcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXA7XG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXgkMSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpbmRleCQxKGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSAnJztcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeCk7XG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcblxuICAgICAga2V5cy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJyk7XG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaW5kZXgkMShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaW5kZXgkMShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cblxuaW5kZXgucGFyc2UgPSBwYXJzZV8xO1xuaW5kZXguY29tcGlsZSA9IGNvbXBpbGVfMTtcbmluZGV4LnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XG5pbmRleC50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XG5cbi8qICAqL1xuXG52YXIgcmVnZXhwQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gZmlsbFBhcmFtcyAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcm91dGVNc2dcbikge1xuICB0cnkge1xuICAgIHZhciBmaWxsZXIgPVxuICAgICAgcmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdIHx8XG4gICAgICAocmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdID0gaW5kZXguY29tcGlsZShwYXRoKSk7XG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZU1hcCAoXG4gIHJvdXRlcyxcbiAgb2xkUGF0aExpc3QsXG4gIG9sZFBhdGhNYXAsXG4gIG9sZE5hbWVNYXBcbikge1xuICAvLyB0aGUgcGF0aCBsaXN0IGlzIHVzZWQgdG8gY29udHJvbCBwYXRoIG1hdGNoaW5nIHByaW9yaXR5XG4gIHZhciBwYXRoTGlzdCA9IG9sZFBhdGhMaXN0IHx8IFtdO1xuICB2YXIgcGF0aE1hcCA9IG9sZFBhdGhNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG5hbWVNYXAgPSBvbGROYW1lTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgLy8gZW5zdXJlIHdpbGRjYXJkIHJvdXRlcyBhcmUgYWx3YXlzIGF0IHRoZSBlbmRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocGF0aExpc3RbaV0gPT09ICcqJykge1xuICAgICAgcGF0aExpc3QucHVzaChwYXRoTGlzdC5zcGxpY2UoaSwgMSlbMF0pO1xuICAgICAgbC0tO1xuICAgICAgaS0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aExpc3Q6IHBhdGhMaXN0LFxuICAgIHBhdGhNYXA6IHBhdGhNYXAsXG4gICAgbmFtZU1hcDogbmFtZU1hcFxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcbiAgcGF0aExpc3QsXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQocGF0aCAhPSBudWxsLCBcIlxcXCJwYXRoXFxcIiBpcyByZXF1aXJlZCBpbiBhIHJvdXRlIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiByb3V0ZS5jb21wb25lbnQgIT09ICdzdHJpbmcnLFxuICAgICAgXCJyb3V0ZSBjb25maWcgXFxcImNvbXBvbmVudFxcXCIgZm9yIHBhdGg6IFwiICsgKFN0cmluZyhwYXRoIHx8IG5hbWUpKSArIFwiIGNhbm5vdCBiZSBhIFwiICtcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCwgcGFyZW50KTtcbiAgdmFyIHBhdGhUb1JlZ2V4cE9wdGlvbnMgPSByb3V0ZS5wYXRoVG9SZWdleHBPcHRpb25zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2Ygcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zZW5zaXRpdmUgPSByb3V0ZS5jYXNlU2Vuc2l0aXZlO1xuICB9XG5cbiAgdmFyIHJlY29yZCA9IHtcbiAgICBwYXRoOiBub3JtYWxpemVkUGF0aCxcbiAgICByZWdleDogY29tcGlsZVJvdXRlUmVnZXgobm9ybWFsaXplZFBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpLFxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcbiAgICBpbnN0YW5jZXM6IHt9LFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcbiAgICByZWRpcmVjdDogcm91dGUucmVkaXJlY3QsXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXG4gICAgcHJvcHM6IHJvdXRlLnByb3BzID09IG51bGxcbiAgICAgID8ge31cbiAgICAgIDogcm91dGUuY29tcG9uZW50c1xuICAgICAgICA/IHJvdXRlLnByb3BzXG4gICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XG4gIH07XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCwgZG9lcyBub3QgcmVkaXJlY3QgYW5kIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuXG4gICAgLy8gSWYgdXNlcnMgbmF2aWdhdGUgdG8gdGhpcyByb3V0ZSBieSBuYW1lLCB0aGUgZGVmYXVsdCBjaGlsZCB3aWxsXG4gICAgLy8gbm90IGJlIHJlbmRlcmVkIChHSCBJc3N1ZSAjNjI5KVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocm91dGUubmFtZSAmJiAhcm91dGUucmVkaXJlY3QgJiYgcm91dGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIC9eXFwvPyQvLnRlc3QoY2hpbGQucGF0aCk7IH0pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJOYW1lZCBSb3V0ZSAnXCIgKyAocm91dGUubmFtZSkgKyBcIicgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS4gXCIgK1xuICAgICAgICAgIFwiV2hlbiBuYXZpZ2F0aW5nIHRvIHRoaXMgbmFtZWQgcm91dGUgKDp0bz1cXFwie25hbWU6ICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJ1xcXCIpLCBcIiArXG4gICAgICAgICAgXCJ0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUmVtb3ZlIHRoZSBuYW1lIGZyb20gXCIgK1xuICAgICAgICAgIFwidGhpcyByb3V0ZSBhbmQgdXNlIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIGZvciBuYW1lZCBcIiArXG4gICAgICAgICAgXCJsaW5rcyBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRNYXRjaEFzID0gbWF0Y2hBc1xuICAgICAgICA/IGNsZWFuUGF0aCgobWF0Y2hBcyArIFwiL1wiICsgKGNoaWxkLnBhdGgpKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGFsaWFzZXMgPSBBcnJheS5pc0FycmF5KHJvdXRlLmFsaWFzKVxuICAgICAgPyByb3V0ZS5hbGlhc1xuICAgICAgOiBbcm91dGUuYWxpYXNdO1xuXG4gICAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgIHBhdGg6IGFsaWFzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgIH07XG4gICAgICBhZGRSb3V0ZVJlY29yZChcbiAgICAgICAgcGF0aExpc3QsXG4gICAgICAgIHBhdGhNYXAsXG4gICAgICAgIG5hbWVNYXAsXG4gICAgICAgIGFsaWFzUm91dGUsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcmVjb3JkLnBhdGggfHwgJy8nIC8vIG1hdGNoQXNcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XG4gICAgcGF0aExpc3QucHVzaChyZWNvcmQucGF0aCk7XG4gICAgcGF0aE1hcFtyZWNvcmQucGF0aF0gPSByZWNvcmQ7XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIW1hdGNoQXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkR1cGxpY2F0ZSBuYW1lZCByb3V0ZXMgZGVmaW5pdGlvbjogXCIgK1xuICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVSb3V0ZVJlZ2V4IChwYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSB7XG4gIHZhciByZWdleCA9IGluZGV4KHBhdGgsIFtdLCBwYXRoVG9SZWdleHBPcHRpb25zKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIga2V5cyA9IHt9O1xuICAgIHJlZ2V4LmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB3YXJuKCFrZXlzW2tleS5uYW1lXSwgKFwiRHVwbGljYXRlIHBhcmFtIGtleXMgaW4gcm91dGUgd2l0aCBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIGtleXNba2V5Lm5hbWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVnZXhcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aCAocGF0aCwgcGFyZW50KSB7XG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gIGlmIChwYXRoWzBdID09PSAnLycpIHsgcmV0dXJuIHBhdGggfVxuICBpZiAocGFyZW50ID09IG51bGwpIHsgcmV0dXJuIHBhdGggfVxuICByZXR1cm4gY2xlYW5QYXRoKCgocGFyZW50LnBhdGgpICsgXCIvXCIgKyBwYXRoKSlcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24gKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIGFwcGVuZCxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIG5leHQgPSB0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmF3IH0gOiByYXc7XG4gIC8vIG5hbWVkIHRhcmdldFxuICBpZiAobmV4dC5uYW1lIHx8IG5leHQuX25vcm1hbGl6ZWQpIHtcbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgLy8gcmVsYXRpdmUgcGFyYW1zXG4gIGlmICghbmV4dC5wYXRoICYmIG5leHQucGFyYW1zICYmIGN1cnJlbnQpIHtcbiAgICBuZXh0ID0gYXNzaWduKHt9LCBuZXh0KTtcbiAgICBuZXh0Ll9ub3JtYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgcGFyYW1zID0gYXNzaWduKGFzc2lnbih7fSwgY3VycmVudC5wYXJhbXMpLCBuZXh0LnBhcmFtcyk7XG4gICAgaWYgKGN1cnJlbnQubmFtZSkge1xuICAgICAgbmV4dC5uYW1lID0gY3VycmVudC5uYW1lO1xuICAgICAgbmV4dC5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Lm1hdGNoZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgcmF3UGF0aCA9IGN1cnJlbnQubWF0Y2hlZFtjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aDtcbiAgICAgIG5leHQucGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJwYXRoIFwiICsgKGN1cnJlbnQucGF0aCkpKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJyk7XG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxuICAgID8gcmVzb2x2ZVBhdGgocGFyc2VkUGF0aC5wYXRoLCBiYXNlUGF0aCwgYXBwZW5kIHx8IG5leHQuYXBwZW5kKVxuICAgIDogYmFzZVBhdGg7XG5cbiAgdmFyIHF1ZXJ5ID0gcmVzb2x2ZVF1ZXJ5KFxuICAgIHBhcnNlZFBhdGgucXVlcnksXG4gICAgbmV4dC5xdWVyeSxcbiAgICByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMucGFyc2VRdWVyeVxuICApO1xuXG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlciAoXG4gIHJvdXRlcyxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG4gIHZhciBwYXRoTGlzdCA9IHJlZi5wYXRoTGlzdDtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKFxuICAgIHJhdyxcbiAgICBjdXJyZW50Um91dGUsXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24ocmF3LCBjdXJyZW50Um91dGUsIGZhbHNlLCByb3V0ZXIpO1xuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4ocmVjb3JkLCAoXCJSb3V0ZSB3aXRoIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlY29yZCkgeyByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKSB9XG4gICAgICB2YXIgcGFyYW1OYW1lcyA9IHJlY29yZC5yZWdleC5rZXlzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWtleS5vcHRpb25hbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkubmFtZTsgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24ucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRSb3V0ZSAmJiB0eXBlb2YgY3VycmVudFJvdXRlLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRSb3V0ZS5wYXJhbXMpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbG9jYXRpb24ucGFyYW1zKSAmJiBwYXJhbU5hbWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXNba2V5XSA9IGN1cnJlbnRSb3V0ZS5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhMaXN0W2ldO1xuICAgICAgICB2YXIgcmVjb3JkJDEgPSBwYXRoTWFwW3BhdGhdO1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShyZWNvcmQkMS5yZWdleCwgbG9jYXRpb24ucGF0aCwgbG9jYXRpb24ucGFyYW1zKSkge1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkJDEsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBubyBtYXRjaFxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiByZWRpcmVjdCAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uXG4gICkge1xuICAgIHZhciBvcmlnaW5hbFJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xuICAgIHZhciByZWRpcmVjdCA9IHR5cGVvZiBvcmlnaW5hbFJlZGlyZWN0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3JpZ2luYWxSZWRpcmVjdChjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpKVxuICAgICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcbiAgcmVnZXgsXG4gIHBhdGgsXG4gIHBhcmFtc1xuKSB7XG4gIHZhciBtID0gcGF0aC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBrZXkgPSByZWdleC5rZXlzW2kgLSAxXTtcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoLCByZWNvcmQpIHtcbiAgcmV0dXJuIHJlc29sdmVQYXRoKHBhdGgsIHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnBhdGggOiAnLycsIHRydWUpXG59XG5cbi8qICAqL1xuXG5cbnZhciBwb3NpdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gc2V0dXBTY3JvbGwgKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAgIGlmIChlLnN0YXRlICYmIGUuc3RhdGUua2V5KSB7XG4gICAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsIChcbiAgcm91dGVyLFxuICB0byxcbiAgZnJvbSxcbiAgaXNQb3Bcbikge1xuICBpZiAoIXJvdXRlci5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICBpZiAoIWJlaGF2aW9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IodG8sIGZyb20sIGlzUG9wID8gcG9zaXRpb24gOiBudWxsKTtcbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xuICAgIGlmIChpc09iamVjdCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaG91bGRTY3JvbGwuc2VsZWN0b3IpO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzaG91bGRTY3JvbGwub2Zmc2V0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwub2Zmc2V0ID09PSAnb2JqZWN0JyA/IHNob3VsZFNjcm9sbC5vZmZzZXQgOiB7fTtcbiAgICAgICAgb2Zmc2V0ID0gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwsIG9mZnNldCkge1xuICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBkb2NSZWN0ID0gZG9jRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCAtIG9mZnNldC54LFxuICAgIHk6IGVsUmVjdC50b3AgLSBkb2NSZWN0LnRvcCAtIG9mZnNldC55XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT2Zmc2V0IChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IDAsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xufVxuXG4vKiAgKi9cblxudmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gaW5Ccm93c2VyICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmIChcbiAgICAodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcbiAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxufSkoKTtcblxuLy8gdXNlIFVzZXIgVGltaW5nIGFwaSAoaWYgcHJlc2VudCkgZm9yIG1vcmUgYWNjdXJhdGUga2V5IHByZWNpc2lvblxudmFyIFRpbWUgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcbiAgPyB3aW5kb3cucGVyZm9ybWFuY2VcbiAgOiBEYXRlO1xuXG52YXIgX2tleSA9IGdlbktleSgpO1xuXG5mdW5jdGlvbiBnZW5LZXkgKCkge1xuICByZXR1cm4gVGltZS5ub3coKS50b0ZpeGVkKDMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIF9rZXlcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xuICBfa2V5ID0ga2V5O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgdmFyIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXkgPSBnZW5LZXkoKTtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVN0YXRlICh1cmwpIHtcbiAgcHVzaFN0YXRlKHVybCwgdHJ1ZSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBydW5RdWV1ZSAocXVldWUsIGZuLCBjYikge1xuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZVtpbmRleF0pIHtcbiAgICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0ZXAoMCk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRzIChtYXRjaGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIG5leHQpIHtcbiAgICB2YXIgaGFzQXN5bmMgPSBmYWxzZTtcbiAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcblxuICAgIGZsYXRNYXBDb21wb25lbnRzKG1hdGNoZWQsIGZ1bmN0aW9uIChkZWYsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICAgIC8vIGlmIGl0J3MgYSBmdW5jdGlvbiBhbmQgZG9lc24ndCBoYXZlIGNpZCBhdHRhY2hlZCxcbiAgICAgIC8vIGFzc3VtZSBpdCdzIGFuIGFzeW5jIGNvbXBvbmVudCByZXNvbHZlIGZ1bmN0aW9uLlxuICAgICAgLy8gd2UgYXJlIG5vdCB1c2luZyBWdWUncyBkZWZhdWx0IGFzeW5jIHJlc29sdmluZyBtZWNoYW5pc20gYmVjYXVzZVxuICAgICAgLy8gd2Ugd2FudCB0byBoYWx0IHRoZSBuYXZpZ2F0aW9uIHVudGlsIHRoZSBpbmNvbWluZyBjb21wb25lbnQgaGFzIGJlZW5cbiAgICAgIC8vIHJlc29sdmVkLlxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZGVmLmNpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhhc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgcGVuZGluZysrO1xuXG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzb2x2ZWREZWYpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWREZWYuX19lc01vZHVsZSAmJiByZXNvbHZlZERlZi5kZWZhdWx0KSB7XG4gICAgICAgICAgICByZXNvbHZlZERlZiA9IHJlc29sdmVkRGVmLmRlZmF1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNhdmUgcmVzb2x2ZWQgb24gYXN5bmMgZmFjdG9yeSBpbiBjYXNlIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgICBkZWYucmVzb2x2ZWQgPSB0eXBlb2YgcmVzb2x2ZWREZWYgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcmVzb2x2ZWREZWZcbiAgICAgICAgICAgIDogX1Z1ZS5leHRlbmQocmVzb2x2ZWREZWYpO1xuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xuICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICBpZiAocGVuZGluZyA8PSAwKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50IFwiICsga2V5ICsgXCI6IFwiICsgcmVhc29uO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgbXNnKTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGlzRXJyb3IocmVhc29uKVxuICAgICAgICAgICAgICA/IHJlYXNvblxuICAgICAgICAgICAgICA6IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgc3ludGF4IGluIFZ1ZSAyLjNcbiAgICAgICAgICAgIHZhciBjb21wID0gcmVzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wICYmIHR5cGVvZiBjb21wLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY29tcC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWhhc0FzeW5jKSB7IG5leHQoKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB0aGlzLmJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAvLyBzdGFydCB3aXRoIGEgcm91dGUgb2JqZWN0IHRoYXQgc3RhbmRzIGZvciBcIm5vd2hlcmVcIlxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICB0aGlzLnJlYWR5Q2JzID0gW107XG4gIHRoaXMucmVhZHlFcnJvckNicyA9IFtdO1xuICB0aGlzLmVycm9yQ2JzID0gW107XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4gKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xuICBpZiAodGhpcy5yZWFkeSkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWFkeUNicy5wdXNoKGNiKTtcbiAgICBpZiAoZXJyb3JDYikge1xuICAgICAgdGhpcy5yZWFkeUVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG4gICAgfVxuICB9XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8gKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XG4gIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgdGhpcyQxLmVuc3VyZVVSTCgpO1xuXG4gICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxuICAgIGlmICghdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKHJvdXRlKTsgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKG9uQWJvcnQpIHtcbiAgICAgIG9uQWJvcnQoZXJyKTtcbiAgICB9XG4gICAgaWYgKGVyciAmJiAhdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5RXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmNvbmZpcm1UcmFuc2l0aW9uID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb24gKHJvdXRlLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgICBpZiAodGhpcyQxLmVycm9yQ2JzLmxlbmd0aCkge1xuICAgICAgICB0aGlzJDEuZXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGZhbHNlLCAndW5jYXVnaHQgZXJyb3IgZHVyaW5nIHJvdXRlIG5hdmlnYXRpb246Jyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25BYm9ydCAmJiBvbkFib3J0KGVycik7XG4gIH07XG4gIGlmIChcbiAgICBpc1NhbWVSb3V0ZShyb3V0ZSwgY3VycmVudCkgJiZcbiAgICAvLyBpbiB0aGUgY2FzZSB0aGUgcm91dGUgbWFwIGhhcyBiZWVuIGR5bmFtaWNhbGx5IGFwcGVuZGVkIHRvXG4gICAgcm91dGUubWF0Y2hlZC5sZW5ndGggPT09IGN1cnJlbnQubWF0Y2hlZC5sZW5ndGhcbiAgKSB7XG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcbiAgICByZXR1cm4gYWJvcnQoKVxuICB9XG5cbiAgdmFyIHJlZiA9IHJlc29sdmVRdWV1ZSh0aGlzLmN1cnJlbnQubWF0Y2hlZCwgcm91dGUubWF0Y2hlZCk7XG4gICAgdmFyIHVwZGF0ZWQgPSByZWYudXBkYXRlZDtcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XG4gICAgdmFyIGFjdGl2YXRlZCA9IHJlZi5hY3RpdmF0ZWQ7XG5cbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxuICAgIC8vIGluLWNvbXBvbmVudCBsZWF2ZSBndWFyZHNcbiAgICBleHRyYWN0TGVhdmVHdWFyZHMoZGVhY3RpdmF0ZWQpLFxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcbiAgICB0aGlzLnJvdXRlci5iZWZvcmVIb29rcyxcbiAgICAvLyBpbi1jb21wb25lbnQgdXBkYXRlIGhvb2tzXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxuICAgIC8vIGluLWNvbmZpZyBlbnRlciBndWFyZHNcbiAgICBhY3RpdmF0ZWQubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmJlZm9yZUVudGVyOyB9KSxcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXG4gICAgcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyhhY3RpdmF0ZWQpXG4gICk7XG5cbiAgdGhpcy5wZW5kaW5nID0gcm91dGU7XG4gIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIChob29rLCBuZXh0KSB7XG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgcmV0dXJuIGFib3J0KClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGhvb2socm91dGUsIGN1cnJlbnQsIGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzRXJyb3IodG8pKSB7XG4gICAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgICAgdGhpcyQxLmVuc3VyZVVSTCh0cnVlKTtcbiAgICAgICAgICBhYm9ydCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIChcbiAgICAgICAgICAgIHR5cGVvZiB0by5wYXRoID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRvLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbmV4dCgnLycpIG9yIG5leHQoeyBwYXRoOiAnLycgfSkgLT4gcmVkaXJlY3RcbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIHRvLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIHRoaXMkMS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcyQxLnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25maXJtIHRyYW5zaXRpb24gYW5kIHBhc3Mgb24gdGhlIHZhbHVlXG4gICAgICAgICAgbmV4dCh0byk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGFib3J0KGUpO1xuICAgIH1cbiAgfTtcblxuICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zdEVudGVyQ2JzID0gW107XG4gICAgdmFyIGlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY3VycmVudCA9PT0gcm91dGU7IH07XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICB2YXIgZW50ZXJHdWFyZHMgPSBleHRyYWN0RW50ZXJHdWFyZHMoYWN0aXZhdGVkLCBwb3N0RW50ZXJDYnMsIGlzVmFsaWQpO1xuICAgIHZhciBxdWV1ZSA9IGVudGVyR3VhcmRzLmNvbmNhdCh0aGlzJDEucm91dGVyLnJlc29sdmVIb29rcyk7XG4gICAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgICB9XG4gICAgICB0aGlzJDEucGVuZGluZyA9IG51bGw7XG4gICAgICBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIGlmICh0aGlzJDEucm91dGVyLmFwcCkge1xuICAgICAgICB0aGlzJDEucm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBvc3RFbnRlckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xuICB0aGlzLmNiICYmIHRoaXMuY2Iocm91dGUpO1xuICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgLy8gcmVzcGVjdCA8YmFzZT4gdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgICAvLyBzdHJpcCBmdWxsIFVSTCBvcmlnaW5cbiAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoL15odHRwcz86XFwvXFwvW15cXC9dKy8sICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9ICcvJztcbiAgICB9XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgdGhlIHN0YXJ0aW5nIHNsYXNoXG4gIGlmIChiYXNlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XG4gIH1cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcbiAgY3VycmVudCxcbiAgbmV4dFxuKSB7XG4gIHZhciBpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXgoY3VycmVudC5sZW5ndGgsIG5leHQubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRbaV0gIT09IG5leHRbaV0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcbiAgICBhY3RpdmF0ZWQ6IG5leHQuc2xpY2UoaSksXG4gICAgZGVhY3RpdmF0ZWQ6IGN1cnJlbnQuc2xpY2UoaSlcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcbiAgcmVjb3JkcyxcbiAgbmFtZSxcbiAgYmluZCxcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xuICAgIHZhciBndWFyZCA9IGV4dHJhY3RHdWFyZChkZWYsIG5hbWUpO1xuICAgIGlmIChndWFyZCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXG4gICAgICAgID8gZ3VhcmQubWFwKGZ1bmN0aW9uIChndWFyZCkgeyByZXR1cm4gYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpOyB9KVxuICAgICAgICA6IGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmbGF0dGVuKHJldmVyc2UgPyBndWFyZHMucmV2ZXJzZSgpIDogZ3VhcmRzKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmQgKFxuICBkZWYsXG4gIGtleVxuKSB7XG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXh0ZW5kIG5vdyBzbyB0aGF0IGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQuXG4gICAgZGVmID0gX1Z1ZS5leHRlbmQoZGVmKTtcbiAgfVxuICByZXR1cm4gZGVmLm9wdGlvbnNba2V5XVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TGVhdmVHdWFyZHMgKGRlYWN0aXZhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGRlYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVMZWF2ZScsIGJpbmRHdWFyZCwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFVwZGF0ZUhvb2tzICh1cGRhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcbn1cblxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kUm91dGVHdWFyZCAoKSB7XG4gICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVudGVyR3VhcmRzIChcbiAgYWN0aXZhdGVkLFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUVudGVyJywgZnVuY3Rpb24gKGd1YXJkLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgcmV0dXJuIGJpbmRFbnRlckd1YXJkKGd1YXJkLCBtYXRjaCwga2V5LCBjYnMsIGlzVmFsaWQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcbiAgZ3VhcmQsXG4gIG1hdGNoLFxuICBrZXksXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiByb3V0ZUVudGVyR3VhcmQgKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgcmV0dXJuIGd1YXJkKHRvLCBmcm9tLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIG5leHQoY2IpO1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gIzc1MFxuICAgICAgICAgIC8vIGlmIGEgcm91dGVyLXZpZXcgaXMgd3JhcHBlZCB3aXRoIGFuIG91dC1pbiB0cmFuc2l0aW9uLFxuICAgICAgICAgIC8vIHRoZSBpbnN0YW5jZSBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIGF0IHRoaXMgdGltZS5cbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICAvLyBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgcG9sbChjYiwgbWF0Y2guaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvbGwgKFxuICBjYiwgLy8gc29tZWhvdyBmbG93IGNhbm5vdCBpbmZlciB0aGlzIGlzIGEgZnVuY3Rpb25cbiAgaW5zdGFuY2VzLFxuICBrZXksXG4gIGlzVmFsaWRcbikge1xuICBpZiAoaW5zdGFuY2VzW2tleV0pIHtcbiAgICBjYihpbnN0YW5jZXNba2V5XSk7XG4gIH0gZWxzZSBpZiAoaXNWYWxpZCgpKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBwb2xsKGNiLCBpbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgfSwgMTYpO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBIVE1MNUhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuXG4gICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIVE1MNUhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhUTUw1SGlzdG9yeTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgaWYgKGdldExvY2F0aW9uKHRoaXMuYmFzZSkgIT09IHRoaXMuY3VycmVudC5mdWxsUGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuICB9O1xuXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcbiAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxuXG52YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciwgYmFzZSwgZmFsbGJhY2spIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICAvLyBjaGVjayBoaXN0b3J5IGZhbGxiYWNrIGRlZXBsaW5raW5nXG4gICAgaWYgKGZhbGxiYWNrICYmIGNoZWNrRmFsbGJhY2sodGhpcy5iYXNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVuc3VyZVNsYXNoKCk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hIaXN0b3J5O1xuXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xuICAvLyB0byBhdm9pZCB0aGUgaGFzaGNoYW5nZSBsaXN0ZW5lciBiZWluZyBmaXJlZCB0b28gZWFybHlcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnNldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBocmVmLnNsaWNlKGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2ggKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaSA9IGhyZWYuaW5kZXhPZignIycpO1xuICB2YXIgYmFzZSA9IGkgPj0gMCA/IGhyZWYuc2xpY2UoMCwgaSkgOiBocmVmO1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgoYmFzZSArIFwiI1wiICsgcGF0aCkpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEFic3RyYWN0SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZnVsbFBhdGggOiAnLydcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuLyogICovXG5cbnZhciBWdWVSb3V0ZXIgPSBmdW5jdGlvbiBWdWVSb3V0ZXIgKG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5hcHAgPSBudWxsO1xuICB0aGlzLmFwcHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5iZWZvcmVIb29rcyA9IFtdO1xuICB0aGlzLnJlc29sdmVIb29rcyA9IFtdO1xuICB0aGlzLmFmdGVySG9va3MgPSBbXTtcbiAgdGhpcy5tYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRpb25zLnJvdXRlcyB8fCBbXSwgdGhpcyk7XG5cbiAgdmFyIG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ2hhc2gnO1xuICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c1B1c2hTdGF0ZSAmJiBvcHRpb25zLmZhbGxiYWNrICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICBtb2RlID0gJ2hhc2gnO1xuICB9XG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgbW9kZSA9ICdhYnN0cmFjdCc7XG4gIH1cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGFzaEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEFic3RyYWN0SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAoXCJpbnZhbGlkIG1vZGU6IFwiICsgbW9kZSkpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjdXJyZW50Um91dGU6IHt9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcbiAgICBpbnN0YWxsLmluc3RhbGxlZCxcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXG4gICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhhc2hIaXN0b3J5KSB7XG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xuICAgIH07XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXIsXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcbiAgICB0aGlzJDEuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYmVmb3JlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVSZXNvbHZlID0gZnVuY3Rpb24gYmVmb3JlUmVzb2x2ZSAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLnJlc29sdmVIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmFmdGVySG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uUmVhZHkoY2IsIGVycm9yQ2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmhpc3Rvcnkub25FcnJvcihlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICB0aGlzLmhpc3RvcnkuZ28obik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcbiAgdGhpcy5nbygtMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkICgpIHtcbiAgdGhpcy5nbygxKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcbiAgdmFyIHJvdXRlID0gdG9cbiAgICA/IHRvLm1hdGNoZWRcbiAgICAgID8gdG9cbiAgICAgIDogdGhpcy5yZXNvbHZlKHRvKS5yb3V0ZVxuICAgIDogdGhpcy5jdXJyZW50Um91dGU7XG4gIGlmICghcm91dGUpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCByb3V0ZS5tYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbS5jb21wb25lbnRzW2tleV1cbiAgICB9KVxuICB9KSlcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKFxuICB0byxcbiAgY3VycmVudCxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24oXG4gICAgdG8sXG4gICAgY3VycmVudCB8fCB0aGlzLmhpc3RvcnkuY3VycmVudCxcbiAgICBhcHBlbmQsXG4gICAgdGhpc1xuICApO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZWdpc3Rlckhvb2sgKGxpc3QsIGZuKSB7XG4gIGxpc3QucHVzaChmbik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBsaXN0LmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHsgbGlzdC5zcGxpY2UoaSwgMSk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMi43LjAnO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVlUm91dGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9fdnVlLXJvdXRlckAyLjcuMEB2dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 132:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapState\", function() { return mapState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapMutations\", function() { return mapMutations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapGetters\", function() { return mapGetters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapActions\", function() { return mapActions; });\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * vuex v2.3.0\n * (c) 2017 Evan You\n * @license MIT\n */\nvar applyMixin = function applyMixin(Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if (options === void 0) options = {};\n\n      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit() {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n};\n\nvar devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin(store) {\n  if (!devtoolHook) {\n    return;\n  }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\n\n/**\n * forEach for object\n */\nfunction forEachValue(obj, fn) {\n  Object.keys(obj).forEach(function (key) {\n    return fn(obj[key], key);\n  });\n}\n\nfunction isObject(obj) {\n  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\nfunction isPromise(val) {\n  return val && typeof val.then === 'function';\n}\n\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error(\"[vuex] \" + msg);\n  }\n}\n\nvar Module = function Module(rawModule, runtime) {\n  this.runtime = runtime;\n  this._children = Object.create(null);\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors$1 = { namespaced: {} };\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced;\n};\n\nModule.prototype.addChild = function addChild(key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild(key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild(key) {\n  return this._children[key];\n};\n\nModule.prototype.update = function update(rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild(fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter(fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction(fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation(fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties(Module.prototype, prototypeAccessors$1);\n\nvar ModuleCollection = function ModuleCollection(rawRootModule) {\n  var this$1 = this;\n\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false);\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, function (rawModule, key) {\n      this$1.register([key], rawModule, false);\n    });\n  }\n};\n\nModuleCollection.prototype.get = function get(path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key);\n  }, this.root);\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace(path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '');\n  }, '');\n};\n\nModuleCollection.prototype.update = function update$1(rawRootModule) {\n  update(this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register(path, rawModule, runtime) {\n  var this$1 = this;\n  if (runtime === void 0) runtime = true;\n\n  var parent = this.get(path.slice(0, -1));\n  var newModule = new Module(rawModule, runtime);\n  parent.addChild(path[path.length - 1], newModule);\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister(path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  if (!parent.getChild(key).runtime) {\n    return;\n  }\n\n  parent.removeChild(key);\n};\n\nfunction update(targetModule, newModule) {\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        console.warn(\"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" + 'manual reload is needed');\n        return;\n      }\n      update(targetModule.getChild(key), newModule.modules[key]);\n    }\n  }\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store(options) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n\n  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n\n  var state = options.state;if (state === void 0) state = {};\n  var plugins = options.plugins;if (plugins === void 0) plugins = [];\n  var strict = options.strict;if (strict === void 0) strict = false;\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch(type, payload) {\n    return dispatch.call(store, type, payload);\n  };\n  this.commit = function boundCommit(type, payload, options) {\n    return commit.call(store, type, payload, options);\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.concat(devtoolPlugin).forEach(function (plugin) {\n    return plugin(this$1);\n  });\n};\n\nvar prototypeAccessors = { state: {} };\n\nprototypeAccessors.state.get = function () {\n  return this._vm._data.$$state;\n};\n\nprototypeAccessors.state.set = function (v) {\n  assert(false, \"Use store.replaceState() to explicit replace store state.\");\n};\n\nStore.prototype.commit = function commit(_type, _payload, _options) {\n  var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n  var type = ref.type;\n  var payload = ref.payload;\n  var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    console.error(\"[vuex] unknown mutation type: \" + type);\n    return;\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator(handler) {\n      handler(payload);\n    });\n  });\n  this._subscribers.forEach(function (sub) {\n    return sub(mutation, this$1.state);\n  });\n\n  if (options && options.silent) {\n    console.warn(\"[vuex] mutation type: \" + type + \". Silent option has been removed. \" + 'Use the filter functionality in the vue-devtools');\n  }\n};\n\nStore.prototype.dispatch = function dispatch(_type, _payload) {\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n  var type = ref.type;\n  var payload = ref.payload;\n\n  var entry = this._actions[type];\n  if (!entry) {\n    console.error(\"[vuex] unknown action type: \" + type);\n    return;\n  }\n  return entry.length > 1 ? Promise.all(entry.map(function (handler) {\n    return handler(payload);\n  })) : entry[0](payload);\n};\n\nStore.prototype.subscribe = function subscribe(fn) {\n  var subs = this._subscribers;\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  };\n};\n\nStore.prototype.watch = function watch(getter, cb, options) {\n  var this$1 = this;\n\n  assert(typeof getter === 'function', \"store.watch only accepts a function.\");\n  return this._watcherVM.$watch(function () {\n    return getter(this$1.state, this$1.getters);\n  }, cb, options);\n};\n\nStore.prototype.replaceState = function replaceState(state) {\n  var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule(path, rawModule) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path));\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule(path) {\n  var this$1 = this;\n\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hotUpdate = function hotUpdate(newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit(fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties(Store.prototype, prototypeAccessors);\n\nfunction resetStore(store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM(store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () {\n      return fn(store);\n    };\n    Object.defineProperty(store.getters, key, {\n      get: function get() {\n        return store._vm[key];\n      },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () {\n      return oldVm.$destroy();\n    });\n  }\n}\n\nfunction installModule(store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var namespacedType = namespace + key;\n    registerAction(store, namespacedType, action, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext(store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._actions[type]) {\n          console.error(\"[vuex] unknown local action type: \" + args.type + \", global type: \" + type);\n          return;\n        }\n      }\n\n      return store.dispatch(type, payload);\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._mutations[type]) {\n          console.error(\"[vuex] unknown local mutation type: \" + args.type + \", global type: \" + type);\n          return;\n        }\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace ? function () {\n        return store.getters;\n      } : function () {\n        return makeLocalGetters(store, namespace);\n      }\n    },\n    state: {\n      get: function get() {\n        return getNestedState(store.state, path);\n      }\n    }\n  });\n\n  return local;\n}\n\nfunction makeLocalGetters(store, namespace) {\n  var gettersProxy = {};\n\n  var splitPos = namespace.length;\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) {\n      return;\n    }\n\n    // extract local getter type\n    var localType = type.slice(splitPos);\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function get() {\n        return store.getters[type];\n      },\n      enumerable: true\n    });\n  });\n\n  return gettersProxy;\n}\n\nfunction registerMutation(store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler(payload) {\n    handler(local.state, payload);\n  });\n}\n\nfunction registerAction(store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler(payload, cb) {\n    var res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err;\n      });\n    } else {\n      return res;\n    }\n  });\n}\n\nfunction registerGetter(store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    console.error(\"[vuex] duplicate getter key: \" + type);\n    return;\n  }\n  store._wrappedGetters[type] = function wrappedGetter(store) {\n    return rawGetter(local.state, // local state\n    local.getters, // local getters\n    store.state, // root state\n    store.getters // root getters\n    );\n  };\n}\n\nfunction enableStrictMode(store) {\n  store._vm.$watch(function () {\n    return this._data.$$state;\n  }, function () {\n    assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\");\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState(state, path) {\n  return path.length ? path.reduce(function (state, key) {\n    return state[key];\n  }, state) : state;\n}\n\nfunction unifyObjectStyle(type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  assert(typeof type === 'string', \"Expects string as the type, but found \" + (typeof type === 'undefined' ? 'undefined' : _typeof(type)) + \".\");\n\n  return { type: type, payload: payload, options: options };\n}\n\nfunction install(_Vue) {\n  if (Vue) {\n    console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');\n    return;\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue);\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState() {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return;\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function' ? val.call(this, state, getters) : state[val];\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res;\n});\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedMutation() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {\n        return;\n      }\n      return this.$store.commit.apply(this.$store, [val].concat(args));\n    };\n  });\n  return res;\n});\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedGetter() {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return;\n      }\n      if (!(val in this.$store.getters)) {\n        console.error(\"[vuex] unknown getter: \" + val);\n        return;\n      }\n      return this.$store.getters[val];\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res;\n});\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedAction() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {\n        return;\n      }\n      return this.$store.dispatch.apply(this.$store, [val].concat(args));\n    };\n  });\n  return res;\n});\n\nfunction normalizeMap(map) {\n  return Array.isArray(map) ? map.map(function (key) {\n    return { key: key, val: key };\n  }) : Object.keys(map).map(function (key) {\n    return { key: key, val: map[key] };\n  });\n}\n\nfunction normalizeNamespace(fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map);\n  };\n}\n\nfunction getModuleByNamespace(store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (!module) {\n    console.error(\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace);\n  }\n  return module;\n}\n\nvar index_esm = {\n  Store: Store,\n  install: install,\n  version: '2.3.0',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index_esm);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L192dWV4QDIuMy4xQHZ1ZXgvZGlzdC92dWV4LmVzbS5qcz8zN2UxIl0sIm5hbWVzIjpbImFwcGx5TWl4aW4iLCJWdWUiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwic3BsaXQiLCJ1c2VzSW5pdCIsImNvbmZpZyIsIl9saWZlY3ljbGVIb29rcyIsImluZGV4T2YiLCJtaXhpbiIsImluaXQiLCJ2dWV4SW5pdCIsImJlZm9yZUNyZWF0ZSIsIl9pbml0IiwicHJvdG90eXBlIiwib3B0aW9ucyIsImNvbmNhdCIsImNhbGwiLCIkb3B0aW9ucyIsInN0b3JlIiwiJHN0b3JlIiwicGFyZW50IiwiZGV2dG9vbEhvb2siLCJ3aW5kb3ciLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiZGV2dG9vbFBsdWdpbiIsIl9kZXZ0b29sSG9vayIsImVtaXQiLCJvbiIsInRhcmdldFN0YXRlIiwicmVwbGFjZVN0YXRlIiwic3Vic2NyaWJlIiwibXV0YXRpb24iLCJzdGF0ZSIsImZvckVhY2hWYWx1ZSIsIm9iaiIsImZuIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpc09iamVjdCIsImlzUHJvbWlzZSIsInZhbCIsInRoZW4iLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtc2ciLCJFcnJvciIsIk1vZHVsZSIsInJhd01vZHVsZSIsInJ1bnRpbWUiLCJfY2hpbGRyZW4iLCJjcmVhdGUiLCJfcmF3TW9kdWxlIiwicmF3U3RhdGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMkMSIsIm5hbWVzcGFjZWQiLCJnZXQiLCJhZGRDaGlsZCIsIm1vZHVsZSIsInJlbW92ZUNoaWxkIiwiZ2V0Q2hpbGQiLCJ1cGRhdGUiLCJhY3Rpb25zIiwibXV0YXRpb25zIiwiZ2V0dGVycyIsImZvckVhY2hDaGlsZCIsImZvckVhY2hHZXR0ZXIiLCJmb3JFYWNoQWN0aW9uIiwiZm9yRWFjaE11dGF0aW9uIiwiZGVmaW5lUHJvcGVydGllcyIsIk1vZHVsZUNvbGxlY3Rpb24iLCJyYXdSb290TW9kdWxlIiwidGhpcyQxIiwicm9vdCIsIm1vZHVsZXMiLCJyZWdpc3RlciIsInBhdGgiLCJyZWR1Y2UiLCJnZXROYW1lc3BhY2UiLCJuYW1lc3BhY2UiLCJ1cGRhdGUkMSIsInNsaWNlIiwibmV3TW9kdWxlIiwibGVuZ3RoIiwicmF3Q2hpbGRNb2R1bGUiLCJ1bnJlZ2lzdGVyIiwidGFyZ2V0TW9kdWxlIiwiY29uc29sZSIsIndhcm4iLCJTdG9yZSIsIlByb21pc2UiLCJwbHVnaW5zIiwic3RyaWN0IiwiX2NvbW1pdHRpbmciLCJfYWN0aW9ucyIsIl9tdXRhdGlvbnMiLCJfd3JhcHBlZEdldHRlcnMiLCJfbW9kdWxlcyIsIl9tb2R1bGVzTmFtZXNwYWNlTWFwIiwiX3N1YnNjcmliZXJzIiwiX3dhdGNoZXJWTSIsInJlZiIsImRpc3BhdGNoIiwiY29tbWl0IiwiYm91bmREaXNwYXRjaCIsInR5cGUiLCJwYXlsb2FkIiwiYm91bmRDb21taXQiLCJpbnN0YWxsTW9kdWxlIiwicmVzZXRTdG9yZVZNIiwicGx1Z2luIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiX3ZtIiwiX2RhdGEiLCIkJHN0YXRlIiwic2V0IiwidiIsIl90eXBlIiwiX3BheWxvYWQiLCJfb3B0aW9ucyIsInVuaWZ5T2JqZWN0U3R5bGUiLCJlbnRyeSIsImVycm9yIiwiX3dpdGhDb21taXQiLCJjb21taXRJdGVyYXRvciIsImhhbmRsZXIiLCJzdWIiLCJzaWxlbnQiLCJhbGwiLCJtYXAiLCJzdWJzIiwicHVzaCIsImkiLCJzcGxpY2UiLCJ3YXRjaCIsImdldHRlciIsImNiIiwiJHdhdGNoIiwicmVnaXN0ZXJNb2R1bGUiLCJBcnJheSIsImlzQXJyYXkiLCJ1bnJlZ2lzdGVyTW9kdWxlIiwicGFyZW50U3RhdGUiLCJnZXROZXN0ZWRTdGF0ZSIsImRlbGV0ZSIsInJlc2V0U3RvcmUiLCJob3RVcGRhdGUiLCJuZXdPcHRpb25zIiwiY29tbWl0dGluZyIsImhvdCIsIm9sZFZtIiwid3JhcHBlZEdldHRlcnMiLCJjb21wdXRlZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImRhdGEiLCJlbmFibGVTdHJpY3RNb2RlIiwibmV4dFRpY2siLCIkZGVzdHJveSIsInJvb3RTdGF0ZSIsImlzUm9vdCIsIm1vZHVsZU5hbWUiLCJsb2NhbCIsImNvbnRleHQiLCJtYWtlTG9jYWxDb250ZXh0IiwibmFtZXNwYWNlZFR5cGUiLCJyZWdpc3Rlck11dGF0aW9uIiwiYWN0aW9uIiwicmVnaXN0ZXJBY3Rpb24iLCJyZWdpc3RlckdldHRlciIsImNoaWxkIiwibm9OYW1lc3BhY2UiLCJhcmdzIiwibWFrZUxvY2FsR2V0dGVycyIsImdldHRlcnNQcm94eSIsInNwbGl0UG9zIiwibG9jYWxUeXBlIiwid3JhcHBlZE11dGF0aW9uSGFuZGxlciIsIndyYXBwZWRBY3Rpb25IYW5kbGVyIiwicmVzIiwicm9vdEdldHRlcnMiLCJyZXNvbHZlIiwiY2F0Y2giLCJlcnIiLCJyYXdHZXR0ZXIiLCJ3cmFwcGVkR2V0dGVyIiwiZGVlcCIsInN5bmMiLCJpbnN0YWxsIiwiX1Z1ZSIsIm1hcFN0YXRlIiwibm9ybWFsaXplTmFtZXNwYWNlIiwic3RhdGVzIiwibm9ybWFsaXplTWFwIiwibWFwcGVkU3RhdGUiLCJnZXRNb2R1bGVCeU5hbWVzcGFjZSIsInZ1ZXgiLCJtYXBNdXRhdGlvbnMiLCJtYXBwZWRNdXRhdGlvbiIsImxlbiIsImFyZ3VtZW50cyIsImFwcGx5IiwibWFwR2V0dGVycyIsIm1hcHBlZEdldHRlciIsIm1hcEFjdGlvbnMiLCJtYXBwZWRBY3Rpb24iLCJjaGFyQXQiLCJoZWxwZXIiLCJpbmRleF9lc20iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7O0FBS0EsSUFBSUEsYUFBYSxTQUFiQSxVQUFhLENBQVVDLEdBQVYsRUFBZTtBQUM5QixNQUFJQyxVQUFVQyxPQUFPRixJQUFJQyxPQUFKLENBQVlFLEtBQVosQ0FBa0IsR0FBbEIsRUFBdUIsQ0FBdkIsQ0FBUCxDQUFkOztBQUVBLE1BQUlGLFdBQVcsQ0FBZixFQUFrQjtBQUNoQixRQUFJ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LFFBQXpCLEVBQW1DO0FBQ2pDa0QsWUFBTWxELFNBQU47QUFDQUEsa0JBQVksRUFBWjtBQUNELEtBSEQsTUFHTyxJQUFJQSxVQUFVK0gsTUFBVixDQUFpQi9ILFVBQVVJLE1BQVYsR0FBbUIsQ0FBcEMsTUFBMkMsR0FBL0MsRUFBb0Q7QUFDekRKLG1CQUFhLEdBQWI7QUFDRDtBQUNELFdBQU83QyxHQUFHNkMsU0FBSCxFQUFja0QsR0FBZCxDQUFQO0FBQ0QsR0FSRDtBQVNEOztBQUVELFNBQVNrRSxvQkFBVCxDQUErQmxMLEtBQS9CLEVBQXNDOEwsTUFBdEMsRUFBOENoSSxTQUE5QyxFQUF5RDtBQUN2RCxNQUFJckIsU0FBU3pDLE1BQU1pRixvQkFBTixDQUEyQm5CLFNBQTNCLENBQWI7QUFDQSxNQUFJLENBQUNyQixNQUFMLEVBQWE7QUFDWDZCLFlBQVFtQyxLQUFSLENBQWUsMENBQTBDcUYsTUFBMUMsR0FBbUQsTUFBbkQsR0FBNERoSSxTQUEzRTtBQUNEO0FBQ0QsU0FBT3JCLE1BQVA7QUFDRDs7QUFFRCxJQUFJc0osWUFBWTtBQUNkdkgsU0FBT0EsS0FETztBQUVkbUcsV0FBU0EsT0FGSztBQUdkNUwsV0FBUyxPQUhLO0FBSWQ4TCxZQUFVQSxRQUpJO0FBS2RPLGdCQUFjQSxZQUxBO0FBTWRLLGNBQVlBLFVBTkU7QUFPZEUsY0FBWUE7QUFQRSxDQUFoQjs7QUFVaUUsK0RBQWVJLFNBQWYiLCJmaWxlIjoiMTMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB2dWV4IHYyLjMuMFxuICogKGMpIDIwMTcgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgYXBwbHlNaXhpbiA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIHZhciB1c2VzSW5pdCA9IFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xO1xuICAgIFZ1ZS5taXhpbih1c2VzSW5pdCA/IHsgaW5pdDogdnVleEluaXQgfSA6IHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdmVycmlkZSBpbml0IGFuZCBpbmplY3QgdnVleCBpbml0IHByb2NlZHVyZVxuICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdmFyIF9pbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBvcHRpb25zLmluaXQgPSBvcHRpb25zLmluaXRcbiAgICAgICAgPyBbdnVleEluaXRdLmNvbmNhdChvcHRpb25zLmluaXQpXG4gICAgICAgIDogdnVleEluaXQ7XG4gICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVnVleCBpbml0IGhvb2ssIGluamVjdGVkIGludG8gZWFjaCBpbnN0YW5jZXMgaW5pdCBob29rcyBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiB2dWV4SW5pdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHN0b3JlIGluamVjdGlvblxuICAgIGlmIChvcHRpb25zLnN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldnRvb2xIb29rID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBpdGVtIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogYnkgc2Vjb25kIGFyZ3VtZW50IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7Kn1cbiAqL1xuLyoqXG4gKiBEZWVwIGNvcHkgdGhlIGdpdmVuIG9iamVjdCBjb25zaWRlcmluZyBjaXJjdWxhciBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGl0cyBjb3BpZXMuXG4gKiBJZiBpdCBkZXRlY3RzIGNpcmN1bGFyIHN0cnVjdHVyZSwgdXNlIGNhY2hlZCBjb3B5IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2FjaGVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fcmF3TW9kdWxlID0gcmF3TW9kdWxlO1xuICB2YXIgcmF3U3RhdGUgPSByYXdNb2R1bGUuc3RhdGU7XG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDoge30gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yb290ID0gbmV3IE1vZHVsZShyYXdSb290TW9kdWxlLCBmYWxzZSk7XG5cbiAgLy8gcmVnaXN0ZXIgYWxsIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdSb290TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3JFYWNoVmFsdWUocmF3Um9vdE1vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3TW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3Rlcihba2V5XSwgcmF3TW9kdWxlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG1vZHVsZSwga2V5KSB7XG4gICAgcmV0dXJuIG1vZHVsZS5nZXRDaGlsZChrZXkpXG4gIH0sIHRoaXMucm9vdClcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uIGdldE5hbWVzcGFjZSAocGF0aCkge1xuICB2YXIgbW9kdWxlID0gdGhpcy5yb290O1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgbW9kdWxlID0gbW9kdWxlLmdldENoaWxkKGtleSk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSArIChtb2R1bGUubmFtZXNwYWNlZCA/IGtleSArICcvJyA6ICcnKVxuICB9LCAnJylcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxIChyYXdSb290TW9kdWxlKSB7XG4gIHVwZGF0ZSh0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlICh0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbdnVleF0gdHJ5aW5nIHRvIGFkZCBhIG5ldyBtb2R1bGUgJ1wiICsga2V5ICsgXCInIG9uIGhvdCByZWxvYWRpbmcsIFwiICtcbiAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLCBuZXdNb2R1bGUubW9kdWxlc1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgYXNzZXJ0KHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJywgXCJ2dWV4IHJlcXVpcmVzIGEgUHJvbWlzZSBwb2x5ZmlsbCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuXG4gIHZhciBzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7IGlmICggc3RhdGUgPT09IHZvaWQgMCApIHN0YXRlID0ge307XG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmNvbmNhdChkZXZ0b29sUGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEpOyB9KTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdm0uX2RhdGEuJCRzdGF0ZVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGVudHJ5Lmxlbmd0aCA+IDFcbiAgICA/IFByb21pc2UuYWxsKGVudHJ5Lm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihwYXlsb2FkKTsgfSkpXG4gICAgOiBlbnRyeVswXShwYXlsb2FkKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoZm4pIHtcbiAgdmFyIHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICByZXR1cm4gdGhpcy5fd2F0Y2hlclZNLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXIodGhpcyQxLnN0YXRlLCB0aGlzJDEuZ2V0dGVycyk7IH0sIGNiLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuX3ZtLl9kYXRhLiQkc3RhdGUgPSBzdGF0ZTtcbiAgfSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpO1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHRoaXMuc3RhdGUsIHBhdGgsIHRoaXMuX21vZHVsZXMuZ2V0KHBhdGgpKTtcbiAgLy8gcmVzZXQgc3RvcmUgdG8gdXBkYXRlIGdldHRlcnMuLi5cbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHRoaXMuc3RhdGUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlIChwYXRoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oc3RvcmUpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZS5nZXR0ZXJzLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3ZtW2tleV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlIC8vIGZvciBsb2NhbCBnZXR0ZXJzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHVzZSBhIFZ1ZSBpbnN0YW5jZSB0byBzdG9yZSB0aGUgc3RhdGUgdHJlZVxuICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YToge1xuICAgICAgJCRzdGF0ZTogc3RhdGVcbiAgICB9LFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICB9KTtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgdm1cbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFZtKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFZtLl9kYXRhLiQkc3RhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTW9kdWxlIChzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLCBtb2R1bGUsIGhvdCkge1xuICB2YXIgaXNSb290ID0gIXBhdGgubGVuZ3RoO1xuICB2YXIgbmFtZXNwYWNlID0gc3RvcmUuX21vZHVsZXMuZ2V0TmFtZXNwYWNlKHBhdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7XG4gICAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIG1vZHVsZU5hbWUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgVnVlLnNldChwYXJlbnRTdGF0ZSwgbW9kdWxlTmFtZSwgbW9kdWxlLnN0YXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJBY3Rpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBhY3Rpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyR2V0dGVyKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgZ2V0dGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBtYWtlIGxvY2FsaXplZCBkaXNwYXRjaCwgY29tbWl0LCBnZXR0ZXJzIGFuZCBzdGF0ZVxuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnO1xuXG4gIHZhciBsb2NhbCA9IHtcbiAgICBkaXNwYXRjaDogbm9OYW1lc3BhY2UgPyBzdG9yZS5kaXNwYXRjaCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKCFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSB2bSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnZXR0ZXJzUHJveHlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIobG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQsIGNiKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIoe1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCwgY2IpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBsb2NhbC5zdGF0ZSwgLy8gbG9jYWwgc3RhdGVcbiAgICAgIGxvY2FsLmdldHRlcnMsIC8vIGxvY2FsIGdldHRlcnNcbiAgICAgIHN0b3JlLnN0YXRlLCAvLyByb290IHN0YXRlXG4gICAgICBzdG9yZS5nZXR0ZXJzIC8vIHJvb3QgZ2V0dGVyc1xuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgc3RvcmUuX3ZtLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLiQkc3RhdGUgfSwgZnVuY3Rpb24gKCkge1xuICAgIGFzc2VydChzdG9yZS5fY29tbWl0dGluZywgXCJEbyBub3QgbXV0YXRlIHZ1ZXggc3RvcmUgc3RhdGUgb3V0c2lkZSBtdXRhdGlvbiBoYW5kbGVycy5cIik7XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsIChcIkV4cGVjdHMgc3RyaW5nIGFzIHRoZSB0eXBlLCBidXQgZm91bmQgXCIgKyAodHlwZW9mIHR5cGUpICsgXCIuXCIpKTtcblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG4vLyBhdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xufVxuXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZE11dGF0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkQWN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmRpc3BhdGNoLmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmICghbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxudmFyIGluZGV4X2VzbSA9IHtcbiAgU3RvcmU6IFN0b3JlLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICB2ZXJzaW9uOiAnMi4zLjAnLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zXG59O1xuXG5leHBvcnQgeyBTdG9yZSwgbWFwU3RhdGUsIG1hcE11dGF0aW9ucywgbWFwR2V0dGVycywgbWFwQWN0aW9ucyB9O2V4cG9ydCBkZWZhdWx0IGluZGV4X2VzbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vX3Z1ZXhAMi4zLjFAdnVleC9kaXN0L3Z1ZXguZXNtLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 469:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! tether 1.4.0 */\n\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n    module.exports = factory(require, exports, module);\n  } else {\n    root.Tether = factory();\n  }\n})(this, function (require, exports, module) {\n\n  'use strict';\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n    };\n  }();\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  var TetherBase = undefined;\n  if (typeof TetherBase === 'undefined') {\n    TetherBase = { modules: [] };\n  }\n\n  var zeroElement = null;\n\n  // Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\n  // if the element lies within a nested document (<frame> or <iframe>-like).\n  function getActualBoundingClientRect(node) {\n    var boundingRect = node.getBoundingClientRect();\n\n    // The original object returned by getBoundingClientRect is immutable, so we clone it\n    // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\n    var rect = {};\n    for (var k in boundingRect) {\n      rect[k] = boundingRect[k];\n    }\n\n    if (node.ownerDocument !== document) {\n      var _frameElement = node.ownerDocument.defaultView.frameElement;\n      if (_frameElement) {\n        var frameRect = getActualBoundingClientRect(_frameElement);\n        rect.top += frameRect.top;\n        rect.bottom += frameRect.top;\n        rect.left += frameRect.left;\n        rect.right += frameRect.left;\n      }\n    }\n\n    return rect;\n  }\n\n  function getScrollParents(el) {\n    // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    var computedStyle = getComputedStyle(el) || {};\n    var position = computedStyle.position;\n    var parents = [];\n\n    if (position === 'fixed') {\n      return [el];\n    }\n\n    var parent = el;\n    while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n      var style = undefined;\n      try {\n        style = getComputedStyle(parent);\n      } catch (err) {}\n\n      if (typeof style === 'undefined' || style === null) {\n        parents.push(parent);\n        return parents;\n      }\n\n      var _style = style;\n      var overflow = _style.overflow;\n      var overflowX = _style.overflowX;\n      var overflowY = _style.overflowY;\n\n      if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n        if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\n          parents.push(parent);\n        }\n      }\n    }\n\n    parents.push(el.ownerDocument.body);\n\n    // If the node is within a frame, account for the parent window scroll\n    if (el.ownerDocument !== document) {\n      parents.push(el.ownerDocument.defaultView);\n    }\n\n    return parents;\n  }\n\n  var uniqueId = function () {\n    var id = 0;\n    return function () {\n      return ++id;\n    };\n  }();\n\n  var zeroPosCache = {};\n  var getOrigin = function getOrigin() {\n    // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\n    // jitter as the user scrolls that messes with our ability to detect if two positions\n    // are equivilant or not.  We place an element at the top left of the page that will\n    // get the same jitter, so we can cancel the two out.\n    var node = zeroElement;\n    if (!node || !document.body.contains(node)) {\n      node = document.createElement('div');\n      node.setAttribute('data-tether-id', uniqueId());\n      extend(node.style, {\n        top: 0,\n        left: 0,\n        position: 'absolute'\n      });\n\n      document.body.appendChild(node);\n\n      zeroElement = node;\n    }\n\n    var id = node.getAttribute('data-tether-id');\n    if (typeof zeroPosCache[id] === 'undefined') {\n      zeroPosCache[id] = getActualBoundingClientRect(node);\n\n      // Clear the cache when this position call is done\n      defer(function () {\n        delete zeroPosCache[id];\n      });\n    }\n\n    return zeroPosCache[id];\n  };\n\n  function removeUtilElements() {\n    if (zeroElement) {\n      document.body.removeChild(zeroElement);\n    }\n    zeroElement = null;\n  };\n\n  function getBounds(el) {\n    var doc = undefined;\n    if (el === document) {\n      doc = document;\n      el = document.documentElement;\n    } else {\n      doc = el.ownerDocument;\n    }\n\n    var docEl = doc.documentElement;\n\n    var box = getActualBoundingClientRect(el);\n\n    var origin = getOrigin();\n\n    box.top -= origin.top;\n    box.left -= origin.left;\n\n    if (typeof box.width === 'undefined') {\n      box.width = document.body.scrollWidth - box.left - box.right;\n    }\n    if (typeof box.height === 'undefined') {\n      box.height = document.body.scrollHeight - box.top - box.bottom;\n    }\n\n    box.top = box.top - docEl.clientTop;\n    box.left = box.left - docEl.clientLeft;\n    box.right = doc.body.clientWidth - box.width - box.left;\n    box.bottom = doc.body.clientHeight - box.height - box.top;\n\n    return box;\n  }\n\n  function getOffsetParent(el) {\n    return el.offsetParent || document.documentElement;\n  }\n\n  var _scrollBarSize = null;\n  function getScrollBarSize() {\n    if (_scrollBarSize) {\n      return _scrollBarSize;\n    }\n    var inner = document.createElement('div');\n    inner.style.width = '100%';\n    inner.style.height = '200px';\n\n    var outer = document.createElement('div');\n    extend(outer.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      pointerEvents: 'none',\n      visibility: 'hidden',\n      width: '200px',\n      height: '150px',\n      overflow: 'hidden'\n    });\n\n    outer.appendChild(inner);\n\n    document.body.appendChild(outer);\n\n    var widthContained = inner.offsetWidth;\n    outer.style.overflow = 'scroll';\n    var widthScroll = inner.offsetWidth;\n\n    if (widthContained === widthScroll) {\n      widthScroll = outer.clientWidth;\n    }\n\n    document.body.removeChild(outer);\n\n    var width = widthContained - widthScroll;\n\n    _scrollBarSize = { width: width, height: width };\n    return _scrollBarSize;\n  }\n\n  function extend() {\n    var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    var args = [];\n\n    Array.prototype.push.apply(args, arguments);\n\n    args.slice(1).forEach(function (obj) {\n      if (obj) {\n        for (var key in obj) {\n          if ({}.hasOwnProperty.call(obj, key)) {\n            out[key] = obj[key];\n          }\n        }\n      }\n    });\n\n    return out;\n  }\n\n  function removeClass(el, name) {\n    if (typeof el.classList !== 'undefined') {\n      name.split(' ').forEach(function (cls) {\n        if (cls.trim()) {\n          el.classList.remove(cls);\n        }\n      });\n    } else {\n      var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');\n      var className = getClassName(el).replace(regex, ' ');\n      setClassName(el, className);\n    }\n  }\n\n  function addClass(el, name) {\n    if (typeof el.classList !== 'undefined') {\n      name.split(' ').forEach(function (cls) {\n        if (cls.trim()) {\n          el.classList.add(cls);\n        }\n      });\n    } else {\n      removeClass(el, name);\n      var cls = getClassName(el) + (' ' + name);\n      setClassName(el, cls);\n    }\n  }\n\n  function hasClass(el, name) {\n    if (typeof el.classList !== 'undefined') {\n      return el.classList.contains(name);\n    }\n    var className = getClassName(el);\n    return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);\n  }\n\n  function getClassName(el) {\n    // Can't use just SVGAnimatedString here since nodes within a Frame in IE have\n    // completely separately SVGAnimatedString base classes\n    if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {\n      return el.className.baseVal;\n    }\n    return el.className;\n  }\n\n  function setClassName(el, className) {\n    el.setAttribute('class', className);\n  }\n\n  function updateClasses(el, add, all) {\n    // Of the set of 'all' classes, we need the 'add' classes, and only the\n    // 'add' classes to be set.\n    all.forEach(function (cls) {\n      if (add.indexOf(cls) === -1 && hasClass(el, cls)) {\n        removeClass(el, cls);\n      }\n    });\n\n    add.forEach(function (cls) {\n      if (!hasClass(el, cls)) {\n        addClass(el, cls);\n      }\n    });\n  }\n\n  var deferred = [];\n\n  var defer = function defer(fn) {\n    deferred.push(fn);\n  };\n\n  var flush = function flush() {\n    var fn = undefined;\n    while (fn = deferred.pop()) {\n      fn();\n    }\n  };\n\n  var Evented = function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n\n    _createClass(Evented, [{\n      key: 'on',\n      value: function on(event, handler, ctx) {\n        var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n        if (typeof this.bindings === 'undefined') {\n          this.bindings = {};\n        }\n        if (typeof this.bindings[event] === 'undefined') {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({ handler: handler, ctx: ctx, once: once });\n      }\n    }, {\n      key: 'once',\n      value: function once(event, handler, ctx) {\n        this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: 'off',\n      value: function off(event, handler) {\n        if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {\n          return;\n        }\n\n        if (typeof handler === 'undefined') {\n          delete this.bindings[event];\n        } else {\n          var i = 0;\n          while (i < this.bindings[event].length) {\n            if (this.bindings[event][i].handler === handler) {\n              this.bindings[event].splice(i, 1);\n            } else {\n              ++i;\n            }\n          }\n        }\n      }\n    }, {\n      key: 'trigger',\n      value: function trigger(event) {\n        if (typeof this.bindings !== 'undefined' && this.bindings[event]) {\n          var i = 0;\n\n          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          while (i < this.bindings[event].length) {\n            var _bindings$event$i = this.bindings[event][i];\n            var handler = _bindings$event$i.handler;\n            var ctx = _bindings$event$i.ctx;\n            var once = _bindings$event$i.once;\n\n            var context = ctx;\n            if (typeof context === 'undefined') {\n              context = this;\n            }\n\n            handler.apply(context, args);\n\n            if (once) {\n              this.bindings[event].splice(i, 1);\n            } else {\n              ++i;\n            }\n          }\n        }\n      }\n    }]);\n\n    return Evented;\n  }();\n\n  TetherBase.Utils = {\n    getActualBoundingClientRect: getActualBoundingClientRect,\n    getScrollParents: getScrollParents,\n    getBounds: getBounds,\n    getOffsetParent: getOffsetParent,\n    extend: extend,\n    addClass: addClass,\n    removeClass: removeClass,\n    hasClass: hasClass,\n    updateClasses: updateClasses,\n    defer: defer,\n    flush: flush,\n    uniqueId: uniqueId,\n    Evented: Evented,\n    getScrollBarSize: getScrollBarSize,\n    removeUtilElements: removeUtilElements\n  };\n  /* globals TetherBase, performance */\n\n  'use strict';\n\n  var _slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;_e = err;\n      } finally {\n        try {\n          if (!_n && _i['return']) _i['return']();\n        } finally {\n          if (_d) throw _e;\n        }\n      }return _arr;\n    }return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n      }\n    };\n  }();\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n    };\n  }();\n\n  var _get = function get(_x6, _x7, _x8) {\n    var _again = true;_function: while (_again) {\n      var object = _x6,\n          property = _x7,\n          receiver = _x8;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);if (parent === null) {\n          return undefined;\n        } else {\n          _x6 = parent;_x7 = property;_x8 = receiver;_again = true;desc = parent = undefined;continue _function;\n        }\n      } else if ('value' in desc) {\n        return desc.value;\n      } else {\n        var getter = desc.get;if (getter === undefined) {\n          return undefined;\n        }return getter.call(receiver);\n      }\n    }\n  };\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  if (typeof TetherBase === 'undefined') {\n    throw new Error('You must include the utils.js file before tether.js');\n  }\n\n  var _TetherBase$Utils = TetherBase.Utils;\n  var getScrollParents = _TetherBase$Utils.getScrollParents;\n  var getBounds = _TetherBase$Utils.getBounds;\n  var getOffsetParent = _TetherBase$Utils.getOffsetParent;\n  var extend = _TetherBase$Utils.extend;\n  var addClass = _TetherBase$Utils.addClass;\n  var removeClass = _TetherBase$Utils.removeClass;\n  var updateClasses = _TetherBase$Utils.updateClasses;\n  var defer = _TetherBase$Utils.defer;\n  var flush = _TetherBase$Utils.flush;\n  var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;\n  var removeUtilElements = _TetherBase$Utils.removeUtilElements;\n\n  function within(a, b) {\n    var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n    return a + diff >= b && b >= a - diff;\n  }\n\n  var transformKey = function () {\n    if (typeof document === 'undefined') {\n      return '';\n    }\n    var el = document.createElement('div');\n\n    var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\n    for (var i = 0; i < transforms.length; ++i) {\n      var key = transforms[i];\n      if (el.style[key] !== undefined) {\n        return key;\n      }\n    }\n  }();\n\n  var tethers = [];\n\n  var position = function position() {\n    tethers.forEach(function (tether) {\n      tether.position(false);\n    });\n    flush();\n  };\n\n  function now() {\n    if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {\n      return performance.now();\n    }\n    return +new Date();\n  }\n\n  (function () {\n    var lastCall = null;\n    var lastDuration = null;\n    var pendingTimeout = null;\n\n    var tick = function tick() {\n      if (typeof lastDuration !== 'undefined' && lastDuration > 16) {\n        // We voluntarily throttle ourselves if we can't manage 60fps\n        lastDuration = Math.min(lastDuration - 16, 250);\n\n        // Just in case this is the last event, remember to position just once more\n        pendingTimeout = setTimeout(tick, 250);\n        return;\n      }\n\n      if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {\n        // Some browsers call events a little too frequently, refuse to run more than is reasonable\n        return;\n      }\n\n      if (pendingTimeout != null) {\n        clearTimeout(pendingTimeout);\n        pendingTimeout = null;\n      }\n\n      lastCall = now();\n      position();\n      lastDuration = now() - lastCall;\n    };\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n      ['resize', 'scroll', 'touchmove'].forEach(function (event) {\n        window.addEventListener(event, tick);\n      });\n    }\n  })();\n\n  var MIRROR_LR = {\n    center: 'center',\n    left: 'right',\n    right: 'left'\n  };\n\n  var MIRROR_TB = {\n    middle: 'middle',\n    top: 'bottom',\n    bottom: 'top'\n  };\n\n  var OFFSET_MAP = {\n    top: 0,\n    left: 0,\n    middle: '50%',\n    center: '50%',\n    bottom: '100%',\n    right: '100%'\n  };\n\n  var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {\n    var left = attachment.left;\n    var top = attachment.top;\n\n    if (left === 'auto') {\n      left = MIRROR_LR[relativeToAttachment.left];\n    }\n\n    if (top === 'auto') {\n      top = MIRROR_TB[relativeToAttachment.top];\n    }\n\n    return { left: left, top: top };\n  };\n\n  var attachmentToOffset = function attachmentToOffset(attachment) {\n    var left = attachment.left;\n    var top = attachment.top;\n\n    if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {\n      left = OFFSET_MAP[attachment.left];\n    }\n\n    if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {\n      top = OFFSET_MAP[attachment.top];\n    }\n\n    return { left: left, top: top };\n  };\n\n  function addOffset() {\n    var out = { top: 0, left: 0 };\n\n    for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {\n      offsets[_key] = arguments[_key];\n    }\n\n    offsets.forEach(function (_ref) {\n      var top = _ref.top;\n      var left = _ref.left;\n\n      if (typeof top === 'string') {\n        top = parseFloat(top, 10);\n      }\n      if (typeof left === 'string') {\n        left = parseFloat(left, 10);\n      }\n\n      out.top += top;\n      out.left += left;\n    });\n\n    return out;\n  }\n\n  function offsetToPx(offset, size) {\n    if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\n      offset.left = parseFloat(offset.left, 10) / 100 * size.width;\n    }\n    if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\n      offset.top = parseFloat(offset.top, 10) / 100 * size.height;\n    }\n\n    return offset;\n  }\n\n  var parseOffset = function parseOffset(value) {\n    var _value$split = value.split(' ');\n\n    var _value$split2 = _slicedToArray(_value$split, 2);\n\n    var top = _value$split2[0];\n    var left = _value$split2[1];\n\n    return { top: top, left: left };\n  };\n  var parseAttachment = parseOffset;\n\n  var TetherClass = function (_Evented) {\n    _inherits(TetherClass, _Evented);\n\n    function TetherClass(options) {\n      var _this = this;\n\n      _classCallCheck(this, TetherClass);\n\n      _get(Object.getPrototypeOf(TetherClass.prototype), 'constructor', this).call(this);\n      this.position = this.position.bind(this);\n\n      tethers.push(this);\n\n      this.history = [];\n\n      this.setOptions(options, false);\n\n      TetherBase.modules.forEach(function (module) {\n        if (typeof module.initialize !== 'undefined') {\n          module.initialize.call(_this);\n        }\n      });\n\n      this.position();\n    }\n\n    _createClass(TetherClass, [{\n      key: 'getClass',\n      value: function getClass() {\n        var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n        var classes = this.options.classes;\n\n        if (typeof classes !== 'undefined' && classes[key]) {\n          return this.options.classes[key];\n        } else if (this.options.classPrefix) {\n          return this.options.classPrefix + '-' + key;\n        } else {\n          return key;\n        }\n      }\n    }, {\n      key: 'setOptions',\n      value: function setOptions(options) {\n        var _this2 = this;\n\n        var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n        var defaults = {\n          offset: '0 0',\n          targetOffset: '0 0',\n          targetAttachment: 'auto auto',\n          classPrefix: 'tether'\n        };\n\n        this.options = extend(defaults, options);\n\n        var _options = this.options;\n        var element = _options.element;\n        var target = _options.target;\n        var targetModifier = _options.targetModifier;\n\n        this.element = element;\n        this.target = target;\n        this.targetModifier = targetModifier;\n\n        if (this.target === 'viewport') {\n          this.target = document.body;\n          this.targetModifier = 'visible';\n        } else if (this.target === 'scroll-handle') {\n          this.target = document.body;\n          this.targetModifier = 'scroll-handle';\n        }\n\n        ['element', 'target'].forEach(function (key) {\n          if (typeof _this2[key] === 'undefined') {\n            throw new Error('Tether Error: Both element and target must be defined');\n          }\n\n          if (typeof _this2[key].jquery !== 'undefined') {\n            _this2[key] = _this2[key][0];\n          } else if (typeof _this2[key] === 'string') {\n            _this2[key] = document.querySelector(_this2[key]);\n          }\n        });\n\n        addClass(this.element, this.getClass('element'));\n        if (!(this.options.addTargetClasses === false)) {\n          addClass(this.target, this.getClass('target'));\n        }\n\n        if (!this.options.attachment) {\n          throw new Error('Tether Error: You must provide an attachment');\n        }\n\n        this.targetAttachment = parseAttachment(this.options.targetAttachment);\n        this.attachment = parseAttachment(this.options.attachment);\n        this.offset = parseOffset(this.options.offset);\n        this.targetOffset = parseOffset(this.options.targetOffset);\n\n        if (typeof this.scrollParents !== 'undefined') {\n          this.disable();\n        }\n\n        if (this.targetModifier === 'scroll-handle') {\n          this.scrollParents = [this.target];\n        } else {\n          this.scrollParents = getScrollParents(this.target);\n        }\n\n        if (!(this.options.enabled === false)) {\n          this.enable(pos);\n        }\n      }\n    }, {\n      key: 'getTargetBounds',\n      value: function getTargetBounds() {\n        if (typeof this.targetModifier !== 'undefined') {\n          if (this.targetModifier === 'visible') {\n            if (this.target === document.body) {\n              return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\n            } else {\n              var bounds = getBounds(this.target);\n\n              var out = {\n                height: bounds.height,\n                width: bounds.width,\n                top: bounds.top,\n                left: bounds.left\n              };\n\n              out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n              out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\n              out.height = Math.min(innerHeight, out.height);\n              out.height -= 2;\n\n              out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n              out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\n              out.width = Math.min(innerWidth, out.width);\n              out.width -= 2;\n\n              if (out.top < pageYOffset) {\n                out.top = pageYOffset;\n              }\n              if (out.left < pageXOffset) {\n                out.left = pageXOffset;\n              }\n\n              return out;\n            }\n          } else if (this.targetModifier === 'scroll-handle') {\n            var bounds = undefined;\n            var target = this.target;\n            if (target === document.body) {\n              target = document.documentElement;\n\n              bounds = {\n                left: pageXOffset,\n                top: pageYOffset,\n                height: innerHeight,\n                width: innerWidth\n              };\n            } else {\n              bounds = getBounds(target);\n            }\n\n            var style = getComputedStyle(target);\n\n            var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;\n\n            var scrollBottom = 0;\n            if (hasBottomScroll) {\n              scrollBottom = 15;\n            }\n\n            var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n\n            var out = {\n              width: 15,\n              height: height * 0.975 * (height / target.scrollHeight),\n              left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n            };\n\n            var fitAdj = 0;\n            if (height < 408 && this.target === document.body) {\n              fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n            }\n\n            if (this.target !== document.body) {\n              out.height = Math.max(out.height, 24);\n            }\n\n            var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\n            out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n\n            if (this.target === document.body) {\n              out.height = Math.max(out.height, 24);\n            }\n\n            return out;\n          }\n        } else {\n          return getBounds(this.target);\n        }\n      }\n    }, {\n      key: 'clearCache',\n      value: function clearCache() {\n        this._cache = {};\n      }\n    }, {\n      key: 'cache',\n      value: function cache(k, getter) {\n        // More than one module will often need the same DOM info, so\n        // we keep a cache which is cleared on each position call\n        if (typeof this._cache === 'undefined') {\n          this._cache = {};\n        }\n\n        if (typeof this._cache[k] === 'undefined') {\n          this._cache[k] = getter.call(this);\n        }\n\n        return this._cache[k];\n      }\n    }, {\n      key: 'enable',\n      value: function enable() {\n        var _this3 = this;\n\n        var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n        if (!(this.options.addTargetClasses === false)) {\n          addClass(this.target, this.getClass('enabled'));\n        }\n        addClass(this.element, this.getClass('enabled'));\n        this.enabled = true;\n\n        this.scrollParents.forEach(function (parent) {\n          if (parent !== _this3.target.ownerDocument) {\n            parent.addEventListener('scroll', _this3.position);\n          }\n        });\n\n        if (pos) {\n          this.position();\n        }\n      }\n    }, {\n      key: 'disable',\n      value: function disable() {\n        var _this4 = this;\n\n        removeClass(this.target, this.getClass('enabled'));\n        removeClass(this.element, this.getClass('enabled'));\n        this.enabled = false;\n\n        if (typeof this.scrollParents !== 'undefined') {\n          this.scrollParents.forEach(function (parent) {\n            parent.removeEventListener('scroll', _this4.position);\n          });\n        }\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        var _this5 = this;\n\n        this.disable();\n\n        tethers.forEach(function (tether, i) {\n          if (tether === _this5) {\n            tethers.splice(i, 1);\n          }\n        });\n\n        // Remove any elements we were using for convenience from the DOM\n        if (tethers.length === 0) {\n          removeUtilElements();\n        }\n      }\n    }, {\n      key: 'updateAttachClasses',\n      value: function updateAttachClasses(elementAttach, targetAttach) {\n        var _this6 = this;\n\n        elementAttach = elementAttach || this.attachment;\n        targetAttach = targetAttach || this.targetAttachment;\n        var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\n\n        if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {\n          // updateAttachClasses can be called more than once in a position call, so\n          // we need to clean up after ourselves such that when the last defer gets\n          // ran it doesn't add any extra classes from previous calls.\n          this._addAttachClasses.splice(0, this._addAttachClasses.length);\n        }\n\n        if (typeof this._addAttachClasses === 'undefined') {\n          this._addAttachClasses = [];\n        }\n        var add = this._addAttachClasses;\n\n        if (elementAttach.top) {\n          add.push(this.getClass('element-attached') + '-' + elementAttach.top);\n        }\n        if (elementAttach.left) {\n          add.push(this.getClass('element-attached') + '-' + elementAttach.left);\n        }\n        if (targetAttach.top) {\n          add.push(this.getClass('target-attached') + '-' + targetAttach.top);\n        }\n        if (targetAttach.left) {\n          add.push(this.getClass('target-attached') + '-' + targetAttach.left);\n        }\n\n        var all = [];\n        sides.forEach(function (side) {\n          all.push(_this6.getClass('element-attached') + '-' + side);\n          all.push(_this6.getClass('target-attached') + '-' + side);\n        });\n\n        defer(function () {\n          if (!(typeof _this6._addAttachClasses !== 'undefined')) {\n            return;\n          }\n\n          updateClasses(_this6.element, _this6._addAttachClasses, all);\n          if (!(_this6.options.addTargetClasses === false)) {\n            updateClasses(_this6.target, _this6._addAttachClasses, all);\n          }\n\n          delete _this6._addAttachClasses;\n        });\n      }\n    }, {\n      key: 'position',\n      value: function position() {\n        var _this7 = this;\n\n        var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n        // flushChanges commits the changes immediately, leave true unless you are positioning multiple\n        // tethers (in which case call Tether.Utils.flush yourself when you're done)\n\n        if (!this.enabled) {\n          return;\n        }\n\n        this.clearCache();\n\n        // Turn 'auto' attachments into the appropriate corner or edge\n        var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\n\n        this.updateAttachClasses(this.attachment, targetAttachment);\n\n        var elementPos = this.cache('element-bounds', function () {\n          return getBounds(_this7.element);\n        });\n\n        var width = elementPos.width;\n        var height = elementPos.height;\n\n        if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n          var _lastSize = this.lastSize;\n\n          // We cache the height and width to make it possible to position elements that are\n          // getting hidden.\n          width = _lastSize.width;\n          height = _lastSize.height;\n        } else {\n          this.lastSize = { width: width, height: height };\n        }\n\n        var targetPos = this.cache('target-bounds', function () {\n          return _this7.getTargetBounds();\n        });\n        var targetSize = targetPos;\n\n        // Get an actual px offset from the attachment\n        var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });\n        var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\n\n        var manualOffset = offsetToPx(this.offset, { width: width, height: height });\n        var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\n\n        // Add the manually provided offset\n        offset = addOffset(offset, manualOffset);\n        targetOffset = addOffset(targetOffset, manualTargetOffset);\n\n        // It's now our goal to make (element position + offset) == (target position + target offset)\n        var left = targetPos.left + targetOffset.left - offset.left;\n        var top = targetPos.top + targetOffset.top - offset.top;\n\n        for (var i = 0; i < TetherBase.modules.length; ++i) {\n          var _module2 = TetherBase.modules[i];\n          var ret = _module2.position.call(this, {\n            left: left,\n            top: top,\n            targetAttachment: targetAttachment,\n            targetPos: targetPos,\n            elementPos: elementPos,\n            offset: offset,\n            targetOffset: targetOffset,\n            manualOffset: manualOffset,\n            manualTargetOffset: manualTargetOffset,\n            scrollbarSize: scrollbarSize,\n            attachment: this.attachment\n          });\n\n          if (ret === false) {\n            return false;\n          } else if (typeof ret === 'undefined' || (typeof ret === 'undefined' ? 'undefined' : _typeof(ret)) !== 'object') {\n            continue;\n          } else {\n            top = ret.top;\n            left = ret.left;\n          }\n        }\n\n        // We describe the position three different ways to give the optimizer\n        // a chance to decide the best possible way to position the element\n        // with the fewest repaints.\n        var next = {\n          // It's position relative to the page (absolute positioning when\n          // the element is a child of the body)\n          page: {\n            top: top,\n            left: left\n          },\n\n          // It's position relative to the viewport (fixed positioning)\n          viewport: {\n            top: top - pageYOffset,\n            bottom: pageYOffset - top - height + innerHeight,\n            left: left - pageXOffset,\n            right: pageXOffset - left - width + innerWidth\n          }\n        };\n\n        var doc = this.target.ownerDocument;\n        var win = doc.defaultView;\n\n        var scrollbarSize = undefined;\n        if (win.innerHeight > doc.documentElement.clientHeight) {\n          scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n          next.viewport.bottom -= scrollbarSize.height;\n        }\n\n        if (win.innerWidth > doc.documentElement.clientWidth) {\n          scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n          next.viewport.right -= scrollbarSize.width;\n        }\n\n        if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\n          // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\n          next.page.bottom = doc.body.scrollHeight - top - height;\n          next.page.right = doc.body.scrollWidth - left - width;\n        }\n\n        if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {\n          (function () {\n            var offsetParent = _this7.cache('target-offsetparent', function () {\n              return getOffsetParent(_this7.target);\n            });\n            var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {\n              return getBounds(offsetParent);\n            });\n            var offsetParentStyle = getComputedStyle(offsetParent);\n            var offsetParentSize = offsetPosition;\n\n            var offsetBorder = {};\n            ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {\n              offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);\n            });\n\n            offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n            offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n\n            if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\n              if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\n                // We're within the visible part of the target's scroll parent\n                var scrollTop = offsetParent.scrollTop;\n                var scrollLeft = offsetParent.scrollLeft;\n\n                // It's position relative to the target's offset parent (absolute positioning when\n                // the element is moved to be a child of the target's offset parent).\n                next.offset = {\n                  top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n                  left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n                };\n              }\n            }\n          })();\n        }\n\n        // We could also travel up the DOM and try each containing context, rather than only\n        // looking at the body, but we're gonna get diminishing returns.\n\n        this.move(next);\n\n        this.history.unshift(next);\n\n        if (this.history.length > 3) {\n          this.history.pop();\n        }\n\n        if (flushChanges) {\n          flush();\n        }\n\n        return true;\n      }\n\n      // THE ISSUE\n    }, {\n      key: 'move',\n      value: function move(pos) {\n        var _this8 = this;\n\n        if (!(typeof this.element.parentNode !== 'undefined')) {\n          return;\n        }\n\n        var same = {};\n\n        for (var type in pos) {\n          same[type] = {};\n\n          for (var key in pos[type]) {\n            var found = false;\n\n            for (var i = 0; i < this.history.length; ++i) {\n              var point = this.history[i];\n              if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {\n                found = true;\n                break;\n              }\n            }\n\n            if (!found) {\n              same[type][key] = true;\n            }\n          }\n        }\n\n        var css = { top: '', left: '', right: '', bottom: '' };\n\n        var transcribe = function transcribe(_same, _pos) {\n          var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';\n          var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;\n          if (gpu !== false) {\n            var yPos = undefined,\n                xPos = undefined;\n            if (_same.top) {\n              css.top = 0;\n              yPos = _pos.top;\n            } else {\n              css.bottom = 0;\n              yPos = -_pos.bottom;\n            }\n\n            if (_same.left) {\n              css.left = 0;\n              xPos = _pos.left;\n            } else {\n              css.right = 0;\n              xPos = -_pos.right;\n            }\n\n            if (window.matchMedia) {\n              // HubSpot/tether#207\n              var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;\n              if (!retina) {\n                xPos = Math.round(xPos);\n                yPos = Math.round(yPos);\n              }\n            }\n\n            css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';\n\n            if (transformKey !== 'msTransform') {\n              // The Z transform will keep this in the GPU (faster, and prevents artifacts),\n              // but IE9 doesn't support 3d transforms and will choke.\n              css[transformKey] += \" translateZ(0)\";\n            }\n          } else {\n            if (_same.top) {\n              css.top = _pos.top + 'px';\n            } else {\n              css.bottom = _pos.bottom + 'px';\n            }\n\n            if (_same.left) {\n              css.left = _pos.left + 'px';\n            } else {\n              css.right = _pos.right + 'px';\n            }\n          }\n        };\n\n        var moved = false;\n        if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n          css.position = 'absolute';\n          transcribe(same.page, pos.page);\n        } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n          css.position = 'fixed';\n          transcribe(same.viewport, pos.viewport);\n        } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {\n          (function () {\n            css.position = 'absolute';\n            var offsetParent = _this8.cache('target-offsetparent', function () {\n              return getOffsetParent(_this8.target);\n            });\n\n            if (getOffsetParent(_this8.element) !== offsetParent) {\n              defer(function () {\n                _this8.element.parentNode.removeChild(_this8.element);\n                offsetParent.appendChild(_this8.element);\n              });\n            }\n\n            transcribe(same.offset, pos.offset);\n            moved = true;\n          })();\n        } else {\n          css.position = 'absolute';\n          transcribe({ top: true, left: true }, pos.page);\n        }\n\n        if (!moved) {\n          if (this.options.bodyElement) {\n            this.options.bodyElement.appendChild(this.element);\n          } else {\n            var offsetParentIsBody = true;\n            var currentNode = this.element.parentNode;\n            while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {\n              if (getComputedStyle(currentNode).position !== 'static') {\n                offsetParentIsBody = false;\n                break;\n              }\n\n              currentNode = currentNode.parentNode;\n            }\n\n            if (!offsetParentIsBody) {\n              this.element.parentNode.removeChild(this.element);\n              this.element.ownerDocument.body.appendChild(this.element);\n            }\n          }\n        }\n\n        // Any css change will trigger a repaint, so let's avoid one if nothing changed\n        var writeCSS = {};\n        var write = false;\n        for (var key in css) {\n          var val = css[key];\n          var elVal = this.element.style[key];\n\n          if (elVal !== val) {\n            write = true;\n            writeCSS[key] = val;\n          }\n        }\n\n        if (write) {\n          defer(function () {\n            extend(_this8.element.style, writeCSS);\n            _this8.trigger('repositioned');\n          });\n        }\n      }\n    }]);\n\n    return TetherClass;\n  }(Evented);\n\n  TetherClass.modules = [];\n\n  TetherBase.position = position;\n\n  var Tether = extend(TetherClass, TetherBase);\n  /* globals TetherBase */\n\n  'use strict';\n\n  var _slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;_e = err;\n      } finally {\n        try {\n          if (!_n && _i['return']) _i['return']();\n        } finally {\n          if (_d) throw _e;\n        }\n      }return _arr;\n    }return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n      }\n    };\n  }();\n\n  var _TetherBase$Utils = TetherBase.Utils;\n  var getBounds = _TetherBase$Utils.getBounds;\n  var extend = _TetherBase$Utils.extend;\n  var updateClasses = _TetherBase$Utils.updateClasses;\n  var defer = _TetherBase$Utils.defer;\n\n  var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\n\n  function getBoundingRect(tether, to) {\n    if (to === 'scrollParent') {\n      to = tether.scrollParents[0];\n    } else if (to === 'window') {\n      to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\n    }\n\n    if (to === document) {\n      to = to.documentElement;\n    }\n\n    if (typeof to.nodeType !== 'undefined') {\n      (function () {\n        var node = to;\n        var size = getBounds(to);\n        var pos = size;\n        var style = getComputedStyle(to);\n\n        to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\n\n        // Account any parent Frames scroll offset\n        if (node.ownerDocument !== document) {\n          var win = node.ownerDocument.defaultView;\n          to[0] += win.pageXOffset;\n          to[1] += win.pageYOffset;\n          to[2] += win.pageXOffset;\n          to[3] += win.pageYOffset;\n        }\n\n        BOUNDS_FORMAT.forEach(function (side, i) {\n          side = side[0].toUpperCase() + side.substr(1);\n          if (side === 'Top' || side === 'Left') {\n            to[i] += parseFloat(style['border' + side + 'Width']);\n          } else {\n            to[i] -= parseFloat(style['border' + side + 'Width']);\n          }\n        });\n      })();\n    }\n\n    return to;\n  }\n\n  TetherBase.modules.push({\n    position: function position(_ref) {\n      var _this = this;\n\n      var top = _ref.top;\n      var left = _ref.left;\n      var targetAttachment = _ref.targetAttachment;\n\n      if (!this.options.constraints) {\n        return true;\n      }\n\n      var _cache = this.cache('element-bounds', function () {\n        return getBounds(_this.element);\n      });\n\n      var height = _cache.height;\n      var width = _cache.width;\n\n      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n        var _lastSize = this.lastSize;\n\n        // Handle the item getting hidden as a result of our positioning without glitching\n        // the classes in and out\n        width = _lastSize.width;\n        height = _lastSize.height;\n      }\n\n      var targetSize = this.cache('target-bounds', function () {\n        return _this.getTargetBounds();\n      });\n\n      var targetHeight = targetSize.height;\n      var targetWidth = targetSize.width;\n\n      var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\n\n      this.options.constraints.forEach(function (constraint) {\n        var outOfBoundsClass = constraint.outOfBoundsClass;\n        var pinnedClass = constraint.pinnedClass;\n\n        if (outOfBoundsClass) {\n          allClasses.push(outOfBoundsClass);\n        }\n        if (pinnedClass) {\n          allClasses.push(pinnedClass);\n        }\n      });\n\n      allClasses.forEach(function (cls) {\n        ['left', 'top', 'right', 'bottom'].forEach(function (side) {\n          allClasses.push(cls + '-' + side);\n        });\n      });\n\n      var addClasses = [];\n\n      var tAttachment = extend({}, targetAttachment);\n      var eAttachment = extend({}, this.attachment);\n\n      this.options.constraints.forEach(function (constraint) {\n        var to = constraint.to;\n        var attachment = constraint.attachment;\n        var pin = constraint.pin;\n\n        if (typeof attachment === 'undefined') {\n          attachment = '';\n        }\n\n        var changeAttachX = undefined,\n            changeAttachY = undefined;\n        if (attachment.indexOf(' ') >= 0) {\n          var _attachment$split = attachment.split(' ');\n\n          var _attachment$split2 = _slicedToArray(_attachment$split, 2);\n\n          changeAttachY = _attachment$split2[0];\n          changeAttachX = _attachment$split2[1];\n        } else {\n          changeAttachX = changeAttachY = attachment;\n        }\n\n        var bounds = getBoundingRect(_this, to);\n\n        if (changeAttachY === 'target' || changeAttachY === 'both') {\n          if (top < bounds[1] && tAttachment.top === 'top') {\n            top += targetHeight;\n            tAttachment.top = 'bottom';\n          }\n\n          if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n            top -= targetHeight;\n            tAttachment.top = 'top';\n          }\n        }\n\n        if (changeAttachY === 'together') {\n          if (tAttachment.top === 'top') {\n            if (eAttachment.top === 'bottom' && top < bounds[1]) {\n              top += targetHeight;\n              tAttachment.top = 'bottom';\n\n              top += height;\n              eAttachment.top = 'top';\n            } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n              top -= height - targetHeight;\n              tAttachment.top = 'bottom';\n\n              eAttachment.top = 'bottom';\n            }\n          }\n\n          if (tAttachment.top === 'bottom') {\n            if (eAttachment.top === 'top' && top + height > bounds[3]) {\n              top -= targetHeight;\n              tAttachment.top = 'top';\n\n              top -= height;\n              eAttachment.top = 'bottom';\n            } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n              top += height - targetHeight;\n              tAttachment.top = 'top';\n\n              eAttachment.top = 'top';\n            }\n          }\n\n          if (tAttachment.top === 'middle') {\n            if (top + height > bounds[3] && eAttachment.top === 'top') {\n              top -= height;\n              eAttachment.top = 'bottom';\n            } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n              top += height;\n              eAttachment.top = 'top';\n            }\n          }\n        }\n\n        if (changeAttachX === 'target' || changeAttachX === 'both') {\n          if (left < bounds[0] && tAttachment.left === 'left') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n          }\n\n          if (left + width > bounds[2] && tAttachment.left === 'right') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n          }\n        }\n\n        if (changeAttachX === 'together') {\n          if (left < bounds[0] && tAttachment.left === 'left') {\n            if (eAttachment.left === 'right') {\n              left += targetWidth;\n              tAttachment.left = 'right';\n\n              left += width;\n              eAttachment.left = 'left';\n            } else if (eAttachment.left === 'left') {\n              left += targetWidth;\n              tAttachment.left = 'right';\n\n              left -= width;\n              eAttachment.left = 'right';\n            }\n          } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n            if (eAttachment.left === 'left') {\n              left -= targetWidth;\n              tAttachment.left = 'left';\n\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (eAttachment.left === 'right') {\n              left -= targetWidth;\n              tAttachment.left = 'left';\n\n              left += width;\n              eAttachment.left = 'left';\n            }\n          } else if (tAttachment.left === 'center') {\n            if (left + width > bounds[2] && eAttachment.left === 'left') {\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (left < bounds[0] && eAttachment.left === 'right') {\n              left += width;\n              eAttachment.left = 'left';\n            }\n          }\n        }\n\n        if (changeAttachY === 'element' || changeAttachY === 'both') {\n          if (top < bounds[1] && eAttachment.top === 'bottom') {\n            top += height;\n            eAttachment.top = 'top';\n          }\n\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\n            top -= height;\n            eAttachment.top = 'bottom';\n          }\n        }\n\n        if (changeAttachX === 'element' || changeAttachX === 'both') {\n          if (left < bounds[0]) {\n            if (eAttachment.left === 'right') {\n              left += width;\n              eAttachment.left = 'left';\n            } else if (eAttachment.left === 'center') {\n              left += width / 2;\n              eAttachment.left = 'left';\n            }\n          }\n\n          if (left + width > bounds[2]) {\n            if (eAttachment.left === 'left') {\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (eAttachment.left === 'center') {\n              left -= width / 2;\n              eAttachment.left = 'right';\n            }\n          }\n        }\n\n        if (typeof pin === 'string') {\n          pin = pin.split(',').map(function (p) {\n            return p.trim();\n          });\n        } else if (pin === true) {\n          pin = ['top', 'left', 'right', 'bottom'];\n        }\n\n        pin = pin || [];\n\n        var pinned = [];\n        var oob = [];\n\n        if (top < bounds[1]) {\n          if (pin.indexOf('top') >= 0) {\n            top = bounds[1];\n            pinned.push('top');\n          } else {\n            oob.push('top');\n          }\n        }\n\n        if (top + height > bounds[3]) {\n          if (pin.indexOf('bottom') >= 0) {\n            top = bounds[3] - height;\n            pinned.push('bottom');\n          } else {\n            oob.push('bottom');\n          }\n        }\n\n        if (left < bounds[0]) {\n          if (pin.indexOf('left') >= 0) {\n            left = bounds[0];\n            pinned.push('left');\n          } else {\n            oob.push('left');\n          }\n        }\n\n        if (left + width > bounds[2]) {\n          if (pin.indexOf('right') >= 0) {\n            left = bounds[2] - width;\n            pinned.push('right');\n          } else {\n            oob.push('right');\n          }\n        }\n\n        if (pinned.length) {\n          (function () {\n            var pinnedClass = undefined;\n            if (typeof _this.options.pinnedClass !== 'undefined') {\n              pinnedClass = _this.options.pinnedClass;\n            } else {\n              pinnedClass = _this.getClass('pinned');\n            }\n\n            addClasses.push(pinnedClass);\n            pinned.forEach(function (side) {\n              addClasses.push(pinnedClass + '-' + side);\n            });\n          })();\n        }\n\n        if (oob.length) {\n          (function () {\n            var oobClass = undefined;\n            if (typeof _this.options.outOfBoundsClass !== 'undefined') {\n              oobClass = _this.options.outOfBoundsClass;\n            } else {\n              oobClass = _this.getClass('out-of-bounds');\n            }\n\n            addClasses.push(oobClass);\n            oob.forEach(function (side) {\n              addClasses.push(oobClass + '-' + side);\n            });\n          })();\n        }\n\n        if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n          eAttachment.left = tAttachment.left = false;\n        }\n        if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n          eAttachment.top = tAttachment.top = false;\n        }\n\n        if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {\n          _this.updateAttachClasses(eAttachment, tAttachment);\n          _this.trigger('update', {\n            attachment: eAttachment,\n            targetAttachment: tAttachment\n          });\n        }\n      });\n\n      defer(function () {\n        if (!(_this.options.addTargetClasses === false)) {\n          updateClasses(_this.target, addClasses, allClasses);\n        }\n        updateClasses(_this.element, addClasses, allClasses);\n      });\n\n      return { top: top, left: left };\n    }\n  });\n  /* globals TetherBase */\n\n  'use strict';\n\n  var _TetherBase$Utils = TetherBase.Utils;\n  var getBounds = _TetherBase$Utils.getBounds;\n  var updateClasses = _TetherBase$Utils.updateClasses;\n  var defer = _TetherBase$Utils.defer;\n\n  TetherBase.modules.push({\n    position: function position(_ref) {\n      var _this = this;\n\n      var top = _ref.top;\n      var left = _ref.left;\n\n      var _cache = this.cache('element-bounds', function () {\n        return getBounds(_this.element);\n      });\n\n      var height = _cache.height;\n      var width = _cache.width;\n\n      var targetPos = this.getTargetBounds();\n\n      var bottom = top + height;\n      var right = left + width;\n\n      var abutted = [];\n      if (top <= targetPos.bottom && bottom >= targetPos.top) {\n        ['left', 'right'].forEach(function (side) {\n          var targetPosSide = targetPos[side];\n          if (targetPosSide === left || targetPosSide === right) {\n            abutted.push(side);\n          }\n        });\n      }\n\n      if (left <= targetPos.right && right >= targetPos.left) {\n        ['top', 'bottom'].forEach(function (side) {\n          var targetPosSide = targetPos[side];\n          if (targetPosSide === top || targetPosSide === bottom) {\n            abutted.push(side);\n          }\n        });\n      }\n\n      var allClasses = [];\n      var addClasses = [];\n\n      var sides = ['left', 'top', 'right', 'bottom'];\n      allClasses.push(this.getClass('abutted'));\n      sides.forEach(function (side) {\n        allClasses.push(_this.getClass('abutted') + '-' + side);\n      });\n\n      if (abutted.length) {\n        addClasses.push(this.getClass('abutted'));\n      }\n\n      abutted.forEach(function (side) {\n        addClasses.push(_this.getClass('abutted') + '-' + side);\n      });\n\n      defer(function () {\n        if (!(_this.options.addTargetClasses === false)) {\n          updateClasses(_this.target, addClasses, allClasses);\n        }\n        updateClasses(_this.element, addClasses, allClasses);\n      });\n\n      return true;\n    }\n  });\n  /* globals TetherBase */\n\n  'use strict';\n\n  var _slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;_e = err;\n      } finally {\n        try {\n          if (!_n && _i['return']) _i['return']();\n        } finally {\n          if (_d) throw _e;\n        }\n      }return _arr;\n    }return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n      }\n    };\n  }();\n\n  TetherBase.modules.push({\n    position: function position(_ref) {\n      var top = _ref.top;\n      var left = _ref.left;\n\n      if (!this.options.shift) {\n        return;\n      }\n\n      var shift = this.options.shift;\n      if (typeof this.options.shift === 'function') {\n        shift = this.options.shift.call(this, { top: top, left: left });\n      }\n\n      var shiftTop = undefined,\n          shiftLeft = undefined;\n      if (typeof shift === 'string') {\n        shift = shift.split(' ');\n        shift[1] = shift[1] || shift[0];\n\n        var _shift = shift;\n\n        var _shift2 = _slicedToArray(_shift, 2);\n\n        shiftTop = _shift2[0];\n        shiftLeft = _shift2[1];\n\n        shiftTop = parseFloat(shiftTop, 10);\n        shiftLeft = parseFloat(shiftLeft, 10);\n      } else {\n        shiftTop = shift.top;\n        shiftLeft = shift.left;\n      }\n\n      top += shiftTop;\n      left += shiftLeft;\n\n      return { top: top, left: left };\n    }\n  });\n  return Tether;\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L190ZXRoZXJAMS40LjBAdGV0aGVyL2Rpc3QvanMvdGV0aGVyLmpzP2MwNWMiXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJkZWZpbmUiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsIlRldGhlciIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiVHlwZUVycm9yIiwiVGV0aGVyQmFzZSIsInVuZGVmaW5lZCIsIm1vZHVsZXMiLCJ6ZXJvRWxlbWVudCIsImdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdCIsIm5vZGUiLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZWN0IiwiayIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsIl9mcmFtZUVsZW1lbnQiLCJkZWZhdWx0VmlldyIsImZyYW1lRWxlbWVudCIsImZyYW1lUmVjdCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImdldFNjcm9sbFBhcmVudHMiLCJlbCIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJwYXJlbnRzIiwicGFyZW50IiwicGFyZW50Tm9kZSIsIm5vZGVUeXBlIiwic3R5bGUiLCJlcnIiLCJwdXNoIiwiX3N0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJ0ZXN0IiwiaW5kZXhPZiIsImJvZHkiLCJ1bmlxdWVJZCIsImlkIiwiemVyb1Bvc0NhY2hlIiwiZ2V0T3JpZ2luIiwiY29udGFpbnMiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiZXh0ZW5kIiwiYXBwZW5kQ2hpbGQiLCJnZXRBdHRyaWJ1dGUiLCJkZWZlciIsInJlbW92ZVV0aWxFbGVtZW50cyIsInJlbW92ZUNoaWxkIiwiZ2V0Qm91bmRzIiwiZG9jIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jRWwiLCJib3giLCJvcmlnaW4iLCJ3aWR0aCIsInNjcm9sbFdpZHRoIiwiaGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0T2Zmc2V0UGFyZW50Iiwib2Zmc2V0UGFyZW50IiwiX3Njcm9sbEJhclNpemUiLCJnZXRTY3JvbGxCYXJTaXplIiwiaW5uZXIiLCJvdXRlciIsInBvaW50ZXJFdmVudHMiLCJ2aXNpYmlsaXR5Iiwid2lkdGhDb250YWluZWQiLCJvZmZzZXRXaWR0aCIsIndpZHRoU2Nyb2xsIiwib3V0IiwiYXJndW1lbnRzIiwiYXJncyIsIkFycmF5IiwiYXBwbHkiLCJzbGljZSIsImZvckVhY2giLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJyZW1vdmVDbGFzcyIsIm5hbWUiLCJjbGFzc0xpc3QiLCJzcGxpdCIsImNscyIsInRyaW0iLCJyZW1vdmUiLCJyZWdleCIsIlJlZ0V4cCIsImpvaW4iLCJjbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJyZXBsYWNlIiwic2V0Q2xhc3NOYW1lIiwiYWRkQ2xhc3MiLCJhZGQiLCJoYXNDbGFzcyIsIlNWR0FuaW1hdGVkU3RyaW5nIiwiYmFzZVZhbCIsInVwZGF0ZUNsYXNzZXMiLCJhbGwiLCJkZWZlcnJlZCIsImZuIiwiZmx1c2giLCJwb3AiLCJFdmVudGVkIiwidmFsdWUiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsImN0eCIsIm9uY2UiLCJiaW5kaW5ncyIsIm9mZiIsInNwbGljZSIsInRyaWdnZXIiLCJfbGVuIiwiX2tleSIsIl9iaW5kaW5ncyRldmVudCRpIiwiY29udGV4dCIsIlV0aWxzIiwiX3NsaWNlZFRvQXJyYXkiLCJzbGljZUl0ZXJhdG9yIiwiYXJyIiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcyIsIm5leHQiLCJkb25lIiwiaXNBcnJheSIsIl9nZXQiLCJnZXQiLCJfeDYiLCJfeDciLCJfeDgiLCJfYWdhaW4iLCJfZnVuY3Rpb24iLCJvYmplY3QiLCJwcm9wZXJ0eSIsInJlY2VpdmVyIiwiRnVuY3Rpb24iLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXR0ZXIiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiRXJyb3IiLCJfVGV0aGVyQmFzZSRVdGlscyIsIndpdGhpbiIsImEiLCJiIiwiZGlmZiIsInRyYW5zZm9ybUtleSIsInRyYW5zZm9ybXMiLCJ0ZXRoZXJzIiwidGV0aGVyIiwibm93IiwicGVyZm9ybWFuY2UiLCJEYXRlIiwibGFzdENhbGwiLCJsYXN0RHVyYXRpb24iLCJwZW5kaW5nVGltZW91dCIsInRpY2siLCJNYXRoIiwibWluIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJNSVJST1JfTFIiLCJjZW50ZXIiLCJNSVJST1JfVEIiLCJtaWRkbGUiLCJPRkZTRVRfTUFQIiwiYXV0b1RvRml4ZWRBdHRhY2htZW50IiwiYXR0YWNobWVudCIsInJlbGF0aXZlVG9BdHRhY2htZW50IiwiYXR0YWNobWVudFRvT2Zmc2V0IiwiYWRkT2Zmc2V0Iiwib2Zmc2V0cyIsIl9yZWYiLCJwYXJzZUZsb2F0Iiwib2Zmc2V0VG9QeCIsIm9mZnNldCIsInNpemUiLCJwYXJzZU9mZnNldCIsIl92YWx1ZSRzcGxpdCIsIl92YWx1ZSRzcGxpdDIiLCJwYXJzZUF0dGFjaG1lbnQiLCJUZXRoZXJDbGFzcyIsIl9FdmVudGVkIiwib3B0aW9ucyIsIl90aGlzIiwiYmluZCIsImhpc3RvcnkiLCJzZXRPcHRpb25zIiwiaW5pdGlhbGl6ZSIsImdldENsYXNzIiwiY2xhc3NlcyIsImNsYXNzUHJlZml4IiwiX3RoaXMyIiwicG9zIiwiZGVmYXVsdHMiLCJ0YXJnZXRPZmZzZXQiLCJ0YXJnZXRBdHRhY2htZW50IiwiX29wdGlvbnMiLCJlbGVtZW50IiwidGFyZ2V0TW9kaWZpZXIiLCJqcXVlcnkiLCJxdWVyeVNlbGVjdG9yIiwiYWRkVGFyZ2V0Q2xhc3NlcyIsInNjcm9sbFBhcmVudHMiLCJkaXNhYmxlIiwiZW5hYmxlZCIsImVuYWJsZSIsImdldFRhcmdldEJvdW5kcyIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJib3VuZHMiLCJoYXNCb3R0b21TY3JvbGwiLCJzY3JvbGxCb3R0b20iLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwiZml0QWRqIiwicG93IiwibWF4Iiwic2Nyb2xsUGVyY2VudGFnZSIsInNjcm9sbFRvcCIsImNsZWFyQ2FjaGUiLCJfY2FjaGUiLCJjYWNoZSIsIl90aGlzMyIsIl90aGlzNCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwiX3RoaXM1IiwidXBkYXRlQXR0YWNoQ2xhc3NlcyIsImVsZW1lbnRBdHRhY2giLCJ0YXJnZXRBdHRhY2giLCJfdGhpczYiLCJzaWRlcyIsIl9hZGRBdHRhY2hDbGFzc2VzIiwic2lkZSIsIl90aGlzNyIsImZsdXNoQ2hhbmdlcyIsImVsZW1lbnRQb3MiLCJsYXN0U2l6ZSIsIl9sYXN0U2l6ZSIsInRhcmdldFBvcyIsInRhcmdldFNpemUiLCJtYW51YWxPZmZzZXQiLCJtYW51YWxUYXJnZXRPZmZzZXQiLCJfbW9kdWxlMiIsInJldCIsInNjcm9sbGJhclNpemUiLCJwYWdlIiwidmlld3BvcnQiLCJ3aW4iLCJwYXJlbnRFbGVtZW50Iiwib3B0aW1pemF0aW9ucyIsIm1vdmVFbGVtZW50Iiwib2Zmc2V0UG9zaXRpb24iLCJvZmZzZXRQYXJlbnRTdHlsZSIsIm9mZnNldFBhcmVudFNpemUiLCJvZmZzZXRCb3JkZXIiLCJ0b0xvd2VyQ2FzZSIsInNjcm9sbExlZnQiLCJtb3ZlIiwidW5zaGlmdCIsIl90aGlzOCIsInNhbWUiLCJ0eXBlIiwiZm91bmQiLCJwb2ludCIsImNzcyIsInRyYW5zY3JpYmUiLCJfc2FtZSIsIl9wb3MiLCJoYXNPcHRpbWl6YXRpb25zIiwiZ3B1IiwieVBvcyIsInhQb3MiLCJtYXRjaE1lZGlhIiwicmV0aW5hIiwibWF0Y2hlcyIsInJvdW5kIiwibW92ZWQiLCJib2R5RWxlbWVudCIsIm9mZnNldFBhcmVudElzQm9keSIsImN1cnJlbnROb2RlIiwidGFnTmFtZSIsIndyaXRlQ1NTIiwid3JpdGUiLCJ2YWwiLCJlbFZhbCIsIkJPVU5EU19GT1JNQVQiLCJnZXRCb3VuZGluZ1JlY3QiLCJ0byIsInRvVXBwZXJDYXNlIiwic3Vic3RyIiwiY29uc3RyYWludHMiLCJ0YXJnZXRIZWlnaHQiLCJ0YXJnZXRXaWR0aCIsImFsbENsYXNzZXMiLCJjb25zdHJhaW50Iiwib3V0T2ZCb3VuZHNDbGFzcyIsInBpbm5lZENsYXNzIiwiYWRkQ2xhc3NlcyIsInRBdHRhY2htZW50IiwiZUF0dGFjaG1lbnQiLCJwaW4iLCJjaGFuZ2VBdHRhY2hYIiwiY2hhbmdlQXR0YWNoWSIsIl9hdHRhY2htZW50JHNwbGl0IiwiX2F0dGFjaG1lbnQkc3BsaXQyIiwibWFwIiwicCIsInBpbm5lZCIsIm9vYiIsIm9vYkNsYXNzIiwiYWJ1dHRlZCIsInRhcmdldFBvc1NpZGUiLCJzaGlmdCIsInNoaWZ0VG9wIiwic2hpZnRMZWZ0IiwiX3NoaWZ0IiwiX3NoaWZ0MiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQyxXQUFTQSxJQUFULEVBQWVDLE9BQWYsRUFBd0I7QUFDdkIsTUFBSSxJQUFKLEVBQWdEO0FBQzlDQyxJQUFBLG9DQUFPRCxPQUFQO0FBQUE7QUFB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QUF3Q0EsU0FBT3ZDLE1BQVA7QUFFQyxDQWh4REEsQ0FBRCIsImZpbGUiOiI0NjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgdGV0aGVyIDEuNC4wICovXG5cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5UZXRoZXIgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBUZXRoZXJCYXNlID0gdW5kZWZpbmVkO1xuaWYgKHR5cGVvZiBUZXRoZXJCYXNlID09PSAndW5kZWZpbmVkJykge1xuICBUZXRoZXJCYXNlID0geyBtb2R1bGVzOiBbXSB9O1xufVxuXG52YXIgemVyb0VsZW1lbnQgPSBudWxsO1xuXG4vLyBTYW1lIGFzIG5hdGl2ZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QsIGV4Y2VwdCBpdCB0YWtlcyBpbnRvIGFjY291bnQgcGFyZW50IDxmcmFtZT4gb2Zmc2V0c1xuLy8gaWYgdGhlIGVsZW1lbnQgbGllcyB3aXRoaW4gYSBuZXN0ZWQgZG9jdW1lbnQgKDxmcmFtZT4gb3IgPGlmcmFtZT4tbGlrZSkuXG5mdW5jdGlvbiBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSkge1xuICB2YXIgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAvLyBUaGUgb3JpZ2luYWwgb2JqZWN0IHJldHVybmVkIGJ5IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBpbW11dGFibGUsIHNvIHdlIGNsb25lIGl0XG4gIC8vIFdlIGNhbid0IHVzZSBleHRlbmQgYmVjYXVzZSB0aGUgcHJvcGVydGllcyBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgb2JqZWN0IGJ5IGhhc093blByb3BlcnR5IGluIElFOVxuICB2YXIgcmVjdCA9IHt9O1xuICBmb3IgKHZhciBrIGluIGJvdW5kaW5nUmVjdCkge1xuICAgIHJlY3Rba10gPSBib3VuZGluZ1JlY3Rba107XG4gIH1cblxuICBpZiAobm9kZS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgIHZhciBfZnJhbWVFbGVtZW50ID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmZyYW1lRWxlbWVudDtcbiAgICBpZiAoX2ZyYW1lRWxlbWVudCkge1xuICAgICAgdmFyIGZyYW1lUmVjdCA9IGdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdChfZnJhbWVFbGVtZW50KTtcbiAgICAgIHJlY3QudG9wICs9IGZyYW1lUmVjdC50b3A7XG4gICAgICByZWN0LmJvdHRvbSArPSBmcmFtZVJlY3QudG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IGZyYW1lUmVjdC5sZWZ0O1xuICAgICAgcmVjdC5yaWdodCArPSBmcmFtZVJlY3QubGVmdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50cyhlbCkge1xuICAvLyBJbiBmaXJlZm94IGlmIHRoZSBlbCBpcyBpbnNpZGUgYW4gaWZyYW1lIHdpdGggZGlzcGxheTogbm9uZTsgd2luZG93LmdldENvbXB1dGVkU3R5bGUoKSB3aWxsIHJldHVybiBudWxsO1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKSB8fCB7fTtcbiAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbjtcbiAgdmFyIHBhcmVudHMgPSBbXTtcblxuICBpZiAocG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gW2VsXTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkgJiYgcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHZhciBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc3R5bGUgPT09IG51bGwpIHtcbiAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgdmFyIF9zdHlsZSA9IHN0eWxlO1xuICAgIHZhciBvdmVyZmxvdyA9IF9zdHlsZS5vdmVyZmxvdztcbiAgICB2YXIgb3ZlcmZsb3dYID0gX3N0eWxlLm92ZXJmbG93WDtcbiAgICB2YXIgb3ZlcmZsb3dZID0gX3N0eWxlLm92ZXJmbG93WTtcblxuICAgIGlmICgvKGF1dG98c2Nyb2xsKS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyB8fCBbJ3JlbGF0aXZlJywgJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihzdHlsZS5wb3NpdGlvbikgPj0gMCkge1xuICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwYXJlbnRzLnB1c2goZWwub3duZXJEb2N1bWVudC5ib2R5KTtcblxuICAvLyBJZiB0aGUgbm9kZSBpcyB3aXRoaW4gYSBmcmFtZSwgYWNjb3VudCBmb3IgdGhlIHBhcmVudCB3aW5kb3cgc2Nyb2xsXG4gIGlmIChlbC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgIHBhcmVudHMucHVzaChlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRzO1xufVxuXG52YXIgdW5pcXVlSWQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiArK2lkO1xuICB9O1xufSkoKTtcblxudmFyIHplcm9Qb3NDYWNoZSA9IHt9O1xudmFyIGdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbigpIHtcbiAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHVuZm9ydHVuYXRlbHkgdG9vIGFjY3VyYXRlLiAgSXQgaW50cm9kdWNlcyBhIHBpeGVsIG9yIHR3byBvZlxuICAvLyBqaXR0ZXIgYXMgdGhlIHVzZXIgc2Nyb2xscyB0aGF0IG1lc3NlcyB3aXRoIG91ciBhYmlsaXR5IHRvIGRldGVjdCBpZiB0d28gcG9zaXRpb25zXG4gIC8vIGFyZSBlcXVpdmlsYW50IG9yIG5vdC4gIFdlIHBsYWNlIGFuIGVsZW1lbnQgYXQgdGhlIHRvcCBsZWZ0IG9mIHRoZSBwYWdlIHRoYXQgd2lsbFxuICAvLyBnZXQgdGhlIHNhbWUgaml0dGVyLCBzbyB3ZSBjYW4gY2FuY2VsIHRoZSB0d28gb3V0LlxuICB2YXIgbm9kZSA9IHplcm9FbGVtZW50O1xuICBpZiAoIW5vZGUgfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMobm9kZSkpIHtcbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGV0aGVyLWlkJywgdW5pcXVlSWQoKSk7XG4gICAgZXh0ZW5kKG5vZGUuc3R5bGUsIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgIHplcm9FbGVtZW50ID0gbm9kZTtcbiAgfVxuXG4gIHZhciBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRldGhlci1pZCcpO1xuICBpZiAodHlwZW9mIHplcm9Qb3NDYWNoZVtpZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgemVyb1Bvc0NhY2hlW2lkXSA9IGdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdChub2RlKTtcblxuICAgIC8vIENsZWFyIHRoZSBjYWNoZSB3aGVuIHRoaXMgcG9zaXRpb24gY2FsbCBpcyBkb25lXG4gICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIHplcm9Qb3NDYWNoZVtpZF07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gemVyb1Bvc0NhY2hlW2lkXTtcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZVV0aWxFbGVtZW50cygpIHtcbiAgaWYgKHplcm9FbGVtZW50KSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh6ZXJvRWxlbWVudCk7XG4gIH1cbiAgemVyb0VsZW1lbnQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRzKGVsKSB7XG4gIHZhciBkb2MgPSB1bmRlZmluZWQ7XG4gIGlmIChlbCA9PT0gZG9jdW1lbnQpIHtcbiAgICBkb2MgPSBkb2N1bWVudDtcbiAgICBlbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICB9XG5cbiAgdmFyIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICB2YXIgYm94ID0gZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0KGVsKTtcblxuICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKCk7XG5cbiAgYm94LnRvcCAtPSBvcmlnaW4udG9wO1xuICBib3gubGVmdCAtPSBvcmlnaW4ubGVmdDtcblxuICBpZiAodHlwZW9mIGJveC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBib3gud2lkdGggPSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoIC0gYm94LmxlZnQgLSBib3gucmlnaHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBib3guaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGJveC5oZWlnaHQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIGJveC50b3AgLSBib3guYm90dG9tO1xuICB9XG5cbiAgYm94LnRvcCA9IGJveC50b3AgLSBkb2NFbC5jbGllbnRUb3A7XG4gIGJveC5sZWZ0ID0gYm94LmxlZnQgLSBkb2NFbC5jbGllbnRMZWZ0O1xuICBib3gucmlnaHQgPSBkb2MuYm9keS5jbGllbnRXaWR0aCAtIGJveC53aWR0aCAtIGJveC5sZWZ0O1xuICBib3guYm90dG9tID0gZG9jLmJvZHkuY2xpZW50SGVpZ2h0IC0gYm94LmhlaWdodCAtIGJveC50b3A7XG5cbiAgcmV0dXJuIGJveDtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsKSB7XG4gIHJldHVybiBlbC5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG52YXIgX3Njcm9sbEJhclNpemUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsQmFyU2l6ZSgpIHtcbiAgaWYgKF9zY3JvbGxCYXJTaXplKSB7XG4gICAgcmV0dXJuIF9zY3JvbGxCYXJTaXplO1xuICB9XG4gIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbm5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JztcblxuICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZXh0ZW5kKG91dGVyLnN0eWxlLCB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgIHdpZHRoOiAnMjAwcHgnLFxuICAgIGhlaWdodDogJzE1MHB4JyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgfSk7XG5cbiAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXG4gIHZhciB3aWR0aENvbnRhaW5lZCA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICB2YXIgd2lkdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRXaWR0aDtcblxuICBpZiAod2lkdGhDb250YWluZWQgPT09IHdpZHRoU2Nyb2xsKSB7XG4gICAgd2lkdGhTY3JvbGwgPSBvdXRlci5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuXG4gIHZhciB3aWR0aCA9IHdpZHRoQ29udGFpbmVkIC0gd2lkdGhTY3JvbGw7XG5cbiAgX3Njcm9sbEJhclNpemUgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiB3aWR0aCB9O1xuICByZXR1cm4gX3Njcm9sbEJhclNpemU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgdmFyIG91dCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciBhcmdzID0gW107XG5cbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICBhcmdzLnNsaWNlKDEpLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmopIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xuICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICBpZiAoY2xzLnRyaW0oKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKF58ICknICsgbmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoIHwkKScsICdnaScpO1xuICAgIHZhciBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUoZWwpLnJlcGxhY2UocmVnZXgsICcgJyk7XG4gICAgc2V0Q2xhc3NOYW1lKGVsLCBjbGFzc05hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG5hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgIGlmIChjbHMudHJpbSgpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzcyhlbCwgbmFtZSk7XG4gICAgdmFyIGNscyA9IGdldENsYXNzTmFtZShlbCkgKyAoJyAnICsgbmFtZSk7XG4gICAgc2V0Q2xhc3NOYW1lKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gIH1cbiAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShlbCk7XG4gIHJldHVybiBuZXcgUmVnRXhwKCcoXnwgKScgKyBuYW1lICsgJyggfCQpJywgJ2dpJykudGVzdChjbGFzc05hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoZWwpIHtcbiAgLy8gQ2FuJ3QgdXNlIGp1c3QgU1ZHQW5pbWF0ZWRTdHJpbmcgaGVyZSBzaW5jZSBub2RlcyB3aXRoaW4gYSBGcmFtZSBpbiBJRSBoYXZlXG4gIC8vIGNvbXBsZXRlbHkgc2VwYXJhdGVseSBTVkdBbmltYXRlZFN0cmluZyBiYXNlIGNsYXNzZXNcbiAgaWYgKGVsLmNsYXNzTmFtZSBpbnN0YW5jZW9mIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuU1ZHQW5pbWF0ZWRTdHJpbmcpIHtcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWw7XG4gIH1cbiAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gc2V0Q2xhc3NOYW1lKGVsLCBjbGFzc05hbWUpIHtcbiAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzZXMoZWwsIGFkZCwgYWxsKSB7XG4gIC8vIE9mIHRoZSBzZXQgb2YgJ2FsbCcgY2xhc3Nlcywgd2UgbmVlZCB0aGUgJ2FkZCcgY2xhc3NlcywgYW5kIG9ubHkgdGhlXG4gIC8vICdhZGQnIGNsYXNzZXMgdG8gYmUgc2V0LlxuICBhbGwuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgaWYgKGFkZC5pbmRleE9mKGNscykgPT09IC0xICYmIGhhc0NsYXNzKGVsLCBjbHMpKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFkZC5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICBpZiAoIWhhc0NsYXNzKGVsLCBjbHMpKSB7XG4gICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGVmZXJyZWQgPSBbXTtcblxudmFyIGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoZm4pIHtcbiAgZGVmZXJyZWQucHVzaChmbik7XG59O1xuXG52YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgdmFyIGZuID0gdW5kZWZpbmVkO1xuICB3aGlsZSAoZm4gPSBkZWZlcnJlZC5wb3AoKSkge1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBFdmVudGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRlZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRlZCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRlZCwgW3tcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICAgIHZhciBvbmNlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbM107XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kaW5ncyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnB1c2goeyBoYW5kbGVyOiBoYW5kbGVyLCBjdHg6IGN0eCwgb25jZTogb25jZSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShldmVudCwgaGFuZGxlciwgY3R4KSB7XG4gICAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdGhpcy5iaW5kaW5nc1tldmVudF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1tldmVudF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5iaW5kaW5nc1tldmVudF0ubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbZXZlbnRdW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyaWdnZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50KSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuYmluZGluZ3NbZXZlbnRdKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5iaW5kaW5nc1tldmVudF0ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIF9iaW5kaW5ncyRldmVudCRpID0gdGhpcy5iaW5kaW5nc1tldmVudF1baV07XG4gICAgICAgICAgdmFyIGhhbmRsZXIgPSBfYmluZGluZ3MkZXZlbnQkaS5oYW5kbGVyO1xuICAgICAgICAgIHZhciBjdHggPSBfYmluZGluZ3MkZXZlbnQkaS5jdHg7XG4gICAgICAgICAgdmFyIG9uY2UgPSBfYmluZGluZ3MkZXZlbnQkaS5vbmNlO1xuXG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBjdHg7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcblxuICAgICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRlZDtcbn0pKCk7XG5cblRldGhlckJhc2UuVXRpbHMgPSB7XG4gIGdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0LFxuICBnZXRTY3JvbGxQYXJlbnRzOiBnZXRTY3JvbGxQYXJlbnRzLFxuICBnZXRCb3VuZHM6IGdldEJvdW5kcyxcbiAgZ2V0T2Zmc2V0UGFyZW50OiBnZXRPZmZzZXRQYXJlbnQsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICB1cGRhdGVDbGFzc2VzOiB1cGRhdGVDbGFzc2VzLFxuICBkZWZlcjogZGVmZXIsXG4gIGZsdXNoOiBmbHVzaCxcbiAgdW5pcXVlSWQ6IHVuaXF1ZUlkLFxuICBFdmVudGVkOiBFdmVudGVkLFxuICBnZXRTY3JvbGxCYXJTaXplOiBnZXRTY3JvbGxCYXJTaXplLFxuICByZW1vdmVVdGlsRWxlbWVudHM6IHJlbW92ZVV0aWxFbGVtZW50c1xufTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSwgcGVyZm9ybWFuY2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3g2LCBfeDcsIF94OCkgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDYsIHByb3BlcnR5ID0gX3g3LCByZWNlaXZlciA9IF94ODsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDYgPSBwYXJlbnQ7IF94NyA9IHByb3BlcnR5OyBfeDggPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaWYgKHR5cGVvZiBUZXRoZXJCYXNlID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGluY2x1ZGUgdGhlIHV0aWxzLmpzIGZpbGUgYmVmb3JlIHRldGhlci5qcycpO1xufVxuXG52YXIgX1RldGhlckJhc2UkVXRpbHMgPSBUZXRoZXJCYXNlLlV0aWxzO1xudmFyIGdldFNjcm9sbFBhcmVudHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRTY3JvbGxQYXJlbnRzO1xudmFyIGdldEJvdW5kcyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldEJvdW5kcztcbnZhciBnZXRPZmZzZXRQYXJlbnQgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRPZmZzZXRQYXJlbnQ7XG52YXIgZXh0ZW5kID0gX1RldGhlckJhc2UkVXRpbHMuZXh0ZW5kO1xudmFyIGFkZENsYXNzID0gX1RldGhlckJhc2UkVXRpbHMuYWRkQ2xhc3M7XG52YXIgcmVtb3ZlQ2xhc3MgPSBfVGV0aGVyQmFzZSRVdGlscy5yZW1vdmVDbGFzcztcbnZhciB1cGRhdGVDbGFzc2VzID0gX1RldGhlckJhc2UkVXRpbHMudXBkYXRlQ2xhc3NlcztcbnZhciBkZWZlciA9IF9UZXRoZXJCYXNlJFV0aWxzLmRlZmVyO1xudmFyIGZsdXNoID0gX1RldGhlckJhc2UkVXRpbHMuZmx1c2g7XG52YXIgZ2V0U2Nyb2xsQmFyU2l6ZSA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldFNjcm9sbEJhclNpemU7XG52YXIgcmVtb3ZlVXRpbEVsZW1lbnRzID0gX1RldGhlckJhc2UkVXRpbHMucmVtb3ZlVXRpbEVsZW1lbnRzO1xuXG5mdW5jdGlvbiB3aXRoaW4oYSwgYikge1xuICB2YXIgZGlmZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IDEgOiBhcmd1bWVudHNbMl07XG5cbiAgcmV0dXJuIGEgKyBkaWZmID49IGIgJiYgYiA+PSBhIC0gZGlmZjtcbn1cblxudmFyIHRyYW5zZm9ybUtleSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHZhciB0cmFuc2Zvcm1zID0gWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBrZXkgPSB0cmFuc2Zvcm1zW2ldO1xuICAgIGlmIChlbC5zdHlsZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgdGV0aGVycyA9IFtdO1xuXG52YXIgcG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgdGV0aGVycy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXRoZXIpIHtcbiAgICB0ZXRoZXIucG9zaXRpb24oZmFsc2UpO1xuICB9KTtcbiAgZmx1c2goKTtcbn07XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH1cbiAgcmV0dXJuICtuZXcgRGF0ZSgpO1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgbGFzdENhbGwgPSBudWxsO1xuICB2YXIgbGFzdER1cmF0aW9uID0gbnVsbDtcbiAgdmFyIHBlbmRpbmdUaW1lb3V0ID0gbnVsbDtcblxuICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgaWYgKHR5cGVvZiBsYXN0RHVyYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxhc3REdXJhdGlvbiA+IDE2KSB7XG4gICAgICAvLyBXZSB2b2x1bnRhcmlseSB0aHJvdHRsZSBvdXJzZWx2ZXMgaWYgd2UgY2FuJ3QgbWFuYWdlIDYwZnBzXG4gICAgICBsYXN0RHVyYXRpb24gPSBNYXRoLm1pbihsYXN0RHVyYXRpb24gLSAxNiwgMjUwKTtcblxuICAgICAgLy8gSnVzdCBpbiBjYXNlIHRoaXMgaXMgdGhlIGxhc3QgZXZlbnQsIHJlbWVtYmVyIHRvIHBvc2l0aW9uIGp1c3Qgb25jZSBtb3JlXG4gICAgICBwZW5kaW5nVGltZW91dCA9IHNldFRpbWVvdXQodGljaywgMjUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxhc3RDYWxsICE9PSAndW5kZWZpbmVkJyAmJiBub3coKSAtIGxhc3RDYWxsIDwgMTApIHtcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgY2FsbCBldmVudHMgYSBsaXR0bGUgdG9vIGZyZXF1ZW50bHksIHJlZnVzZSB0byBydW4gbW9yZSB0aGFuIGlzIHJlYXNvbmFibGVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ1RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmdUaW1lb3V0KTtcbiAgICAgIHBlbmRpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBsYXN0Q2FsbCA9IG5vdygpO1xuICAgIHBvc2l0aW9uKCk7XG4gICAgbGFzdER1cmF0aW9uID0gbm93KCkgLSBsYXN0Q2FsbDtcbiAgfTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIFsncmVzaXplJywgJ3Njcm9sbCcsICd0b3VjaG1vdmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRpY2spO1xuICAgIH0pO1xuICB9XG59KSgpO1xuXG52YXIgTUlSUk9SX0xSID0ge1xuICBjZW50ZXI6ICdjZW50ZXInLFxuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnXG59O1xuXG52YXIgTUlSUk9SX1RCID0ge1xuICBtaWRkbGU6ICdtaWRkbGUnLFxuICB0b3A6ICdib3R0b20nLFxuICBib3R0b206ICd0b3AnXG59O1xuXG52YXIgT0ZGU0VUX01BUCA9IHtcbiAgdG9wOiAwLFxuICBsZWZ0OiAwLFxuICBtaWRkbGU6ICc1MCUnLFxuICBjZW50ZXI6ICc1MCUnLFxuICBib3R0b206ICcxMDAlJyxcbiAgcmlnaHQ6ICcxMDAlJ1xufTtcblxudmFyIGF1dG9Ub0ZpeGVkQXR0YWNobWVudCA9IGZ1bmN0aW9uIGF1dG9Ub0ZpeGVkQXR0YWNobWVudChhdHRhY2htZW50LCByZWxhdGl2ZVRvQXR0YWNobWVudCkge1xuICB2YXIgbGVmdCA9IGF0dGFjaG1lbnQubGVmdDtcbiAgdmFyIHRvcCA9IGF0dGFjaG1lbnQudG9wO1xuXG4gIGlmIChsZWZ0ID09PSAnYXV0bycpIHtcbiAgICBsZWZ0ID0gTUlSUk9SX0xSW3JlbGF0aXZlVG9BdHRhY2htZW50LmxlZnRdO1xuICB9XG5cbiAgaWYgKHRvcCA9PT0gJ2F1dG8nKSB7XG4gICAgdG9wID0gTUlSUk9SX1RCW3JlbGF0aXZlVG9BdHRhY2htZW50LnRvcF07XG4gIH1cblxuICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xufTtcblxudmFyIGF0dGFjaG1lbnRUb09mZnNldCA9IGZ1bmN0aW9uIGF0dGFjaG1lbnRUb09mZnNldChhdHRhY2htZW50KSB7XG4gIHZhciBsZWZ0ID0gYXR0YWNobWVudC5sZWZ0O1xuICB2YXIgdG9wID0gYXR0YWNobWVudC50b3A7XG5cbiAgaWYgKHR5cGVvZiBPRkZTRVRfTUFQW2F0dGFjaG1lbnQubGVmdF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGVmdCA9IE9GRlNFVF9NQVBbYXR0YWNobWVudC5sZWZ0XTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgT0ZGU0VUX01BUFthdHRhY2htZW50LnRvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdG9wID0gT0ZGU0VUX01BUFthdHRhY2htZW50LnRvcF07XG4gIH1cblxuICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xufTtcblxuZnVuY3Rpb24gYWRkT2Zmc2V0KCkge1xuICB2YXIgb3V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb2Zmc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG9mZnNldHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBvZmZzZXRzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgdG9wID0gX3JlZi50b3A7XG4gICAgdmFyIGxlZnQgPSBfcmVmLmxlZnQ7XG5cbiAgICBpZiAodHlwZW9mIHRvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRvcCA9IHBhcnNlRmxvYXQodG9wLCAxMCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxlZnQgPSBwYXJzZUZsb2F0KGxlZnQsIDEwKTtcbiAgICB9XG5cbiAgICBvdXQudG9wICs9IHRvcDtcbiAgICBvdXQubGVmdCArPSBsZWZ0O1xuICB9KTtcblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBvZmZzZXRUb1B4KG9mZnNldCwgc2l6ZSkge1xuICBpZiAodHlwZW9mIG9mZnNldC5sZWZ0ID09PSAnc3RyaW5nJyAmJiBvZmZzZXQubGVmdC5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgb2Zmc2V0LmxlZnQgPSBwYXJzZUZsb2F0KG9mZnNldC5sZWZ0LCAxMCkgLyAxMDAgKiBzaXplLndpZHRoO1xuICB9XG4gIGlmICh0eXBlb2Ygb2Zmc2V0LnRvcCA9PT0gJ3N0cmluZycgJiYgb2Zmc2V0LnRvcC5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgb2Zmc2V0LnRvcCA9IHBhcnNlRmxvYXQob2Zmc2V0LnRvcCwgMTApIC8gMTAwICogc2l6ZS5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG52YXIgcGFyc2VPZmZzZXQgPSBmdW5jdGlvbiBwYXJzZU9mZnNldCh2YWx1ZSkge1xuICB2YXIgX3ZhbHVlJHNwbGl0ID0gdmFsdWUuc3BsaXQoJyAnKTtcblxuICB2YXIgX3ZhbHVlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMik7XG5cbiAgdmFyIHRvcCA9IF92YWx1ZSRzcGxpdDJbMF07XG4gIHZhciBsZWZ0ID0gX3ZhbHVlJHNwbGl0MlsxXTtcblxuICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xufTtcbnZhciBwYXJzZUF0dGFjaG1lbnQgPSBwYXJzZU9mZnNldDtcblxudmFyIFRldGhlckNsYXNzID0gKGZ1bmN0aW9uIChfRXZlbnRlZCkge1xuICBfaW5oZXJpdHMoVGV0aGVyQ2xhc3MsIF9FdmVudGVkKTtcblxuICBmdW5jdGlvbiBUZXRoZXJDbGFzcyhvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXRoZXJDbGFzcyk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihUZXRoZXJDbGFzcy5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmJpbmQodGhpcyk7XG5cbiAgICB0ZXRoZXJzLnB1c2godGhpcyk7XG5cbiAgICB0aGlzLmhpc3RvcnkgPSBbXTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLCBmYWxzZSk7XG5cbiAgICBUZXRoZXJCYXNlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICBpZiAodHlwZW9mIG1vZHVsZS5pbml0aWFsaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuaW5pdGlhbGl6ZS5jYWxsKF90aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucG9zaXRpb24oKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXRoZXJDbGFzcywgW3tcbiAgICBrZXk6ICdnZXRDbGFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsYXNzKCkge1xuICAgICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLm9wdGlvbnMuY2xhc3NlcztcblxuICAgICAgaWYgKHR5cGVvZiBjbGFzc2VzICE9PSAndW5kZWZpbmVkJyAmJiBjbGFzc2VzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGFzc2VzW2tleV07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsYXNzUHJlZml4ICsgJy0nICsga2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgb2Zmc2V0OiAnMCAwJyxcbiAgICAgICAgdGFyZ2V0T2Zmc2V0OiAnMCAwJyxcbiAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogJ2F1dG8gYXV0bycsXG4gICAgICAgIGNsYXNzUHJlZml4OiAndGV0aGVyJ1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgdmFyIF9vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGVsZW1lbnQgPSBfb3B0aW9ucy5lbGVtZW50O1xuICAgICAgdmFyIHRhcmdldCA9IF9vcHRpb25zLnRhcmdldDtcbiAgICAgIHZhciB0YXJnZXRNb2RpZmllciA9IF9vcHRpb25zLnRhcmdldE1vZGlmaWVyO1xuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gdGFyZ2V0TW9kaWZpZXI7XG5cbiAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSAndmlzaWJsZSc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09PSAnc2Nyb2xsLWhhbmRsZScpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gJ3Njcm9sbC1oYW5kbGUnO1xuICAgICAgfVxuXG4gICAgICBbJ2VsZW1lbnQnLCAndGFyZ2V0J10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXMyW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXRoZXIgRXJyb3I6IEJvdGggZWxlbWVudCBhbmQgdGFyZ2V0IG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczJba2V5XS5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgX3RoaXMyW2tleV0gPSBfdGhpczJba2V5XVswXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoaXMyW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX3RoaXMyW2tleV0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF90aGlzMltrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZWxlbWVudCcpKTtcbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXR0YWNobWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RldGhlciBFcnJvcjogWW91IG11c3QgcHJvdmlkZSBhbiBhdHRhY2htZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGFyZ2V0QXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudCh0aGlzLm9wdGlvbnMudGFyZ2V0QXR0YWNobWVudCk7XG4gICAgICB0aGlzLmF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQodGhpcy5vcHRpb25zLmF0dGFjaG1lbnQpO1xuICAgICAgdGhpcy5vZmZzZXQgPSBwYXJzZU9mZnNldCh0aGlzLm9wdGlvbnMub2Zmc2V0KTtcbiAgICAgIHRoaXMudGFyZ2V0T2Zmc2V0ID0gcGFyc2VPZmZzZXQodGhpcy5vcHRpb25zLnRhcmdldE9mZnNldCk7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zY3JvbGxQYXJlbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICdzY3JvbGwtaGFuZGxlJykge1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMgPSBbdGhpcy50YXJnZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzID0gZ2V0U2Nyb2xsUGFyZW50cyh0aGlzLnRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkpIHtcbiAgICAgICAgdGhpcy5lbmFibGUocG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUYXJnZXRCb3VuZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYXJnZXRCb3VuZHMoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudGFyZ2V0TW9kaWZpZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldE1vZGlmaWVyID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRvcDogcGFnZVlPZmZzZXQsIGxlZnQ6IHBhZ2VYT2Zmc2V0LCBoZWlnaHQ6IGlubmVySGVpZ2h0LCB3aWR0aDogaW5uZXJXaWR0aCB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRzKHRoaXMudGFyZ2V0KTtcblxuICAgICAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aDogYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgICB0b3A6IGJvdW5kcy50b3AsXG4gICAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4ob3V0LmhlaWdodCwgYm91bmRzLmhlaWdodCAtIChwYWdlWU9mZnNldCAtIGJvdW5kcy50b3ApKTtcbiAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1pbihvdXQuaGVpZ2h0LCBib3VuZHMuaGVpZ2h0IC0gKGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0IC0gKHBhZ2VZT2Zmc2V0ICsgaW5uZXJIZWlnaHQpKSk7XG4gICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4oaW5uZXJIZWlnaHQsIG91dC5oZWlnaHQpO1xuICAgICAgICAgICAgb3V0LmhlaWdodCAtPSAyO1xuXG4gICAgICAgICAgICBvdXQud2lkdGggPSBNYXRoLm1pbihvdXQud2lkdGgsIGJvdW5kcy53aWR0aCAtIChwYWdlWE9mZnNldCAtIGJvdW5kcy5sZWZ0KSk7XG4gICAgICAgICAgICBvdXQud2lkdGggPSBNYXRoLm1pbihvdXQud2lkdGgsIGJvdW5kcy53aWR0aCAtIChib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIChwYWdlWE9mZnNldCArIGlubmVyV2lkdGgpKSk7XG4gICAgICAgICAgICBvdXQud2lkdGggPSBNYXRoLm1pbihpbm5lcldpZHRoLCBvdXQud2lkdGgpO1xuICAgICAgICAgICAgb3V0LndpZHRoIC09IDI7XG5cbiAgICAgICAgICAgIGlmIChvdXQudG9wIDwgcGFnZVlPZmZzZXQpIHtcbiAgICAgICAgICAgICAgb3V0LnRvcCA9IHBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dC5sZWZ0IDwgcGFnZVhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgb3V0LmxlZnQgPSBwYWdlWE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXRNb2RpZmllciA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XG4gICAgICAgICAgdmFyIGJvdW5kcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgICAgaWYgKHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgICBib3VuZHMgPSB7XG4gICAgICAgICAgICAgIGxlZnQ6IHBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICB0b3A6IHBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aDogaW5uZXJXaWR0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm91bmRzID0gZ2V0Qm91bmRzKHRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuXG4gICAgICAgICAgdmFyIGhhc0JvdHRvbVNjcm9sbCA9IHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aCB8fCBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WF0uaW5kZXhPZignc2Nyb2xsJykgPj0gMCB8fCB0aGlzLnRhcmdldCAhPT0gZG9jdW1lbnQuYm9keTtcblxuICAgICAgICAgIHZhciBzY3JvbGxCb3R0b20gPSAwO1xuICAgICAgICAgIGlmIChoYXNCb3R0b21TY3JvbGwpIHtcbiAgICAgICAgICAgIHNjcm9sbEJvdHRvbSA9IDE1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgLSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKSAtIHNjcm9sbEJvdHRvbTtcblxuICAgICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICB3aWR0aDogMTUsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIDAuOTc1ICogKGhlaWdodCAvIHRhcmdldC5zY3JvbGxIZWlnaHQpLFxuICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckxlZnRXaWR0aCkgLSAxNVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZml0QWRqID0gMDtcbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgNDA4ICYmIHRoaXMudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBmaXRBZGogPSAtMC4wMDAxMSAqIE1hdGgucG93KGhlaWdodCwgMikgLSAwLjAwNzI3ICogaGVpZ2h0ICsgMjIuNTg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5tYXgob3V0LmhlaWdodCwgMjQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzY3JvbGxQZXJjZW50YWdlID0gdGhpcy50YXJnZXQuc2Nyb2xsVG9wIC8gKHRhcmdldC5zY3JvbGxIZWlnaHQgLSBoZWlnaHQpO1xuICAgICAgICAgIG91dC50b3AgPSBzY3JvbGxQZXJjZW50YWdlICogKGhlaWdodCAtIG91dC5oZWlnaHQgLSBmaXRBZGopICsgYm91bmRzLnRvcCArIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5tYXgob3V0LmhlaWdodCwgMjQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRCb3VuZHModGhpcy50YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyQ2FjaGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWNoZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhY2hlKGssIGdldHRlcikge1xuICAgICAgLy8gTW9yZSB0aGFuIG9uZSBtb2R1bGUgd2lsbCBvZnRlbiBuZWVkIHRoZSBzYW1lIERPTSBpbmZvLCBzb1xuICAgICAgLy8gd2Uga2VlcCBhIGNhY2hlIHdoaWNoIGlzIGNsZWFyZWQgb24gZWFjaCBwb3NpdGlvbiBjYWxsXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NhY2hlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NhY2hlW2tdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9jYWNoZVtrXSA9IGdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVba107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ICE9PSBfdGhpczMudGFyZ2V0Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMzLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmdldENsYXNzKCdlbmFibGVkJykpO1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zY3JvbGxQYXJlbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzNC5wb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgICB0ZXRoZXJzLmZvckVhY2goZnVuY3Rpb24gKHRldGhlciwgaSkge1xuICAgICAgICBpZiAodGV0aGVyID09PSBfdGhpczUpIHtcbiAgICAgICAgICB0ZXRoZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgZWxlbWVudHMgd2Ugd2VyZSB1c2luZyBmb3IgY29udmVuaWVuY2UgZnJvbSB0aGUgRE9NXG4gICAgICBpZiAodGV0aGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlVXRpbEVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQXR0YWNoQ2xhc3NlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUF0dGFjaENsYXNzZXMoZWxlbWVudEF0dGFjaCwgdGFyZ2V0QXR0YWNoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgZWxlbWVudEF0dGFjaCA9IGVsZW1lbnRBdHRhY2ggfHwgdGhpcy5hdHRhY2htZW50O1xuICAgICAgdGFyZ2V0QXR0YWNoID0gdGFyZ2V0QXR0YWNoIHx8IHRoaXMudGFyZ2V0QXR0YWNobWVudDtcbiAgICAgIHZhciBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ21pZGRsZScsICdjZW50ZXInXTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAvLyB1cGRhdGVBdHRhY2hDbGFzc2VzIGNhbiBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgaW4gYSBwb3NpdGlvbiBjYWxsLCBzb1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlcyBzdWNoIHRoYXQgd2hlbiB0aGUgbGFzdCBkZWZlciBnZXRzXG4gICAgICAgIC8vIHJhbiBpdCBkb2Vzbid0IGFkZCBhbnkgZXh0cmEgY2xhc3NlcyBmcm9tIHByZXZpb3VzIGNhbGxzLlxuICAgICAgICB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzLnNwbGljZSgwLCB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyA9IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFkZCA9IHRoaXMuX2FkZEF0dGFjaENsYXNzZXM7XG5cbiAgICAgIGlmIChlbGVtZW50QXR0YWNoLnRvcCkge1xuICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCdlbGVtZW50LWF0dGFjaGVkJykgKyAnLScgKyBlbGVtZW50QXR0YWNoLnRvcCk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudEF0dGFjaC5sZWZ0KSB7XG4gICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIGVsZW1lbnRBdHRhY2gubGVmdCk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0QXR0YWNoLnRvcCkge1xuICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSArICctJyArIHRhcmdldEF0dGFjaC50b3ApO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEF0dGFjaC5sZWZ0KSB7XG4gICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldC1hdHRhY2hlZCcpICsgJy0nICsgdGFyZ2V0QXR0YWNoLmxlZnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxsID0gW107XG4gICAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIGFsbC5wdXNoKF90aGlzNi5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpICsgJy0nICsgc2lkZSk7XG4gICAgICAgIGFsbC5wdXNoKF90aGlzNi5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykgKyAnLScgKyBzaWRlKTtcbiAgICAgIH0pO1xuXG4gICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBfdGhpczYuX2FkZEF0dGFjaENsYXNzZXMgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXM2LmVsZW1lbnQsIF90aGlzNi5fYWRkQXR0YWNoQ2xhc3NlcywgYWxsKTtcbiAgICAgICAgaWYgKCEoX3RoaXM2Lm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpczYudGFyZ2V0LCBfdGhpczYuX2FkZEF0dGFjaENsYXNzZXMsIGFsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgX3RoaXM2Ll9hZGRBdHRhY2hDbGFzc2VzO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgZmx1c2hDaGFuZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgLy8gZmx1c2hDaGFuZ2VzIGNvbW1pdHMgdGhlIGNoYW5nZXMgaW1tZWRpYXRlbHksIGxlYXZlIHRydWUgdW5sZXNzIHlvdSBhcmUgcG9zaXRpb25pbmcgbXVsdGlwbGVcbiAgICAgIC8vIHRldGhlcnMgKGluIHdoaWNoIGNhc2UgY2FsbCBUZXRoZXIuVXRpbHMuZmx1c2ggeW91cnNlbGYgd2hlbiB5b3UncmUgZG9uZSlcblxuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcblxuICAgICAgLy8gVHVybiAnYXV0bycgYXR0YWNobWVudHMgaW50byB0aGUgYXBwcm9wcmlhdGUgY29ybmVyIG9yIGVkZ2VcbiAgICAgIHZhciB0YXJnZXRBdHRhY2htZW50ID0gYXV0b1RvRml4ZWRBdHRhY2htZW50KHRoaXMudGFyZ2V0QXR0YWNobWVudCwgdGhpcy5hdHRhY2htZW50KTtcblxuICAgICAgdGhpcy51cGRhdGVBdHRhY2hDbGFzc2VzKHRoaXMuYXR0YWNobWVudCwgdGFyZ2V0QXR0YWNobWVudCk7XG5cbiAgICAgIHZhciBlbGVtZW50UG9zID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXM3LmVsZW1lbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciB3aWR0aCA9IGVsZW1lbnRQb3Mud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudFBvcy5oZWlnaHQ7XG5cbiAgICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDAgJiYgdHlwZW9mIHRoaXMubGFzdFNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBfbGFzdFNpemUgPSB0aGlzLmxhc3RTaXplO1xuXG4gICAgICAgIC8vIFdlIGNhY2hlIHRoZSBoZWlnaHQgYW5kIHdpZHRoIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gcG9zaXRpb24gZWxlbWVudHMgdGhhdCBhcmVcbiAgICAgICAgLy8gZ2V0dGluZyBoaWRkZW4uXG4gICAgICAgIHdpZHRoID0gX2xhc3RTaXplLndpZHRoO1xuICAgICAgICBoZWlnaHQgPSBfbGFzdFNpemUuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0U2l6ZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0UG9zID0gdGhpcy5jYWNoZSgndGFyZ2V0LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNy5nZXRUYXJnZXRCb3VuZHMoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHRhcmdldFNpemUgPSB0YXJnZXRQb3M7XG5cbiAgICAgIC8vIEdldCBhbiBhY3R1YWwgcHggb2Zmc2V0IGZyb20gdGhlIGF0dGFjaG1lbnRcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRUb1B4KGF0dGFjaG1lbnRUb09mZnNldCh0aGlzLmF0dGFjaG1lbnQpLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICB2YXIgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0VG9QeChhdHRhY2htZW50VG9PZmZzZXQodGFyZ2V0QXR0YWNobWVudCksIHRhcmdldFNpemUpO1xuXG4gICAgICB2YXIgbWFudWFsT2Zmc2V0ID0gb2Zmc2V0VG9QeCh0aGlzLm9mZnNldCwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgdmFyIG1hbnVhbFRhcmdldE9mZnNldCA9IG9mZnNldFRvUHgodGhpcy50YXJnZXRPZmZzZXQsIHRhcmdldFNpemUpO1xuXG4gICAgICAvLyBBZGQgdGhlIG1hbnVhbGx5IHByb3ZpZGVkIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gYWRkT2Zmc2V0KG9mZnNldCwgbWFudWFsT2Zmc2V0KTtcbiAgICAgIHRhcmdldE9mZnNldCA9IGFkZE9mZnNldCh0YXJnZXRPZmZzZXQsIG1hbnVhbFRhcmdldE9mZnNldCk7XG5cbiAgICAgIC8vIEl0J3Mgbm93IG91ciBnb2FsIHRvIG1ha2UgKGVsZW1lbnQgcG9zaXRpb24gKyBvZmZzZXQpID09ICh0YXJnZXQgcG9zaXRpb24gKyB0YXJnZXQgb2Zmc2V0KVxuICAgICAgdmFyIGxlZnQgPSB0YXJnZXRQb3MubGVmdCArIHRhcmdldE9mZnNldC5sZWZ0IC0gb2Zmc2V0LmxlZnQ7XG4gICAgICB2YXIgdG9wID0gdGFyZ2V0UG9zLnRvcCArIHRhcmdldE9mZnNldC50b3AgLSBvZmZzZXQudG9wO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRldGhlckJhc2UubW9kdWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgX21vZHVsZTIgPSBUZXRoZXJCYXNlLm1vZHVsZXNbaV07XG4gICAgICAgIHZhciByZXQgPSBfbW9kdWxlMi5wb3NpdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6IHRhcmdldEF0dGFjaG1lbnQsXG4gICAgICAgICAgdGFyZ2V0UG9zOiB0YXJnZXRQb3MsXG4gICAgICAgICAgZWxlbWVudFBvczogZWxlbWVudFBvcyxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCxcbiAgICAgICAgICBtYW51YWxPZmZzZXQ6IG1hbnVhbE9mZnNldCxcbiAgICAgICAgICBtYW51YWxUYXJnZXRPZmZzZXQ6IG1hbnVhbFRhcmdldE9mZnNldCxcbiAgICAgICAgICBzY3JvbGxiYXJTaXplOiBzY3JvbGxiYXJTaXplLFxuICAgICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuYXR0YWNobWVudFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcmV0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcCA9IHJldC50b3A7XG4gICAgICAgICAgbGVmdCA9IHJldC5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGRlc2NyaWJlIHRoZSBwb3NpdGlvbiB0aHJlZSBkaWZmZXJlbnQgd2F5cyB0byBnaXZlIHRoZSBvcHRpbWl6ZXJcbiAgICAgIC8vIGEgY2hhbmNlIHRvIGRlY2lkZSB0aGUgYmVzdCBwb3NzaWJsZSB3YXkgdG8gcG9zaXRpb24gdGhlIGVsZW1lbnRcbiAgICAgIC8vIHdpdGggdGhlIGZld2VzdCByZXBhaW50cy5cbiAgICAgIHZhciBuZXh0ID0ge1xuICAgICAgICAvLyBJdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYWdlIChhYnNvbHV0ZSBwb3NpdGlvbmluZyB3aGVuXG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIGEgY2hpbGQgb2YgdGhlIGJvZHkpXG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgKGZpeGVkIHBvc2l0aW9uaW5nKVxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIHRvcDogdG9wIC0gcGFnZVlPZmZzZXQsXG4gICAgICAgICAgYm90dG9tOiBwYWdlWU9mZnNldCAtIHRvcCAtIGhlaWdodCArIGlubmVySGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IGxlZnQgLSBwYWdlWE9mZnNldCxcbiAgICAgICAgICByaWdodDogcGFnZVhPZmZzZXQgLSBsZWZ0IC0gd2lkdGggKyBpbm5lcldpZHRoXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBkb2MgPSB0aGlzLnRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldztcblxuICAgICAgdmFyIHNjcm9sbGJhclNpemUgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAod2luLmlubmVySGVpZ2h0ID4gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgc2Nyb2xsYmFyU2l6ZSA9IHRoaXMuY2FjaGUoJ3Njcm9sbGJhci1zaXplJywgZ2V0U2Nyb2xsQmFyU2l6ZSk7XG4gICAgICAgIG5leHQudmlld3BvcnQuYm90dG9tIC09IHNjcm9sbGJhclNpemUuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAod2luLmlubmVyV2lkdGggPiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSB7XG4gICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xuICAgICAgICBuZXh0LnZpZXdwb3J0LnJpZ2h0IC09IHNjcm9sbGJhclNpemUud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChbJycsICdzdGF0aWMnXS5pbmRleE9mKGRvYy5ib2R5LnN0eWxlLnBvc2l0aW9uKSA9PT0gLTEgfHwgWycnLCAnc3RhdGljJ10uaW5kZXhPZihkb2MuYm9keS5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gQWJzb2x1dGUgcG9zaXRpb25pbmcgaW4gdGhlIGJvZHkgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGUgcGFnZSwgbm90IHRoZSAnaW5pdGlhbCBjb250YWluaW5nIGJsb2NrJ1xuICAgICAgICBuZXh0LnBhZ2UuYm90dG9tID0gZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0IC0gdG9wIC0gaGVpZ2h0O1xuICAgICAgICBuZXh0LnBhZ2UucmlnaHQgPSBkb2MuYm9keS5zY3JvbGxXaWR0aCAtIGxlZnQgLSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub3B0aW1pemF0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcHRpb25zLm9wdGltaXphdGlvbnMubW92ZUVsZW1lbnQgIT09IGZhbHNlICYmICEodHlwZW9mIHRoaXMudGFyZ2V0TW9kaWZpZXIgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBfdGhpczcuY2FjaGUoJ3RhcmdldC1vZmZzZXRwYXJlbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KF90aGlzNy50YXJnZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBvZmZzZXRQb3NpdGlvbiA9IF90aGlzNy5jYWNoZSgndGFyZ2V0LW9mZnNldHBhcmVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKG9mZnNldFBhcmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIG9mZnNldFBhcmVudFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnRTaXplID0gb2Zmc2V0UG9zaXRpb247XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0Qm9yZGVyID0ge307XG4gICAgICAgICAgWydUb3AnLCAnTGVmdCcsICdCb3R0b20nLCAnUmlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgICAgICBvZmZzZXRCb3JkZXJbc2lkZS50b0xvd2VyQ2FzZSgpXSA9IHBhcnNlRmxvYXQob2Zmc2V0UGFyZW50U3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb2Zmc2V0UG9zaXRpb24ucmlnaHQgPSBkb2MuYm9keS5zY3JvbGxXaWR0aCAtIG9mZnNldFBvc2l0aW9uLmxlZnQgLSBvZmZzZXRQYXJlbnRTaXplLndpZHRoICsgb2Zmc2V0Qm9yZGVyLnJpZ2h0O1xuICAgICAgICAgIG9mZnNldFBvc2l0aW9uLmJvdHRvbSA9IGRvYy5ib2R5LnNjcm9sbEhlaWdodCAtIG9mZnNldFBvc2l0aW9uLnRvcCAtIG9mZnNldFBhcmVudFNpemUuaGVpZ2h0ICsgb2Zmc2V0Qm9yZGVyLmJvdHRvbTtcblxuICAgICAgICAgIGlmIChuZXh0LnBhZ2UudG9wID49IG9mZnNldFBvc2l0aW9uLnRvcCArIG9mZnNldEJvcmRlci50b3AgJiYgbmV4dC5wYWdlLmJvdHRvbSA+PSBvZmZzZXRQb3NpdGlvbi5ib3R0b20pIHtcbiAgICAgICAgICAgIGlmIChuZXh0LnBhZ2UubGVmdCA+PSBvZmZzZXRQb3NpdGlvbi5sZWZ0ICsgb2Zmc2V0Qm9yZGVyLmxlZnQgJiYgbmV4dC5wYWdlLnJpZ2h0ID49IG9mZnNldFBvc2l0aW9uLnJpZ2h0KSB7XG4gICAgICAgICAgICAgIC8vIFdlJ3JlIHdpdGhpbiB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZSB0YXJnZXQncyBzY3JvbGwgcGFyZW50XG4gICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICAgIC8vIEl0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHRhcmdldCdzIG9mZnNldCBwYXJlbnQgKGFic29sdXRlIHBvc2l0aW9uaW5nIHdoZW5cbiAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgbW92ZWQgdG8gYmUgYSBjaGlsZCBvZiB0aGUgdGFyZ2V0J3Mgb2Zmc2V0IHBhcmVudCkuXG4gICAgICAgICAgICAgIG5leHQub2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgIHRvcDogbmV4dC5wYWdlLnRvcCAtIG9mZnNldFBvc2l0aW9uLnRvcCArIHNjcm9sbFRvcCAtIG9mZnNldEJvcmRlci50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogbmV4dC5wYWdlLmxlZnQgLSBvZmZzZXRQb3NpdGlvbi5sZWZ0ICsgc2Nyb2xsTGVmdCAtIG9mZnNldEJvcmRlci5sZWZ0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBjb3VsZCBhbHNvIHRyYXZlbCB1cCB0aGUgRE9NIGFuZCB0cnkgZWFjaCBjb250YWluaW5nIGNvbnRleHQsIHJhdGhlciB0aGFuIG9ubHlcbiAgICAgIC8vIGxvb2tpbmcgYXQgdGhlIGJvZHksIGJ1dCB3ZSdyZSBnb25uYSBnZXQgZGltaW5pc2hpbmcgcmV0dXJucy5cblxuICAgICAgdGhpcy5tb3ZlKG5leHQpO1xuXG4gICAgICB0aGlzLmhpc3RvcnkudW5zaGlmdChuZXh0KTtcblxuICAgICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPiAzKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsdXNoQ2hhbmdlcykge1xuICAgICAgICBmbHVzaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUSEUgSVNTVUVcbiAgfSwge1xuICAgIGtleTogJ21vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKHBvcykge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIGlmICghKHR5cGVvZiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNhbWUgPSB7fTtcblxuICAgICAgZm9yICh2YXIgdHlwZSBpbiBwb3MpIHtcbiAgICAgICAgc2FtZVt0eXBlXSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwb3NbdHlwZV0pIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oaXN0b3J5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmhpc3RvcnlbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50W3R5cGVdICE9PSAndW5kZWZpbmVkJyAmJiAhd2l0aGluKHBvaW50W3R5cGVdW2tleV0sIHBvc1t0eXBlXVtrZXldKSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHNhbWVbdHlwZV1ba2V5XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3MgPSB7IHRvcDogJycsIGxlZnQ6ICcnLCByaWdodDogJycsIGJvdHRvbTogJycgfTtcblxuICAgICAgdmFyIHRyYW5zY3JpYmUgPSBmdW5jdGlvbiB0cmFuc2NyaWJlKF9zYW1lLCBfcG9zKSB7XG4gICAgICAgIHZhciBoYXNPcHRpbWl6YXRpb25zID0gdHlwZW9mIF90aGlzOC5vcHRpb25zLm9wdGltaXphdGlvbnMgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB2YXIgZ3B1ID0gaGFzT3B0aW1pemF0aW9ucyA/IF90aGlzOC5vcHRpb25zLm9wdGltaXphdGlvbnMuZ3B1IDogbnVsbDtcbiAgICAgICAgaWYgKGdwdSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgeVBvcyA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgeFBvcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoX3NhbWUudG9wKSB7XG4gICAgICAgICAgICBjc3MudG9wID0gMDtcbiAgICAgICAgICAgIHlQb3MgPSBfcG9zLnRvcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzLmJvdHRvbSA9IDA7XG4gICAgICAgICAgICB5UG9zID0gLV9wb3MuYm90dG9tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfc2FtZS5sZWZ0KSB7XG4gICAgICAgICAgICBjc3MubGVmdCA9IDA7XG4gICAgICAgICAgICB4UG9zID0gX3Bvcy5sZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3MucmlnaHQgPSAwO1xuICAgICAgICAgICAgeFBvcyA9IC1fcG9zLnJpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgLy8gSHViU3BvdC90ZXRoZXIjMjA3XG4gICAgICAgICAgICB2YXIgcmV0aW5hID0gd2luZG93Lm1hdGNoTWVkaWEoJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDEuM2RwcHgpJykubWF0Y2hlcyB8fCB3aW5kb3cubWF0Y2hNZWRpYSgnb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuMyknKS5tYXRjaGVzO1xuICAgICAgICAgICAgaWYgKCFyZXRpbmEpIHtcbiAgICAgICAgICAgICAgeFBvcyA9IE1hdGgucm91bmQoeFBvcyk7XG4gICAgICAgICAgICAgIHlQb3MgPSBNYXRoLnJvdW5kKHlQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNzc1t0cmFuc2Zvcm1LZXldID0gJ3RyYW5zbGF0ZVgoJyArIHhQb3MgKyAncHgpIHRyYW5zbGF0ZVkoJyArIHlQb3MgKyAncHgpJztcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm1LZXkgIT09ICdtc1RyYW5zZm9ybScpIHtcbiAgICAgICAgICAgIC8vIFRoZSBaIHRyYW5zZm9ybSB3aWxsIGtlZXAgdGhpcyBpbiB0aGUgR1BVIChmYXN0ZXIsIGFuZCBwcmV2ZW50cyBhcnRpZmFjdHMpLFxuICAgICAgICAgICAgLy8gYnV0IElFOSBkb2Vzbid0IHN1cHBvcnQgM2QgdHJhbnNmb3JtcyBhbmQgd2lsbCBjaG9rZS5cbiAgICAgICAgICAgIGNzc1t0cmFuc2Zvcm1LZXldICs9IFwiIHRyYW5zbGF0ZVooMClcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKF9zYW1lLnRvcCkge1xuICAgICAgICAgICAgY3NzLnRvcCA9IF9wb3MudG9wICsgJ3B4JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzLmJvdHRvbSA9IF9wb3MuYm90dG9tICsgJ3B4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3NhbWUubGVmdCkge1xuICAgICAgICAgICAgY3NzLmxlZnQgPSBfcG9zLmxlZnQgKyAncHgnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3MucmlnaHQgPSBfcG9zLnJpZ2h0ICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtb3ZlZCA9IGZhbHNlO1xuICAgICAgaWYgKChzYW1lLnBhZ2UudG9wIHx8IHNhbWUucGFnZS5ib3R0b20pICYmIChzYW1lLnBhZ2UubGVmdCB8fCBzYW1lLnBhZ2UucmlnaHQpKSB7XG4gICAgICAgIGNzcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRyYW5zY3JpYmUoc2FtZS5wYWdlLCBwb3MucGFnZSk7XG4gICAgICB9IGVsc2UgaWYgKChzYW1lLnZpZXdwb3J0LnRvcCB8fCBzYW1lLnZpZXdwb3J0LmJvdHRvbSkgJiYgKHNhbWUudmlld3BvcnQubGVmdCB8fCBzYW1lLnZpZXdwb3J0LnJpZ2h0KSkge1xuICAgICAgICBjc3MucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICB0cmFuc2NyaWJlKHNhbWUudmlld3BvcnQsIHBvcy52aWV3cG9ydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzYW1lLm9mZnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgc2FtZS5vZmZzZXQudG9wICYmIHNhbWUub2Zmc2V0LmxlZnQpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBfdGhpczguY2FjaGUoJ3RhcmdldC1vZmZzZXRwYXJlbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KF90aGlzOC50YXJnZXQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGdldE9mZnNldFBhcmVudChfdGhpczguZWxlbWVudCkgIT09IG9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczguZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF90aGlzOC5lbGVtZW50KTtcbiAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50LmFwcGVuZENoaWxkKF90aGlzOC5lbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyYW5zY3JpYmUoc2FtZS5vZmZzZXQsIHBvcy5vZmZzZXQpO1xuICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNzcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRyYW5zY3JpYmUoeyB0b3A6IHRydWUsIGxlZnQ6IHRydWUgfSwgcG9zLnBhZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm9keUVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYm9keUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50SXNCb2R5ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgY3VycmVudE5vZGUudGFnTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSkucG9zaXRpb24gIT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgIG9mZnNldFBhcmVudElzQm9keSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb2Zmc2V0UGFyZW50SXNCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbnkgY3NzIGNoYW5nZSB3aWxsIHRyaWdnZXIgYSByZXBhaW50LCBzbyBsZXQncyBhdm9pZCBvbmUgaWYgbm90aGluZyBjaGFuZ2VkXG4gICAgICB2YXIgd3JpdGVDU1MgPSB7fTtcbiAgICAgIHZhciB3cml0ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIga2V5IGluIGNzcykge1xuICAgICAgICB2YXIgdmFsID0gY3NzW2tleV07XG4gICAgICAgIHZhciBlbFZhbCA9IHRoaXMuZWxlbWVudC5zdHlsZVtrZXldO1xuXG4gICAgICAgIGlmIChlbFZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgd3JpdGUgPSB0cnVlO1xuICAgICAgICAgIHdyaXRlQ1NTW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHdyaXRlKSB7XG4gICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBleHRlbmQoX3RoaXM4LmVsZW1lbnQuc3R5bGUsIHdyaXRlQ1NTKTtcbiAgICAgICAgICBfdGhpczgudHJpZ2dlcigncmVwb3NpdGlvbmVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXRoZXJDbGFzcztcbn0pKEV2ZW50ZWQpO1xuXG5UZXRoZXJDbGFzcy5tb2R1bGVzID0gW107XG5cblRldGhlckJhc2UucG9zaXRpb24gPSBwb3NpdGlvbjtcblxudmFyIFRldGhlciA9IGV4dGVuZChUZXRoZXJDbGFzcywgVGV0aGVyQmFzZSk7XG4vKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxudmFyIF9UZXRoZXJCYXNlJFV0aWxzID0gVGV0aGVyQmFzZS5VdGlscztcbnZhciBnZXRCb3VuZHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRCb3VuZHM7XG52YXIgZXh0ZW5kID0gX1RldGhlckJhc2UkVXRpbHMuZXh0ZW5kO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG5cbnZhciBCT1VORFNfRk9STUFUID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHRldGhlciwgdG8pIHtcbiAgaWYgKHRvID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgIHRvID0gdGV0aGVyLnNjcm9sbFBhcmVudHNbMF07XG4gIH0gZWxzZSBpZiAodG8gPT09ICd3aW5kb3cnKSB7XG4gICAgdG8gPSBbcGFnZVhPZmZzZXQsIHBhZ2VZT2Zmc2V0LCBpbm5lcldpZHRoICsgcGFnZVhPZmZzZXQsIGlubmVySGVpZ2h0ICsgcGFnZVlPZmZzZXRdO1xuICB9XG5cbiAgaWYgKHRvID09PSBkb2N1bWVudCkge1xuICAgIHRvID0gdG8uZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0by5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vZGUgPSB0bztcbiAgICAgIHZhciBzaXplID0gZ2V0Qm91bmRzKHRvKTtcbiAgICAgIHZhciBwb3MgPSBzaXplO1xuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0byk7XG5cbiAgICAgIHRvID0gW3Bvcy5sZWZ0LCBwb3MudG9wLCBzaXplLndpZHRoICsgcG9zLmxlZnQsIHNpemUuaGVpZ2h0ICsgcG9zLnRvcF07XG5cbiAgICAgIC8vIEFjY291bnQgYW55IHBhcmVudCBGcmFtZXMgc2Nyb2xsIG9mZnNldFxuICAgICAgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgdG9bMF0gKz0gd2luLnBhZ2VYT2Zmc2V0O1xuICAgICAgICB0b1sxXSArPSB3aW4ucGFnZVlPZmZzZXQ7XG4gICAgICAgIHRvWzJdICs9IHdpbi5wYWdlWE9mZnNldDtcbiAgICAgICAgdG9bM10gKz0gd2luLnBhZ2VZT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBCT1VORFNfRk9STUFULmZvckVhY2goZnVuY3Rpb24gKHNpZGUsIGkpIHtcbiAgICAgICAgc2lkZSA9IHNpZGVbMF0udG9VcHBlckNhc2UoKSArIHNpZGUuc3Vic3RyKDEpO1xuICAgICAgICBpZiAoc2lkZSA9PT0gJ1RvcCcgfHwgc2lkZSA9PT0gJ0xlZnQnKSB7XG4gICAgICAgICAgdG9baV0gKz0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9baV0gLT0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cblRldGhlckJhc2UubW9kdWxlcy5wdXNoKHtcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuICAgIHZhciB0YXJnZXRBdHRhY2htZW50ID0gX3JlZi50YXJnZXRBdHRhY2htZW50O1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY29uc3RyYWludHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBfY2FjaGUgPSB0aGlzLmNhY2hlKCdlbGVtZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXMuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gX2NhY2hlLmhlaWdodDtcbiAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XG5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgaXRlbSBnZXR0aW5nIGhpZGRlbiBhcyBhIHJlc3VsdCBvZiBvdXIgcG9zaXRpb25pbmcgd2l0aG91dCBnbGl0Y2hpbmdcbiAgICAgIC8vIHRoZSBjbGFzc2VzIGluIGFuZCBvdXRcbiAgICAgIHdpZHRoID0gX2xhc3RTaXplLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U2l6ZSA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0VGFyZ2V0Qm91bmRzKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0U2l6ZS5oZWlnaHQ7XG4gICAgdmFyIHRhcmdldFdpZHRoID0gdGFyZ2V0U2l6ZS53aWR0aDtcblxuICAgIHZhciBhbGxDbGFzc2VzID0gW3RoaXMuZ2V0Q2xhc3MoJ3Bpbm5lZCcpLCB0aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyldO1xuXG4gICAgdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciBvdXRPZkJvdW5kc0NsYXNzID0gY29uc3RyYWludC5vdXRPZkJvdW5kc0NsYXNzO1xuICAgICAgdmFyIHBpbm5lZENsYXNzID0gY29uc3RyYWludC5waW5uZWRDbGFzcztcblxuICAgICAgaWYgKG91dE9mQm91bmRzQ2xhc3MpIHtcbiAgICAgICAgYWxsQ2xhc3Nlcy5wdXNoKG91dE9mQm91bmRzQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHBpbm5lZENsYXNzKSB7XG4gICAgICAgIGFsbENsYXNzZXMucHVzaChwaW5uZWRDbGFzcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhbGxDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIGFsbENsYXNzZXMucHVzaChjbHMgKyAnLScgKyBzaWRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGFkZENsYXNzZXMgPSBbXTtcblxuICAgIHZhciB0QXR0YWNobWVudCA9IGV4dGVuZCh7fSwgdGFyZ2V0QXR0YWNobWVudCk7XG4gICAgdmFyIGVBdHRhY2htZW50ID0gZXh0ZW5kKHt9LCB0aGlzLmF0dGFjaG1lbnQpO1xuXG4gICAgdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciB0byA9IGNvbnN0cmFpbnQudG87XG4gICAgICB2YXIgYXR0YWNobWVudCA9IGNvbnN0cmFpbnQuYXR0YWNobWVudDtcbiAgICAgIHZhciBwaW4gPSBjb25zdHJhaW50LnBpbjtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhdHRhY2htZW50ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VBdHRhY2hYID0gdW5kZWZpbmVkLFxuICAgICAgICAgIGNoYW5nZUF0dGFjaFkgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoYXR0YWNobWVudC5pbmRleE9mKCcgJykgPj0gMCkge1xuICAgICAgICB2YXIgX2F0dGFjaG1lbnQkc3BsaXQgPSBhdHRhY2htZW50LnNwbGl0KCcgJyk7XG5cbiAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9hdHRhY2htZW50JHNwbGl0LCAyKTtcblxuICAgICAgICBjaGFuZ2VBdHRhY2hZID0gX2F0dGFjaG1lbnQkc3BsaXQyWzBdO1xuICAgICAgICBjaGFuZ2VBdHRhY2hYID0gX2F0dGFjaG1lbnQkc3BsaXQyWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlQXR0YWNoWCA9IGNoYW5nZUF0dGFjaFkgPSBhdHRhY2htZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRpbmdSZWN0KF90aGlzLCB0byk7XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hZID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgdG9wICs9IHRhcmdldEhlaWdodDtcbiAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgdEF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRvcCAtPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFkgPT09ICd0b2dldGhlcicpIHtcbiAgICAgICAgaWYgKHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJyAmJiB0b3AgPCBib3VuZHNbMV0pIHtcbiAgICAgICAgICAgIHRvcCArPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcblxuICAgICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAndG9wJyAmJiB0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgdG9wIC0gKGhlaWdodCAtIHRhcmdldEhlaWdodCkgPj0gYm91bmRzWzFdKSB7XG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG5cbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcgJiYgdG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XG4gICAgICAgICAgICB0b3AgLT0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG5cbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScgJiYgdG9wIDwgYm91bmRzWzFdICYmIHRvcCArIChoZWlnaHQgKiAyIC0gdGFyZ2V0SGVpZ2h0KSA8PSBib3VuZHNbM10pIHtcbiAgICAgICAgICAgIHRvcCArPSBoZWlnaHQgLSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcblxuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRBdHRhY2htZW50LnRvcCA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RvZ2V0aGVyJykge1xuICAgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuXG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCAtPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodEF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiBlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFkgPT09ICdlbGVtZW50JyB8fCBjaGFuZ2VBdHRhY2hZID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFggPT09ICdlbGVtZW50JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0pIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgbGVmdCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0pIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBpbiA9IHBpbi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBwLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHBpbiA9PT0gdHJ1ZSkge1xuICAgICAgICBwaW4gPSBbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuICAgICAgfVxuXG4gICAgICBwaW4gPSBwaW4gfHwgW107XG5cbiAgICAgIHZhciBwaW5uZWQgPSBbXTtcbiAgICAgIHZhciBvb2IgPSBbXTtcblxuICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSkge1xuICAgICAgICBpZiAocGluLmluZGV4T2YoJ3RvcCcpID49IDApIHtcbiAgICAgICAgICB0b3AgPSBib3VuZHNbMV07XG4gICAgICAgICAgcGlubmVkLnB1c2goJ3RvcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCd0b3AnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZignYm90dG9tJykgPj0gMCkge1xuICAgICAgICAgIHRvcCA9IGJvdW5kc1szXSAtIGhlaWdodDtcbiAgICAgICAgICBwaW5uZWQucHVzaCgnYm90dG9tJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb29iLnB1c2goJ2JvdHRvbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZignbGVmdCcpID49IDApIHtcbiAgICAgICAgICBsZWZ0ID0gYm91bmRzWzBdO1xuICAgICAgICAgIHBpbm5lZC5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb29iLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZigncmlnaHQnKSA+PSAwKSB7XG4gICAgICAgICAgbGVmdCA9IGJvdW5kc1syXSAtIHdpZHRoO1xuICAgICAgICAgIHBpbm5lZC5wdXNoKCdyaWdodCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5uZWQubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHBpbm5lZENsYXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBpbm5lZENsYXNzID0gX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGlubmVkQ2xhc3MgPSBfdGhpcy5nZXRDbGFzcygncGlubmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzKTtcbiAgICAgICAgICBwaW5uZWQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvb2IubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9vYkNsYXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5vdXRPZkJvdW5kc0NsYXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb29iQ2xhc3MgPSBfdGhpcy5vcHRpb25zLm91dE9mQm91bmRzQ2xhc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9vYkNsYXNzID0gX3RoaXMuZ2V0Q2xhc3MoJ291dC1vZi1ib3VuZHMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MpO1xuICAgICAgICAgIG9vYi5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MgKyAnLScgKyBzaWRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbm5lZC5pbmRleE9mKCdsZWZ0JykgPj0gMCB8fCBwaW5uZWQuaW5kZXhPZigncmlnaHQnKSA+PSAwKSB7XG4gICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSB0QXR0YWNobWVudC5sZWZ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGlubmVkLmluZGV4T2YoJ3RvcCcpID49IDAgfHwgcGlubmVkLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcbiAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gdEF0dGFjaG1lbnQudG9wID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0QXR0YWNobWVudC50b3AgIT09IHRhcmdldEF0dGFjaG1lbnQudG9wIHx8IHRBdHRhY2htZW50LmxlZnQgIT09IHRhcmdldEF0dGFjaG1lbnQubGVmdCB8fCBlQXR0YWNobWVudC50b3AgIT09IF90aGlzLmF0dGFjaG1lbnQudG9wIHx8IGVBdHRhY2htZW50LmxlZnQgIT09IF90aGlzLmF0dGFjaG1lbnQubGVmdCkge1xuICAgICAgICBfdGhpcy51cGRhdGVBdHRhY2hDbGFzc2VzKGVBdHRhY2htZW50LCB0QXR0YWNobWVudCk7XG4gICAgICAgIF90aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHtcbiAgICAgICAgICBhdHRhY2htZW50OiBlQXR0YWNobWVudCxcbiAgICAgICAgICB0YXJnZXRBdHRhY2htZW50OiB0QXR0YWNobWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghKF90aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMuZWxlbWVudCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuICB9XG59KTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfVGV0aGVyQmFzZSRVdGlscyA9IFRldGhlckJhc2UuVXRpbHM7XG52YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG5cblRldGhlckJhc2UubW9kdWxlcy5wdXNoKHtcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgdmFyIF9jYWNoZSA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpcy5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHZhciBoZWlnaHQgPSBfY2FjaGUuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IF9jYWNoZS53aWR0aDtcblxuICAgIHZhciB0YXJnZXRQb3MgPSB0aGlzLmdldFRhcmdldEJvdW5kcygpO1xuXG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG5cbiAgICB2YXIgYWJ1dHRlZCA9IFtdO1xuICAgIGlmICh0b3AgPD0gdGFyZ2V0UG9zLmJvdHRvbSAmJiBib3R0b20gPj0gdGFyZ2V0UG9zLnRvcCkge1xuICAgICAgWydsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcbiAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IGxlZnQgfHwgdGFyZ2V0UG9zU2lkZSA9PT0gcmlnaHQpIHtcbiAgICAgICAgICBhYnV0dGVkLnB1c2goc2lkZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsZWZ0IDw9IHRhcmdldFBvcy5yaWdodCAmJiByaWdodCA+PSB0YXJnZXRQb3MubGVmdCkge1xuICAgICAgWyd0b3AnLCAnYm90dG9tJ10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcbiAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IHRvcCB8fCB0YXJnZXRQb3NTaWRlID09PSBib3R0b20pIHtcbiAgICAgICAgICBhYnV0dGVkLnB1c2goc2lkZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhbGxDbGFzc2VzID0gW107XG4gICAgdmFyIGFkZENsYXNzZXMgPSBbXTtcblxuICAgIHZhciBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG4gICAgYWxsQ2xhc3Nlcy5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSk7XG4gICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgYWxsQ2xhc3Nlcy5wdXNoKF90aGlzLmdldENsYXNzKCdhYnV0dGVkJykgKyAnLScgKyBzaWRlKTtcbiAgICB9KTtcblxuICAgIGlmIChhYnV0dGVkLmxlbmd0aCkge1xuICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSk7XG4gICAgfVxuXG4gICAgYWJ1dHRlZC5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICBhZGRDbGFzc2VzLnB1c2goX3RoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSArICctJyArIHNpZGUpO1xuICAgIH0pO1xuXG4gICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCEoX3RoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcbiAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy50YXJnZXQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xuICAgICAgfVxuICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59KTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xuXG5UZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihfcmVmKSB7XG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hpZnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hpZnQgPSB0aGlzLm9wdGlvbnMuc2hpZnQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2hpZnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNoaWZ0ID0gdGhpcy5vcHRpb25zLnNoaWZ0LmNhbGwodGhpcywgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9KTtcbiAgICB9XG5cbiAgICB2YXIgc2hpZnRUb3AgPSB1bmRlZmluZWQsXG4gICAgICAgIHNoaWZ0TGVmdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHNoaWZ0ID09PSAnc3RyaW5nJykge1xuICAgICAgc2hpZnQgPSBzaGlmdC5zcGxpdCgnICcpO1xuICAgICAgc2hpZnRbMV0gPSBzaGlmdFsxXSB8fCBzaGlmdFswXTtcblxuICAgICAgdmFyIF9zaGlmdCA9IHNoaWZ0O1xuXG4gICAgICB2YXIgX3NoaWZ0MiA9IF9zbGljZWRUb0FycmF5KF9zaGlmdCwgMik7XG5cbiAgICAgIHNoaWZ0VG9wID0gX3NoaWZ0MlswXTtcbiAgICAgIHNoaWZ0TGVmdCA9IF9zaGlmdDJbMV07XG5cbiAgICAgIHNoaWZ0VG9wID0gcGFyc2VGbG9hdChzaGlmdFRvcCwgMTApO1xuICAgICAgc2hpZnRMZWZ0ID0gcGFyc2VGbG9hdChzaGlmdExlZnQsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hpZnRUb3AgPSBzaGlmdC50b3A7XG4gICAgICBzaGlmdExlZnQgPSBzaGlmdC5sZWZ0O1xuICAgIH1cblxuICAgIHRvcCArPSBzaGlmdFRvcDtcbiAgICBsZWZ0ICs9IHNoaWZ0TGVmdDtcblxuICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gIH1cbn0pO1xucmV0dXJuIFRldGhlcjtcblxufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9fdGV0aGVyQDEuNC4wQHRldGhlci9kaXN0L2pzL3RldGhlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 51:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * Vue.js v2.3.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n\n\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString(val) {\n  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res;\n}\n\n/**\n * Perform no operation.\n */\nfunction noop() {}\n\n/**\n * Always return false.\n */\nvar no = function no() {\n  return false;\n};\n\n/**\n * Return same value\n */\nvar identity = function identity(_) {\n  return _;\n};\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys(modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(',');\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b);\n    } catch (e) {\n      // possible circular reference\n      return a === b;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\n\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n      obj = obj[segments[i]];\n    }\n    return obj;\n  };\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = null; // work around flow check\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function classify(str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function warn(msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  tip = function tip(msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = function formatComponentName(vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var repeat = function repeat(str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) {\n        res += str;\n      }\n      if (n > 1) {\n        str += str;\n      }\n      n >>= 1;\n    }\n    return res;\n  };\n\n  var generateComponentTrace = function generateComponentTrace(vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n        return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n      }).join('\\n');\n    } else {\n      return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n    }\n  };\n}\n\n/*  */\n\nfunction handleError(err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function isServerRendering() {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer;\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function logError(err) {\n      console.error(err);\n    };\n    timerFunc = function timerFunc() {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function timerFunc() {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function timerFunc() {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      });\n    }\n  };\n}();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(_target) {\n  if (Dep.target) {\n    targetStack.push(Dep.target);\n  }\n  Dep.target = _target;\n}\n\nfunction popTarget() {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break;\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) {\n      ob.observeArray(inserted);\n    }\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, asRootData) {\n  if (!isObject(value)) {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1(obj, key, val, customSetter) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set(target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del(target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n  if (!hasOwn(target, key)) {\n    return;\n  }\n  delete target[key];\n  if (!ob) {\n    return;\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n    return defaultStrat(parent, child);\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(childVal.call(this), parentVal.call(this));\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook(parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal ? extend(res, childVal) : res;\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\nstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret;\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options) {\n  var props = options.props;\n  if (!props) {\n    return;\n  }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\n/*  */\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value;\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n  if (value == null && !prop.required) {\n    return;\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n    return;\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isType(type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type);\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true;\n    }\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function mark(tag) {\n      return perf.mark(tag);\n    };\n    measure = function measure(name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function warnNonPresent(target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + \"referenced during render. Make sure to declare reactive data \" + \"properties in the data option.\", target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed;\n    }\n  };\n\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function createEmptyVNode() {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned;\n}\n\nfunction cloneVNodes(vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res;\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns) {\n  function invoker() {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments);\n    }\n  }\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, vm) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return;\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n  return children;\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res;\n}\n\n/*  */\n\nfunction ensureCtor(comp, base) {\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor, context) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function forceRender() {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(process.env.NODE_ENV !== 'production' ? \"timeout (\" + res.timeout + \"ms)\" : null);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c;\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm;\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm;\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm;\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n  var slots = {};\n  if (!children) {\n    return slots;\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {\n      var name = child.data.slot;\n      var slot = slots[name] || (slots[name] = []);\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment || node.text === ' ';\n}\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nres) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle(vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n      , vm.$options._parentElm, vm.$options._refElm);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function updateComponent() {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure(name + \" render\", startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure(name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function updateComponent() {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  parentVnode.data.scopedSlots || // has new scoped slots\n  vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, hook + \" hook\");\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue() {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks(queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher(vm, expOrFn, cb, options) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n  this.value = this.lazy ? undefined : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value;\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown() {\n  var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse(val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if (!isA && !isObject(val) || !Object.isExtensible(val)) {\n    return;\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return;\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n  if (opts.watch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function loop(key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) {\n    loop(key);\n  }observerState.shouldConvert = true;\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\"The data property \\\"\" + keys[i] + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData(data, vm) {\n  try {\n    return data.call(vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed(vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production') {\n      if (getter === undefined) {\n        warn(\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\", vm);\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    }\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\"method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data;\n  };\n  var propsDef = {};\n  propsDef.get = function () {\n    return this._props;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n\n/*  */\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n        source = source.$parent;\n      }\n    }\n    return result;\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent(Ctor, propsData, data, context, children) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function h(a, b, c, d) {\n    return createElement(_context, a, b, c, d, true);\n  };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function slots() {\n      return resolveSlots(children, context);\n    }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating, parentElm, refElm) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n    return;\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return;\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent, // activeInstance in lifecycle state\nparentElm, refElm) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options);\n}\n\nfunction mergeHooks(data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1(one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  };\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) {\n      applyNS(vnode, ns);\n    }\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    ret._isVList = true;\n  }\n  return ret;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInAlias) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1;\n  } else {\n    return keyCodes !== eventKeyCode;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  };\n}\n\nfunction renderMixin(Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + vm._uid;\n      endTag = \"vue-perf-end:\" + vm._uid;\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(vm._name + \" init\", startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified;\n}\n\nfunction dedupe(latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res;\n  } else {\n    return latest;\n  }\n}\n\nfunction Vue$3(options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this;\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this;\n  };\n}\n\n/*  */\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n\n/*  */\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n      }\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction pruneCache(cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created() {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed() {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include(val) {\n      pruneCache(this.cache, this._vnode, function (name) {\n        return matches(val, name);\n      });\n    },\n    exclude: function exclude(val) {\n      pruneCache(this.cache, this._vnode, function (name) {\n        return !matches(val, name);\n      });\n    }\n  },\n\n  render: function render() {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {\n        return vnode;\n      }\n      var key = vnode.key == null\n      // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode;\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () {\n    return config;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext;\n  }\n});\n\nVue$3.version = '2.3.4';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function mustUseProp(tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function isXlink(name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function getXlinkProp(name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function isFalsyAttrValue(val) {\n  return val == null || val === false;\n};\n\n/*  */\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction genClassFromData(data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (isUndef(value)) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1);\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) {\n        res += key + ' ';\n      }\n    }\n    return res.slice(0, -1);\n  }\n  /* istanbul ignore next */\n  return res;\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isPreTag = function isPreTag(tag) {\n  return tag === 'pre';\n};\n\nvar isReservedTag = function isReservedTag(tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n  if (isReservedTag(tag)) {\n    return false;\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n    return selected;\n  } else {\n    return el;\n  }\n}\n\n/*  */\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm;\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute(node, key, val) {\n  node.setAttribute(key, val);\n}\n\nvar nodeOps = Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope(vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate(elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false;\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true /* hydrating */);\n      }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break;\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false;\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(vnode, insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function callInsert() {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res;\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters(exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) {\n        inSingle = false;\n      }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) {\n        inDouble = false;\n      }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) {\n        inTemplateString = false;\n      }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) {\n        inRegex = false;\n      }\n    } else if (c === 0x7C && // pipe\n    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x60:\n          inTemplateString = true;break; // `\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n      if (c === 0x2f) {\n        // /\n        var j = i - 1;\n        var p = void 0;\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') {\n            break;\n          }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter() {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression;\n}\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n  }\n}\n\n/*  */\n\nfunction baseWarn(msg) {\n  console.error(\"[Vue compiler]: \" + msg);\n}\n\nfunction pluckModuleFunction(modules, key) {\n  return modules ? modules.map(function (m) {\n    return m[key];\n  }).filter(function (_) {\n    return _;\n  }) : [];\n}\n\nfunction addProp(el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr(el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective(el, name, rawName, value, arg, modifiers) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler(el, name, value, modifiers, important, warn) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {\n    warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr(el, name, getStatic) {\n  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue);\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue);\n    }\n  }\n}\n\nfunction getAndRemoveAttr(el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n  return val;\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel(el, value, modifiers) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: \"(\" + value + \")\",\n    expression: \"\\\"\" + value + \"\\\"\",\n    callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode(value, assignment) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return value + \"=\" + assignment;\n  } else {\n    return \"var $$exp = \" + modelRs.exp + \", $$idx = \" + modelRs.idx + \";\" + \"if (!Array.isArray($$exp)){\" + value + \"=\" + assignment + \"}\" + \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\";\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel(val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    };\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  };\n}\n\nfunction next() {\n  return str.charCodeAt(++index$1);\n}\n\nfunction eof() {\n  return index$1 >= len;\n}\n\nfunction isStringStart(chr) {\n  return chr === 0x22 || chr === 0x27;\n}\n\nfunction parseBracket(chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue;\n    }\n    if (chr === 0x5B) {\n      inBracket++;\n    }\n    if (chr === 0x5D) {\n      inBracket--;\n    }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break;\n    }\n  }\n}\n\nfunction parseString(chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model(el, dir, _warn) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" + \"v-model does not support dynamic input types. Use v-if branches instead.\");\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false;\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n  }\n\n  // ensure runtime directive metadata\n  return true;\n}\n\nfunction genCheckboxModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n}\n\nfunction genRadioModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n  addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel(el, value, modifiers) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', \"(\" + value + \")\");\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents(on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1(event, _handler, once$$1, capture, passive) {\n  if (once$$1) {\n    var oldHandler = _handler;\n    var _target = target$1; // save current target element in closure\n    _handler = function handler(ev) {\n      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, _handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n}\n\nfunction remove$2(event, handler, capture, _target) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n      if (cur === oldProps[key]) {\n        continue;\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, vnode, checkVal) {\n  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));\n}\n\nfunction isDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal;\n}\n\nfunction isInputChanged(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal);\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim();\n  }\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n  return bindingStyle;\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function setProp(el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && prop in testEl.style) {\n    return prop;\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) {\n    return cb();\n  }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function end() {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function onEnd(e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n}\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1)) * 1000;\n}\n\n/*  */\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return;\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm();\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function cb() {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple ? binding.value.some(function (v) {\n        return hasNoMatchingOption(v, el.options);\n      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return;\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) {\n      return;\n    }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return;\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) {\n      return c.tag;\n    });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return;\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) {\n      return d.name === 'show';\n    })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function performLeave() {\n          delayedLeave();\n        };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n\n  beforeUpdate: function beforeUpdate() {\n    // force removing pass\n    this.__patch__(this._vnode, this.kept, false, // hydrating\n    true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      if (this._hasMove != null) {\n        return this._hasMove;\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode(content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0;\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n/*  */\n\nvar decoder;\n\nfunction decode(html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent;\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n// attr value double quotes\n/\"([^\"]*)\"+/.source,\n// attr value, single quotes\n/'([^']*)'+/.source,\n// attr value, no quotes\n/([^\\s\"'=<>`]+)/.source];\nvar attribute = new RegExp('^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?');\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) {\n    return decodingMap[match];\n  });\n}\n\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue;\n        }\n      }\n\n      var text = void 0,\n          rest$1 = void 0,\n          next = void 0;\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return '';\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n      }\n      break;\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') {\n          delete args[3];\n        }\n        if (args[4] === '') {\n          delete args[4];\n        }\n        if (args[5] === '') {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, options.shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\n\nfunction parseText(text, delimiters) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while (match = tagRE.exec(text)) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push(\"_s(\" + exp + \")\");\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+');\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse(template, options) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce(msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre(element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start(tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints(el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) {\n          // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end() {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars(text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce('Component template requires a root element, rather than just text.');\n          } else if (text = text.trim()) {\n            warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n          }\n        }\n        return;\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n        return;\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n      // only preserve whitespace if its not right after a starting tag\n      : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root;\n}\n\nfunction processPre(el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs(el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey(el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef(el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor(el) {\n  var exp;\n  if (exp = getAndRemoveAttr(el, 'v-for')) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\"Invalid v-for expression: \" + exp);\n      return;\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf(el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions(el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n  }\n}\n\nfunction findPrevElement(children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i];\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition(el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce(el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot(el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent(el) {\n  var binding;\n  if (binding = getBindingAttr(el, 'is')) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs(el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) {\n        // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') {\n              name = 'innerHTML';\n            }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) {\n        // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else {\n        // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor(el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction parseModifiers(name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) {\n      ret[m.slice(1)] = true;\n    });\n    return ret;\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map;\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag(el) {\n  return el.tag === 'script' || el.tag === 'style';\n}\n\nfunction isForbiddenTag(el) {\n  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug(attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res;\n}\n\nfunction checkForAliasModel(el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize(root, options) {\n  if (!root) {\n    return;\n  }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1(keys) {\n  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n}\n\nfunction markStatic$1(node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n      return;\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots(node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n      node.staticRoot = true;\n      return;\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks(conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic(node) {\n  if (node.type === 2) {\n    // expression\n    return false;\n  }\n  if (node.type === 3) {\n    // text\n    return true;\n  }\n  return !!(node.pre || !node.hasBindings && // no dynamic bindings\n  !node.if && !node.for && // not v-if or v-for or v-else\n  !isBuiltInTag(node.tag) && // not a built-in\n  isPlatformReservedTag(node.tag) && // not a component\n  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n}\n\nfunction isDirectChildOfTemplateFor(node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false;\n    }\n    if (node.for) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function genGuard(condition) {\n  return \"if(\" + condition + \")return null;\";\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers(events, isNative, warn) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (process.env.NODE_ENV !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {\n      warn(\"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" + \"do not actually fire \\\"click\\\" events.\");\n    }\n    res += \"\\\"\" + name + \"\\\":\" + genHandler(name, handler) + \",\";\n  }\n  return res.slice(0, -1) + '}';\n}\n\nfunction genHandler(name, handler) {\n  if (!handler) {\n    return 'function(){}';\n  }\n\n  if (Array.isArray(handler)) {\n    return \"[\" + handler.map(function (handler) {\n      return genHandler(name, handler);\n    }).join(',') + \"]\";\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression ? handler.value : \"function($event){\" + handler.value + \"}\"; // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n    return \"function($event){\" + code + handlerCode + \"}\";\n  }\n}\n\nfunction genKeyFilter(keys) {\n  return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n}\n\nfunction genFilterCode(key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return \"$event.keyCode!==\" + keyVal;\n  }\n  var alias = keyCodes[key];\n  return \"_k($event.keyCode,\" + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + \")\";\n}\n\n/*  */\n\nfunction bind$1(el, dir) {\n  el.wrapData = function (code) {\n    return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\";\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate(ast, options) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: \"with(this){return \" + code + \"}\",\n    staticRenderFns: currentStaticRenderFns\n  };\n}\n\nfunction genElement(el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el);\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el);\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el);\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el);\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0';\n  } else if (el.tag === 'slot') {\n    return genSlot(el);\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code;\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic(el) {\n  el.staticProcessed = true;\n  staticRenderFns.push(\"with(this){return \" + genElement(el) + \"}\");\n  return \"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n}\n\n// v-once\nfunction genOnce(el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el);\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break;\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$3(\"v-once can only be used inside v-for that is keyed. \");\n      return genElement(el);\n    }\n    return \"_o(\" + genElement(el) + \",\" + onceCount++ + (key ? \",\" + key : \"\") + \")\";\n  } else {\n    return genStatic(el);\n  }\n}\n\nfunction genIf(el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice());\n}\n\nfunction genIfConditions(conditions) {\n  if (!conditions.length) {\n    return '_e()';\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions);\n  } else {\n    return \"\" + genTernaryExp(condition.block);\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp(el) {\n    return el.once ? genOnce(el) : genElement(el);\n  }\n}\n\nfunction genFor(el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n  if (process.env.NODE_ENV !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n    warn$3(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genElement(el) + '})';\n}\n\nfunction genData(el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) {\n    data += dirs + ',';\n  }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + el.key + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + el.ref + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + el.tag + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + genProps(el.props) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += genHandlers(el.events, false, warn$3) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += genHandlers(el.nativeEvents, true, warn$3) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + el.slotTarget + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += genScopedSlots(el.scopedSlots) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data;\n}\n\nfunction genDirectives(el) {\n  var dirs = el.directives;\n  if (!dirs) {\n    return;\n  }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']';\n  }\n}\n\nfunction genInlineTemplate(el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n      return \"function(){\" + code + \"}\";\n    }).join(',') + \"]}\";\n  }\n}\n\nfunction genScopedSlots(slots) {\n  return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n    return genScopedSlot(key, slots[key]);\n  }).join(',') + \"])\";\n}\n\nfunction genScopedSlot(key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el);\n  }\n  return \"{key:\" + key + \",fn:function(\" + String(el.attrsMap.scope) + \"){\" + \"return \" + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + \"}}\";\n}\n\nfunction genForScopedSlot(key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el) + '})';\n}\n\nfunction genChildren(el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n      return genElement(el$1);\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return \"[\" + children.map(genNode).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType(children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue;\n    }\n    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return needsNormalization(c.block);\n    })) {\n      res = 2;\n      break;\n    }\n    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return maybeComponent(c.block);\n    })) {\n      res = 1;\n    }\n  }\n  return res;\n}\n\nfunction needsNormalization(el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\n\nfunction maybeComponent(el) {\n  return !isPlatformReservedTag$1(el.tag);\n}\n\nfunction genNode(node) {\n  if (node.type === 1) {\n    return genElement(node);\n  } else {\n    return genText(node);\n  }\n}\n\nfunction genText(text) {\n  return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n  : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n}\n\nfunction genSlot(el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n  var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n    return camelize(a.name) + \":\" + a.value;\n  }).join(',') + \"}\";\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')';\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent(componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return \"_c(\" + componentName + \",\" + genData(el) + (children ? \",\" + children : '') + \")\";\n}\n\nfunction genProps(props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n  }\n  return res.slice(0, -1);\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines(text) {\n  return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors(ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors;\n}\n\nfunction checkNode(node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          } else {\n            checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent(exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor(node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier(ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n  }\n}\n\nfunction checkExpression(exp, text, errors) {\n  try {\n    new Function(\"return \" + exp);\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n    } else {\n      errors.push(\"invalid expression: \" + text.trim());\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile(template, options) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  };\n}\n\nfunction makeFunction(code, errors) {\n  try {\n    return new Function(code);\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop;\n  }\n}\n\nfunction createCompiler(baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile(template, options) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled;\n  }\n\n  function compileToFunctions(template, options, vm) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters ? String(options.delimiters) + template : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key];\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n          return \"- \" + e;\n        }).join('\\n') + '\\n', vm);\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) {\n          return tip(msg, vm);\n        });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n          var err = ref.err;\n          var code = ref.code;\n\n          return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n        }).join('\\n'), vm);\n      }\n    }\n\n    return functionCompileCache[key] = res;\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  };\n}\n\n/*  */\n\nfunction transformNode(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1(el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + el.staticClass + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + el.classBinding + \",\";\n  }\n  return data;\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2(el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + el.staticStyle + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + el.styleBinding + \"),\";\n  }\n  return data;\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [klass$1, style$1];\n\n/*  */\n\nfunction text(el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n  }\n}\n\n/*  */\n\nfunction html(el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML;\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n    return this;\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\"Template element not found or is empty: \" + options.template, this);\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this;\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(this._name + \" compile\", 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating);\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66), __webpack_require__(83)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L192dWVAMi4zLjRAdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcz9mOTFjIl0sIm5hbWVzIjpbImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiY2FsbCIsImlzUmVnRXhwIiwidmFsIiwiSlNPTiIsInN0cmluZ2lmeSIsIlN0cmluZyIsInRvTnVtYmVyIiwibiIsInBhcnNlRmxvYXQiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0Iiwic2xpY2UiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsImJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJBcnJheSIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImIiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJlIiwibG9vc2VJbmRleE9mIiwib25jZSIsImNhbGxlZCIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJjb25maWciLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwid2FybiIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsIm1zZyIsInZtIiwiZXJyb3IiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm5hbWUiLCJvcHRpb25zIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsIm1hdGNoIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwiY29uc3RydWN0b3IiLCJwdXNoIiwiaXNBcnJheSIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImluQnJvd3NlciIsImhhc1Byb3RvIiwid2luZG93IiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsImdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImdsb2JhbCIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJuZXh0VGljayIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJ0aW1lckZ1bmMiLCJuZXh0VGlja0hhbmRsZXIiLCJjb3BpZXMiLCJQcm9taXNlIiwicCIsInJlc29sdmUiLCJsb2dFcnJvciIsInRoZW4iLCJjYXRjaCIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJkYXRhIiwicXVldWVOZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJyZWplY3QiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmd1bWVudHMkMSIsImFyZ3MiLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJNYXRoIiwibWF4IiwiZGVsIiwic3RyYXRzIiwiZWwiLCJwcm9wc0RhdGEiLCJwYXJlbnQiLCJjaGlsZCIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJ0eXBlIiwid2F0Y2giLCJwcm9wcyIsIm1ldGhvZHMiLCJjb21wdXRlZCIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJsb3dlciIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwibGVuIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY2FwdHVyZSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwiY3VyIiwib2xkIiwiZXZlbnQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJmYWN0b3J5IiwiYmFzZUN0b3IiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsImNvbnRleHRzIiwic3luYyIsImZvcmNlUmVuZGVyIiwiJGZvcmNlVXBkYXRlIiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsImxpc3RlbmVycyIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb25jZSIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiVnVlIiwiaG9va1JFIiwidGhpcyQxIiwiaSQxIiwiY2JzIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwiZGVmYXVsdFNsb3QiLCJzbG90IiwiZXZlcnkiLCJpc1doaXRlc3BhY2UiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJhY3RpdmVJbnN0YW5jZSIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiR2bm9kZSIsIiRkZXN0cm95IiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwidGVtcGxhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJfcGFyZW50Vm5vZGUiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVIb29rcyIsImVtaXQiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsInRyYXZlcnNlIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2Vlbk9iamVjdHMiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiZGVwSWQiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJwcm94eSIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwiaXNSZXNlcnZlZFByb3AiLCJyZWYiLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJsb29wIiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiJGRhdGEiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNvbXB1dGVkR2V0dGVyIiwiaGFuZGxlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJwcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwiaW5qZWN0IiwicHJvdmlkZUtleSIsInNvdXJjZSIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwiX2NvbnRleHQiLCJoIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJpbmplY3Rpb25zIiwiZnVuY3Rpb25hbE9wdGlvbnMiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsInBhcmVudEVsbSIsInJlZkVsbSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCIkbW91bnQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwib2xkVm5vZGUiLCJpbnNlcnQiLCJkZXN0cm95IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiX2Jhc2UiLCJjaWQiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsIm1lcmdlSG9va3MiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsInN0YXRpY1JlbmRlckZucyIsImZyb21QYXJlbnQiLCJvdXJzIiwibWVyZ2VIb29rJDEiLCJvbmUiLCJ0d28iLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiZG9tUHJvcHMiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZCIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiZ2V0Q29tcG9uZW50TmFtZSIsIm1hdGNoZXMiLCJwYXR0ZXJuIiwicHJ1bmVDYWNoZSIsImN1cnJlbnQiLCJmaWx0ZXIiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlZmluZVJlYWN0aXZlIiwiZGVsZXRlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJnZW5DbGFzc0Zyb21EYXRhIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImhvb2tzIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiYmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImh5ZHJhdGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsIm1vZGVsUnMiLCJwYXJzZU1vZGVsIiwiaWR4IiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0Iiwic3Vic3RyaW5nIiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJkeW5hbWljVHlwZSIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJ0YXJnZXQkMSIsImFkZCQxIiwib2xkSGFuZGxlciIsImV2IiwicmVtb3ZlJDIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJzdHlsZSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwicHJlZml4ZXMiLCJ0ZXN0RWwiLCJ1cHBlciIsInByZWZpeGVkIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJkZWYkJDEiLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJlbmQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiTnVtYmVyIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwibW9kZWwkMSIsImJpbmRpbmciLCJzZXRTZWxlY3RlZCIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJuZWVkUmVzZXQiLCJzb21lIiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJnZXRWYWx1ZSIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsImtleSQxIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiYm9keSIsImYiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJzaG91bGREZWNvZGUiLCJjb250ZW50IiwiZW5jb2RlZCIsImRpdiIsImlubmVySFRNTCIsInNob3VsZERlY29kZU5ld2xpbmVzIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiZGVjb2RlciIsImRlY29kZSIsImh0bWwiLCJzaW5nbGVBdHRySWRlbnRpZmllciIsInNpbmdsZUF0dHJBc3NpZ24iLCJzaW5nbGVBdHRyVmFsdWVzIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiZGVjb2RlQXR0ciIsInJlIiwicGFyc2VIVE1MIiwic3RhY2siLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCQxIiwiY2hhcnMiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwiZW5kVGFnTGVuZ3RoIiwicmVzdCIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwibGFzdEluZGV4IiwiZXhlYyIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluVlByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiZW5kUHJlIiwiZWxlbWVudCIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJ3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3MiLCJjb25kaXRpb25CbG9ja3MiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJzcGFjZSIsInVwIiwicmlnaHQiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwic2VsZiIsImN0cmwiLCJzaGlmdCIsImFsdCIsIm1ldGEiLCJtaWRkbGUiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImdlbktleUZpbHRlciIsImhhbmRsZXJDb2RlIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsInBhcnNlSW50IiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwid2FybiQzIiwidHJhbnNmb3JtcyQxIiwiZGF0YUdlbkZucyIsInBsYXRmb3JtRGlyZWN0aXZlcyQxIiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEiLCJvbmNlQ291bnQiLCJjdXJyZW50T3B0aW9ucyIsImdlbmVyYXRlIiwiYXN0IiwicHJldlN0YXRpY1JlbmRlckZucyIsImN1cnJlbnRTdGF0aWNSZW5kZXJGbnMiLCJwcmV2T25jZUNvdW50IiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsIm1heWJlQ29tcG9uZW50IiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJlbCQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJpZGVudFJFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIkZ1bmN0aW9uIiwiYmFzZUNvbXBpbGUiLCJtYWtlRnVuY3Rpb24iLCJjcmVhdGVDb21waWxlciIsImJhc2VPcHRpb25zIiwiZnVuY3Rpb25Db21waWxlQ2FjaGUiLCJjb21waWxlIiwiZmluYWxPcHRpb25zIiwidGlwcyIsInRpcCQkMSIsImNvbXBpbGVkIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwiZm5HZW5FcnJvcnMiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSQxIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMiIsInN0eWxlJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJyZWYkMSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUNBLFNBQVNBLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLE1BQU1DLFNBQU4sSUFBbUJELE1BQU0sSUFBaEM7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QXlFO0FBQ3ZFQSxhQUFLLGFBQUw7QUFDQUMsZ0JBQVUsS0FBSzBKLEtBQU4sR0FBZSxVQUF4QixFQUFxQyxTQUFyQyxFQUFnRCxhQUFoRDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU82OEIsTUFBTXI3QyxJQUFOLENBQVcsSUFBWCxFQUFpQitRLEVBQWpCLEVBQXFCc00sU0FBckIsQ0FBUDtBQUNELENBaEVEOztBQWtFQTs7OztBQUlBLFNBQVNrK0IsWUFBVCxDQUF1QnhxQyxFQUF2QixFQUEyQjtBQUN6QixNQUFJQSxHQUFHeXFDLFNBQVAsRUFBa0I7QUFDaEIsV0FBT3pxQyxHQUFHeXFDLFNBQVY7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJQyxZQUFZdnZDLFNBQVNtWixhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FvMkIsY0FBVTVxQixXQUFWLENBQXNCOWYsR0FBRzQ0QixTQUFILENBQWEsSUFBYixDQUF0QjtBQUNBLFdBQU84UixVQUFVbFIsU0FBakI7QUFDRDtBQUNGOztBQUVEL2UsTUFBTTB1QixPQUFOLEdBQWdCSyxrQkFBaEI7O0FBRUFtQixPQUFPQyxPQUFQLEdBQWlCbndCLEtBQWpCLEMiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi4zLjRcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBwb3NzaWJsZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgIHJldHVybiBhID09PSBiXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChudWxsKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gKSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWUsXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlclxuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSAnJztcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGNoaWxkLmRhdGEgJiYgY2hpbGQuZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gY2hpbGQuZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZUhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHtcbiAga2V5OiAxLFxuICByZWY6IDEsXG4gIHNsb3Q6IDFcbn07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldIHx8IGNvbmZpZy5pc1Jlc2VydmVkQXR0cihrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJObyBnZXR0ZXIgZnVuY3Rpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICAvLyBpc0FycmF5IGhlcmVcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGlzQXJyYXlcbiAgICAgID8gaW5qZWN0XG4gICAgICA6IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCB7fSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGxpc3RlbmVyczogZGF0YS5vbiB8fCB7fSxcbiAgICBpbmplY3Rpb25zOiByZXNvbHZlSW5qZWN0KEN0b3Iub3B0aW9ucy5pbmplY3QsIGNvbnRleHQpLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB2bm9kZS5mdW5jdGlvbmFsT3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDErKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHBdO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgY3VycmVudCwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIGlmIChjYWNoZWROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjMuNCc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmKHZhbHVlKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChpc0RlZih2YWx1ZVtpXSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQgKyAnICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkgeyByZXMgKz0ga2V5ICsgJyAnOyB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiZcbiAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICApXG59XG5cbi8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgZHluYW1pY2FsbHkgY2hhbmdpbmcgdHlwZSBmb3IgPGlucHV0PlxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgaW5QcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluUHJlICYmXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuICAgICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHRhZylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGluUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgIGlmIChyZWYucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSkgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV0gOiBudWxsO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBuZXdTdGFydFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICFiYWlsZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwidmFyICQkZXhwID0gXCIgKyAobW9kZWxScy5leHApICsgXCIsICQkaWR4ID0gXCIgKyAobW9kZWxScy5pZHgpICsgXCI7XCIgK1xuICAgICAgXCJpZiAoIUFycmF5LmlzQXJyYXkoJCRleHApKXtcIiArXG4gICAgICAgIHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIgK1xuICAgICAgXCJlbHNleyQkZXhwLnNwbGljZSgkJGlkeCwgMSwgXCIgKyBhc3NpZ25tZW50ICsgXCIpfVwiXG4gIH1cbn1cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcbiAgICBpZHg6IHZhbC5zdWJzdHJpbmcoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgZHluYW1pY1R5cGUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPGlucHV0IDp0eXBlPVxcXCJcIiArIGR5bmFtaWNUeXBlICsgXCJcXFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OlxcblwiICtcbiAgICAgICAgXCJ2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBpbnB1dCB0eXBlcy4gVXNlIHYtaWYgYnJhbmNoZXMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlciB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBpZiAob25jZSQkMSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgdGVzdEVsO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICB0ZXN0RWwgPSB0ZXN0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBlbC5vcHRpb25zKTsgfSlcbiAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgZWwub3B0aW9ucyk7XG4gICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uc1tpXSksIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW92ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0JDEpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QkMS5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChleHByZXNzaW9uID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFszXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzKG5vZGUuaWZDb25kaXRpb25zLCBpc0luRm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIChjb25kaXRpb25CbG9ja3MsIGlzSW5Gb3IpIHtcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvbmRpdGlvbkJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG1hcmtTdGF0aWNSb290cyhjb25kaXRpb25CbG9ja3NbaV0uYmxvY2ssIGlzSW5Gb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcbiAgICAvLyAjNTMzMDogd2FybiBjbGljay5yaWdodCwgc2luY2UgcmlnaHQgY2xpY2tzIGRvIG5vdCBhY3R1YWxseSBmaXJlIGNsaWNrIGV2ZW50cy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbmFtZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLm1vZGlmaWVycyAmJiBoYW5kbGVyLm1vZGlmaWVycy5yaWdodFxuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJVc2UgXFxcImNvbnRleHRtZW51XFxcIiBpbnN0ZWFkIG9mIFxcXCJjbGljay5yaWdodFxcXCIgc2luY2UgcmlnaHQgY2xpY2tzIFwiICtcbiAgICAgICAgXCJkbyBub3QgYWN0dWFsbHkgZmlyZSBcXFwiY2xpY2tcXFwiIGV2ZW50cy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQzO1xudmFyIHRyYW5zZm9ybXMkMTtcbnZhciBkYXRhR2VuRm5zO1xudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxO1xudmFyIHN0YXRpY1JlbmRlckZucztcbnZhciBvbmNlQ291bnQ7XG52YXIgY3VycmVudE9wdGlvbnM7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuICB2YXIgcHJldlN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG4gIG9uY2VDb3VudCA9IDA7XG4gIGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgd2FybiQzID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0cmFuc2Zvcm1zJDEgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcbiAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgb25jZUNvdW50ID0gcHJldk9uY2VDb3VudDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbClcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMkMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDMoXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIixcIiArIChvbmNlQ291bnQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoZWwpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChjb25kaXRpb25zKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGVsLm9uY2UgPyBnZW5PbmNlKGVsKSA6IGdlbkVsZW1lbnQoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBtYXliZUNvbXBvbmVudChlbCkgJiYgZWwudGFnICE9PSAnc2xvdCcgJiYgZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5rZXlcbiAgKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgd2FybiQzKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCB3YXJuJDMpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHBsYXRmb3JtRGlyZWN0aXZlcyQxW2Rpci5uYW1lXSB8fCBiYXNlRGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgd2FybiQzKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHdhcm4kMygnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgY3VycmVudE9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKHNsb3RzKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSk7IH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbClcbiAgfVxuICByZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCkpICsgXCJ9fVwiXG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChjaGlsZHJlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG4gIHJldHVybiAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEoZWwudGFnKVxufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YShlbCkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG4gICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgdmFyIGZ1bmN0aW9uQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBjb21waWxlIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHRpcHMgPSBbXTtcbiAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCQkMSkge1xuICAgICAgKHRpcCQkMSA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID0gKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgfVxuICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcbiAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgfVxuICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICByZXR1cm4gY29tcGlsZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHZhciBsID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLmxlbmd0aDtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXMuc3RhdGljUmVuZGVyRm5zW2ldID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnN0YXRpY1JlbmRlckZuc1tpXSwgZm5HZW5FcnJvcnMpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0gPSByZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjb21waWxlVG9GdW5jdGlvbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDJcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKCh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbm1vZHVsZS5leHBvcnRzID0gVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L192dWVAMi4zLjRAdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 543:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(51);
__webpack_require__(131);
__webpack_require__(132);
module.exports = __webpack_require__(85);


/***/ }),

/***/ 66:
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19wcm9jZXNzQDAuMTEuMTBAcHJvY2Vzcy9icm93c2VyLmpzPzExZmEiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSUEsVUFBVUMsT0FBT0MsT0FBUCxHQUFpQixFQUEvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQyxnQkFBSjtBQUNBLElBQUlDLGtCQUFKOztBQUVBLFNBQVNDLGdCQUFULEdBQTRCO0FBQ3hCLFVBQU0sSUFBSUMsS0FBSixDQUFVLGlDQUFWLENBQU47QUFDSDtBQUNELFNBQVNDLG1CQUFULEdBQWdDO0FBQzVCLFVBQU0sSUFBSUQsS0FBSixDQUFVLG1DQUFWLENBQU47QUFDSDtBQUNBLGFBQVk7QUFDVCxRQUFJO0FBQ0EsWUFBSSxPQUFPRSxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ2xDTCwrQkFBbUJLLFVBQW5CO0FBQ0gsU0FGRCxNQUVPO0FBQ0hMLCtCQUFtQkUsZ0JBQW5CO0FBQ0g7QUFDSixLQU5ELENBTUUsT0FBT0ksQ0FBUCxFQUFVO0FBQ1JOLDJCQUFtQkUsZ0JBQW5CO0FBQ0g7QUFDRCxRQUFJO0FBQ0EsWUFBSSxPQUFPSyxZQUFQLEtBQXdCLFVBQTVCLEVBQXdDO0FBQ3BDTixpQ0FBcUJNLFlBQXJCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hOLGlDQUFxQkcsbUJBQXJCO0FBQ0g7QUFDSixLQU5ELENBTUUsT0FBT0UsQ0FBUCxFQUFVO0FBQ1JMLDZCQUFxQkcsbUJBQXJCO0FBQ0g7QUFDSixDQW5CQSxHQUFEO0FBb0JBLFNBQVNJLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3JCLFFBQUlULHFCQUFxQkssVUFBekIsRUFBcUM7QUFDakM7QUFDQSxlQUFPQSxXQUFXSSxHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNEO0FBQ0EsUUFBSSxDQUFDVCxxQkFBcUJFLGdCQUFyQixJQUF5QyxDQUFDRixnQkFBM0MsS0FBZ0VLLFVBQXBFLEVBQWdGO0FBQzVFTCwyQkFBbUJLLFVBQW5CO0FBQ0EsZUFBT0EsV0FBV0ksR0FBWCxFQUFnQixDQUFoQixDQUFQO0FBQ0g7QUFDRCxRQUFJO0FBQ0E7QUFDQSxlQUFPVCxpQkFBaUJTLEdBQWpCLEVBQXNCLENBQXRCLENBQVA7QUFDSCxLQUhELENBR0UsT0FBTUgsQ0FBTixFQUFRO0FBQ04sWUFBSTtBQUNBO0FBQ0EsbUJBQU9OLGlCQUFpQlUsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJELEdBQTVCLEVBQWlDLENBQWpDLENBQVA7QUFDSCxTQUhELENBR0UsT0FBTUgsQ0FBTixFQUFRO0FBQ047QUFDQSxtQkFBT04saUJBQWlCVSxJQUFqQixDQUFzQixJQUF0QixFQUE0QkQsR0FBNUIsRUFBaUMsQ0FBakMsQ0FBUDtBQUNIO0FBQ0o7QUFHSjtBQUNELFNBQVNFLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDO0FBQzdCLFFBQUlYLHVCQUF1Qk0sWUFBM0IsRUFBeUM7QUFDckM7QUFDQSxlQUFPQSxhQUFhSyxNQUFiLENBQVA7QUFDSDtBQUNEO0FBQ0EsUUFBSSxDQUFDWCx1QkFBdUJHLG1CQUF2QixJQUE4QyxDQUFDSCxrQkFBaEQsS0FBdUVNLFlBQTNFLEVBQXlGO0FBQ3JGTiw2QkFBcUJNLFlBQXJCO0FBQ0EsZUFBT0EsYUFBYUssTUFBYixDQUFQO0FBQ0g7QUFDRCxRQUFJO0FBQ0E7QUFDQSxlQUFPWCxtQkFBbUJXLE1BQW5CLENBQVA7QUFDSCxLQUhELENBR0UsT0FBT04sQ0FBUCxFQUFTO0FBQ1AsWUFBSTtBQUNBO0FBQ0EsbUJBQU9MLG1CQUFtQlMsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJFLE1BQTlCLENBQVA7QUFDSCxTQUhELENBR0UsT0FBT04sQ0FBUCxFQUFTO0FBQ1A7QUFDQTtBQUNBLG1CQUFPTCxtQkFBbUJTLElBQW5CLENBQXdCLElBQXhCLEVBQThCRSxNQUE5QixDQUFQO0FBQ0g7QUFDSjtBQUlKO0FBQ0QsSUFBSUMsUUFBUSxFQUFaO0FBQ0EsSUFBSUMsV0FBVyxLQUFmO0FBQ0EsSUFBSUMsWUFBSjtBQUNBLElBQUlDLGFBQWEsQ0FBQyxDQUFsQjs7QUFFQSxTQUFTQyxlQUFULEdBQTJCO0FBQ3ZCLFFBQUksQ0FBQ0gsUUFBRCxJQUFhLENBQUNDLFlBQWxCLEVBQWdDO0FBQzVCO0FBQ0g7QUFDREQsZUFBVyxLQUFYO0FBQ0EsUUFBSUMsYUFBYUcsTUFBakIsRUFBeUI7QUFDckJMLGdCQUFRRSxhQUFhSSxNQUFiLENBQW9CTixLQUFwQixDQUFSO0FBQ0gsS0FGRCxNQUVPO0FBQ0hHLHFCQUFhLENBQUMsQ0FBZDtBQUNIO0FBQ0QsUUFBSUgsTUFBTUssTUFBVixFQUFrQjtBQUNkRTtBQUNIO0FBQ0o7O0FBRUQsU0FBU0EsVUFBVCxHQUFzQjtBQUNsQixRQUFJTixRQUFKLEVBQWM7QUFDVjtBQUNIO0FBQ0QsUUFBSU8sVUFBVWIsV0FBV1MsZUFBWCxDQUFkO0FBQ0FILGVBQVcsSUFBWDs7QUFFQSxRQUFJUSxNQUFNVCxNQUFNSyxNQUFoQjtBQUNBLFdBQU1JLEdBQU4sRUFBVztBQUNQUCx1QkFBZUYsS0FBZjtBQUNBQSxnQkFBUSxFQUFSO0FBQ0EsZUFBTyxFQUFFRyxVQUFGLEdBQWVNLEdBQXRCLEVBQTJCO0FBQ3ZCLGdCQUFJUCxZQUFKLEVBQWtCO0FBQ2RBLDZCQUFhQyxVQUFiLEVBQXlCTyxHQUF6QjtBQUNIO0FBQ0o7QUFDRFAscUJBQWEsQ0FBQyxDQUFkO0FBQ0FNLGNBQU1ULE1BQU1LLE1BQVo7QUFDSDtBQUNESCxtQkFBZSxJQUFmO0FBQ0FELGVBQVcsS0FBWDtBQUNBSCxvQkFBZ0JVLE9BQWhCO0FBQ0g7O0FBRUR4QixRQUFRMkIsUUFBUixHQUFtQixVQUFVZixHQUFWLEVBQWU7QUFDOUIsUUFBSWdCLE9BQU8sSUFBSUMsS0FBSixDQUFVQyxVQUFVVCxNQUFWLEdBQW1CLENBQTdCLENBQVg7QUFDQSxRQUFJUyxVQUFVVCxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3RCLGFBQUssSUFBSVUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxVQUFVVCxNQUE5QixFQUFzQ1UsR0FBdEMsRUFBMkM7QUFDdkNILGlCQUFLRyxJQUFJLENBQVQsSUFBY0QsVUFBVUMsQ0FBVixDQUFkO0FBQ0g7QUFDSjtBQUNEZixVQUFNZ0IsSUFBTixDQUFXLElBQUlDLElBQUosQ0FBU3JCLEdBQVQsRUFBY2dCLElBQWQsQ0FBWDtBQUNBLFFBQUlaLE1BQU1LLE1BQU4sS0FBaUIsQ0FBakIsSUFBc0IsQ0FBQ0osUUFBM0IsRUFBcUM7QUFDakNOLG1CQUFXWSxVQUFYO0FBQ0g7QUFDSixDQVhEOztBQWFBO0FBQ0EsU0FBU1UsSUFBVCxDQUFjckIsR0FBZCxFQUFtQnNCLEtBQW5CLEVBQTBCO0FBQ3RCLFNBQUt0QixHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLc0IsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7QUFDREQsS0FBS0UsU0FBTCxDQUFlVCxHQUFmLEdBQXFCLFlBQVk7QUFDN0IsU0FBS2QsR0FBTCxDQUFTd0IsS0FBVCxDQUFlLElBQWYsRUFBcUIsS0FBS0YsS0FBMUI7QUFDSCxDQUZEO0FBR0FsQyxRQUFRcUMsS0FBUixHQUFnQixTQUFoQjtBQUNBckMsUUFBUXNDLE9BQVIsR0FBa0IsSUFBbEI7QUFDQXRDLFFBQVF1QyxHQUFSLEdBQWMsRUFBZDtBQUNBdkMsUUFBUXdDLElBQVIsR0FBZSxFQUFmO0FBQ0F4QyxRQUFReUMsT0FBUixHQUFrQixFQUFsQixDLENBQXNCO0FBQ3RCekMsUUFBUTBDLFFBQVIsR0FBbUIsRUFBbkI7O0FBRUEsU0FBU0MsSUFBVCxHQUFnQixDQUFFOztBQUVsQjNDLFFBQVE0QyxFQUFSLEdBQWFELElBQWI7QUFDQTNDLFFBQVE2QyxXQUFSLEdBQXNCRixJQUF0QjtBQUNBM0MsUUFBUThDLElBQVIsR0FBZUgsSUFBZjtBQUNBM0MsUUFBUStDLEdBQVIsR0FBY0osSUFBZDtBQUNBM0MsUUFBUWdELGNBQVIsR0FBeUJMLElBQXpCO0FBQ0EzQyxRQUFRaUQsa0JBQVIsR0FBNkJOLElBQTdCO0FBQ0EzQyxRQUFRa0QsSUFBUixHQUFlUCxJQUFmO0FBQ0EzQyxRQUFRbUQsZUFBUixHQUEwQlIsSUFBMUI7QUFDQTNDLFFBQVFvRCxtQkFBUixHQUE4QlQsSUFBOUI7O0FBRUEzQyxRQUFRcUQsU0FBUixHQUFvQixVQUFVQyxJQUFWLEVBQWdCO0FBQUUsV0FBTyxFQUFQO0FBQVcsQ0FBakQ7O0FBRUF0RCxRQUFRdUQsT0FBUixHQUFrQixVQUFVRCxJQUFWLEVBQWdCO0FBQzlCLFVBQU0sSUFBSWhELEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFJQU4sUUFBUXdELEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBTyxHQUFQO0FBQVksQ0FBeEM7QUFDQXhELFFBQVF5RCxLQUFSLEdBQWdCLFVBQVVDLEdBQVYsRUFBZTtBQUMzQixVQUFNLElBQUlwRCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7QUFHQU4sUUFBUTJELEtBQVIsR0FBZ0IsWUFBVztBQUFFLFdBQU8sQ0FBUDtBQUFXLENBQXhDIiwiZmlsZSI6IjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vX3Byb2Nlc3NAMC4xMS4xMEBwcm9jZXNzL2Jyb3dzZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 85:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tether__ = __webpack_require__(469);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tether___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tether__);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction omitLinkProps() {\n  for (var t = [], e = arguments.length; e--;) {\n    t[e] = arguments[e];\n  }return Object.keys(props).reduce(function (e, n) {\n    return t.includes(n) || (e[n] = props[n]), e;\n  }, {});\n}function isVisible(t) {\n  return t && (t.offsetWidth > 0 || t.offsetHeight > 0);\n}function findFirstVisible(t, e) {\n  if (!t || !t.querySelectorAll || !e) return null;for (var n = Array.prototype.slice.call(t.querySelectorAll(e)), i = n.find ? n.find(function (t) {\n    return isVisible(t);\n  }) : null, o = 0; !i && o < n.length; o++) {\n    isVisible(n[o]) && (i = n[o]);\n  }return i;\n}function isVisible$1(t) {\n  return t && (t.offsetWidth > 0 || t.offsetHeight > 0);\n}function makePageArray(t, e) {\n  return Array.apply(null, { length: e }).map(function (e, n) {\n    return { number: n + t, className: null };\n  });\n}function observeDOM(t, e, n) {\n  var i = window.MutationObserver || window.WebKitMutationObserver,\n      o = window.addEventListener;i ? new i(function (t) {\n    (t[0].addedNodes.length > 0 || t[0].removedNodes.length > 0) && e();\n  }).observe(t, Object.assign({ childList: !0, subtree: !0 }, n)) : o && (t.addEventListener(\"DOMNodeInserted\", e, !1), t.addEventListener(\"DOMNodeRemoved\", e, !1));\n}function targets(t, e, n, i) {\n  var o = t.__vue__;if (!o) return console.warn(\"__vue__ is not available on element\", t), [];var r = Object.keys(e.modifiers || {}).filter(function (t) {\n    return !all_listen_types[t];\n  });e.value && r.push(e.value);var s = function s() {\n    i({ targets: r, vm: o });\n  };return Object.keys(all_listen_types).forEach(function (i) {\n    (n[i] || e.modifiers[i]) && t.addEventListener(i, s);\n  }), r;\n}function isElement(t) {\n  return t.nodeType;\n}function closest(t, e) {\n  var n = t.closest(e);return n === t ? null : n;\n}function $QSA(t, e) {\n  return e || (e = document), isElement(e) ? Array.prototype.slice.call(e.querySelectorAll(t)) : [];\n}function $QS(t, e) {\n  return e || (e = document), isElement(e) ? e.querySelector(t) || null : null;\n}function getVm(t) {\n  return t ? t.__vue__ : null;\n}function toType(t) {\n  return {}.toString.call(t).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}function typeCheckConfig(t, e, n) {\n  for (var i in n) {\n    if (Object.prototype.hasOwnProperty.call(n, i)) {\n      var o = n[i],\n          r = e[i],\n          s = r && isElement(r) ? \"element\" : toType(r);new RegExp(o).test(s) || console.error(t + ': Option \"' + i + '\" provided type \"' + s + '\" but expected type \"' + o + '\"');\n    }\n  }\n}function ScrollSpy(t, e) {\n  this._$el = t, this._selector = [Selector.NAV_LINKS, Selector.LIST_ITEMS, Selector.DROPDOWN_ITEMS].join(\",\"), this._config = Object.assign({}, Default), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, this._$root = null, this._resizeTimeout = null, this.updateConfig(e);\n}var warn = function warn(t) {\n  console.warn(\"[Bootstrap-Vue warn]: \" + t);\n},\n    alert = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return t.localShow ? n(\"div\", { class: t.classObject, attrs: { role: \"alert\", \"aria-live\": \"polite\", \"aria-atomic\": \"true\" } }, [t.dismissible ? n(\"button\", { staticClass: \"close\", attrs: { type: \"button\", \"data-dismiss\": \"alert\", \"aria-label\": \"dismissLabel\" }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.dismiss(e);\n        } } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" } }, [t._v(\"×\")])]) : t._e(), t._t(\"default\")], 2) : t._e();\n  }, staticRenderFns: [], data: function data() {\n    return { countDownTimerId: null, dismissed: !1 };\n  }, created: function created() {\n    this.state && warn('<b-alert> \"state\" property is deprecated, please use \"variant\" property instead.');\n  }, computed: { classObject: function classObject() {\n      return [\"alert\", this.alertVariant, this.dismissible ? \"alert-dismissible\" : \"\"];\n    }, alertVariant: function alertVariant() {\n      return \"alert-\" + (this.state || this.variant || \"info\");\n    }, localShow: function localShow() {\n      return !this.dismissed && (this.countDownTimerId || this.show);\n    } }, props: { variant: { type: String, default: \"info\" }, state: { type: String, default: null }, dismissible: { type: Boolean, default: !1 }, dismissLabel: { type: String, default: \"Close\" }, show: { type: [Boolean, Number], default: !1 } }, watch: { show: function show() {\n      this.showChanged();\n    } }, mounted: function mounted() {\n    this.showChanged();\n  }, methods: { dismiss: function dismiss() {\n      this.dismissed = !0, this.$emit(\"dismissed\"), this.clearCounter();\n    }, clearCounter: function clearCounter() {\n      this.countDownTimerId && clearInterval(this.countDownTimerId);\n    }, showChanged: function showChanged() {\n      var t = this;if (this.dismissed = !1, !0 !== this.show && !1 !== this.show && null !== this.show && 0 !== this.show) {\n        var e = this.show;this.$emit(\"dismiss-count-down\", e), this.clearCounter(), this.countDownTimerId = setInterval(function () {\n          if (e < 2) return t.dismiss();e--, t.$emit(\"dismiss-count-down\", e);\n        }, 1e3);\n      }\n    } } },\n    props = { active: { type: Boolean, default: !1 }, activeClass: { type: String, default: \"active\" }, append: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, event: { type: [String, Array], default: \"click\" }, exact: { type: Boolean, default: !1 }, exactActiveClass: { type: String, default: \"active\" }, href: { type: String, default: \"#\" }, rel: { type: String, default: null }, replace: { type: Boolean, default: !1 }, routerTag: { type: String, default: \"a\" }, tag: { type: String, default: null }, target: { type: String, default: \"_self\" }, to: { type: [String, Object], default: null } },\n    computed = { linkProps: function linkProps() {\n    var t = this;return Object.keys(props).reduce(function (e, n) {\n      return e[n] = t[n], e;\n    }, {});\n  }, isRouterLink: function isRouterLink() {\n    return Boolean(this.$router && this.to && !this.disabled);\n  }, _href: function _href() {\n    return this.disabled ? \"#\" : this.href ? this.href : this.to && \"string\" == typeof this.to ? this.to : void 0;\n  }, computedRel: function computedRel() {\n    return \"_blank\" === this.target && null === this.rel ? \"noopener\" : this.rel || null;\n  }, componentTag: function componentTag() {\n    return this.tag ? (warn('<b-link> \"tag\" property is deprecated, please use \"routerTag\" property instead.'), this.tag) : this.routerTag;\n  }, linkClassObject: function linkClassObject() {\n    return [this.active ? this.exact ? this.exactActiveClass : this.activeClass : null, this.disabled ? \"disabled\" : null];\n  } },\n    methods = { linkClick: function linkClick(t) {\n    this.disabled ? t.stopPropagation() : (this.$root.$emit(\"clicked::link\", this), this.$emit(\"click\", t)), this.isRouterLink || \"#\" !== this._href || t.preventDefault();\n  } },\n    linkMixin = { props: props, computed: computed, methods: methods },\n    bLink = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return t.isRouterLink ? n(\"router-link\", { tag: \"a\", class: t.linkClassObject, attrs: { \"active-class\": t.activeClass, \"exact-active-class\": t.exactActiveClass, disabled: t.disabled, \"aria-disabled\": t.disabled ? \"true\" : \"false\", to: t.to, exact: t.exact, append: t.append, replace: t.replace, event: t.event, tag: t.componentTag }, nativeOn: { click: function click(e) {\n          t.linkClick(e);\n        } } }, [t._t(\"default\")], 2) : n(\"a\", { class: t.linkClassObject, attrs: { disabled: t.disabled, \"aria-disabled\": t.disabled ? \"true\" : \"false\", href: t._href, target: t.target || null, rel: t.computedRel }, on: { click: t.linkClick } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], mixins: [linkMixin] },\n    bLinkPropKeys = Object.keys(props),\n    breadcrumb = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"ol\", { staticClass: \"breadcrumb\" }, [t._l(t.normalizedItems, function (e) {\n      return n(\"li\", { class: [\"breadcrumb-item\", e.active ? \"active\" : null], attrs: { role: \"presentation\" }, on: { click: function click(n) {\n            t.onClick(e._originalItem);\n          } } }, [e.active ? n(\"span\", { attrs: { \"aria-current\": t.ariaCurrent }, domProps: { innerHTML: t._s(e.text) } }) : n(\"b-link\", t._b({ domProps: { innerHTML: t._s(e.text) } }, \"b-link\", e._linkProps))], 1);\n    }), t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, computed: { normalizedItems: function normalizedItems() {\n      var t = !1,\n          e = this.items.length;return this.items.map(function (n, i) {\n        var o = { _originalItem: n },\n            r = i === e - 1;return \"string\" == typeof n ? Object.assign(o, { text: n, link: \"#\", active: r }) : Object.assign(o, n), !0 === o.active || !1 === o.active || t ? o.active && (t = !0) : o.active = r, o.link && (o.href = o.link), o._linkProps = Object.keys(o).reduce(function (t, e) {\n          return bLinkPropKeys.includes(e) && (t[e] = o[e]), t;\n        }, {}), o;\n      });\n    } }, props: { items: { type: Array, default: function _default() {\n        return [];\n      }, required: !0 }, ariaCurrent: { type: String, default: \"location\" } }, methods: { onClick: function onClick(t) {\n      this.$emit(\"click\", t);\n    } } },\n    linkProps = Object.assign(omitLinkProps(\"href\", \"to\"), { href: { type: props.href.type }, to: { type: props.to.type } }),\n    bBtn = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.componentType, t._b({ tag: \"button\", class: t.classList, attrs: { type: t.btnType, disabled: t.disabled }, on: { click: t.onClick } }, \"button\", t.conditionalLinkProps), [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, computed: { linkProps: computed.linkProps, classList: function classList() {\n      return [\"btn\", this.btnVariant, this.btnSize, this.btnBlock, this.btnDisabled];\n    }, componentType: function componentType() {\n      return this.href || this.to ? \"b-link\" : \"button\";\n    }, btnBlock: function btnBlock() {\n      return this.block ? \"btn-block\" : \"\";\n    }, btnVariant: function btnVariant() {\n      return this.variant ? \"btn-\" + this.variant : \"btn-secondary\";\n    }, btnSize: function btnSize() {\n      return this.size ? \"btn-\" + this.size : \"\";\n    }, btnDisabled: function btnDisabled() {\n      return this.disabled ? \"disabled\" : \"\";\n    }, btnType: function btnType() {\n      return this.href || this.to ? null : this.type;\n    }, conditionalLinkProps: function conditionalLinkProps() {\n      return \"button\" === this.componentType ? {} : this.linkProps;\n    } }, props: Object.assign(linkProps, { block: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, size: { type: String, default: null }, variant: { type: String, default: null }, type: { type: String, default: \"button\" } }), methods: { onClick: function onClick(t) {\n      this.disabled ? (t.stopPropagation(), t.preventDefault()) : this.$emit(\"click\", t);\n    } } },\n    ITEM_SELECTOR = ['.btn:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', '.form-control:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', 'select:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', 'input[type=\"checkbox\"]:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', 'input[type=\"radio\"]:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])'].join(\",\"),\n    buttonToolbar = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { class: t.classObject, attrs: { role: \"toolbar\", tabindex: t.keyNav ? \"0\" : null }, on: { focusin: function focusin(e) {\n          if (e.target !== e.currentTarget) return null;t.focusFirst(e);\n        }, keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : void t.focusNext(e, !0) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : void t.focusNext(e, !1) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"left\", 37)) && e.shiftKey ? \"button\" in e && 0 !== e.button ? null : void t.focusFirst(e) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"up\", 38)) && e.shiftKey ? void t.focusFirst(e) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"right\", 39)) && e.shiftKey ? \"button\" in e && 2 !== e.button ? null : void t.focusLast(e) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"down\", 40)) && e.shiftKey ? void t.focusLast(e) : null;\n        }] } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"btn-toolbar\", this.justify && !this.vertical ? \"justify-content-between\" : \"\"];\n    } }, props: { justify: { type: Boolean, default: !1 }, KeyNav: { type: Boolean, default: !1 } }, methods: { setItemFocus: function setItemFocus(t) {\n      this.$nextTick(function () {\n        t.focus();\n      });\n    }, focusNext: function focusNext(t, e) {\n      if (this.keyNav) {\n        t.preventDefault(), t.stopPropagation();var n = this.getItems();if (!(n.length < 1)) {\n          var i = n.indexOf(t.target);e && i > 0 ? i-- : !e && i < n.length - 1 && i++, i < 0 && (i = 0), this.setItemFocus(n[i]);\n        }\n      }\n    }, focusFirst: function focusFirst(t) {\n      if (this.keyNav) {\n        t.preventDefault(), t.stopPropagation();var e = this.getItems();e.length > 0 && this.setItemFocus(e[0]);\n      }\n    }, focusLast: function focusLast(t) {\n      if (this.keyNav) {\n        t.preventDefault(), t.stopPropagation();var e = this.getItems();e.length > 0 && this.setItemFocus([e.length - 1]);\n      }\n    }, getItems: function getItems() {\n      var t = Array.prototype.slice.call(this.$el.querySelectorAll(ITEM_SELECTOR));return t.forEach(function (t) {\n        t.tabIndex = -1;\n      }), t;\n    } }, mounted: function mounted() {\n    this.keyNav && this.getItems();\n  } },\n    buttonGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"btn-group\", this.vertical ? \"btn-group-vertical\" : \"\", this.justify && !this.vertical ? \"justify-content-between\" : \"\", this.size ? \"btn-group-\" + this.size : \"\"];\n    } }, props: { vertical: { type: Boolean, default: !1 }, justify: { type: Boolean, default: !1 }, size: { type: String, default: null } } },\n    clickOut = { mounted: function mounted() {\n    \"undefined\" != typeof document && document.documentElement.addEventListener(\"click\", this._clickOutListener);\n  }, destroyed: function destroyed() {\n    \"undefined\" != typeof document && document.removeEventListener(\"click\", this._clickOutListener);\n  }, methods: { _clickOutListener: function _clickOutListener(t) {\n      this.$el.contains(t.target) || this.clickOutListener && this.clickOutListener();\n    } } },\n    ITEM_SELECTOR$1 = '.dropdown-item:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])',\n    HEADER_SELECTOR = '.dropdown-header:not([style*=\"display: none\"]):not([style*=\"display:none\"])',\n    ALL_SELECTOR = [ITEM_SELECTOR$1, HEADER_SELECTOR].join(\",\"),\n    dropdown = { props: { split: { type: Boolean, default: !1 }, text: { type: String, default: \"\" }, dropup: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, right: { type: Boolean, default: !1 } }, created: function created() {\n    var t = this,\n        e = function e(_e) {\n      _e !== t && (t.visible = !1);\n    };this.$root.$on(\"shown::dropdown\", e), this.$root.$on(\"clicked::link\", e);\n  }, watch: { visible: function visible(t, e) {\n      var n = this;t !== e && (t ? (this.$root.$emit(\"shown::dropdown\", this), \"undefined\" != typeof document && \"ontouchstart\" in document.documentElement && Array.prototype.slice.call(document.body.children).forEach(function (t) {\n        t.addEventListener(\"mouseover\", n.noop);\n      })) : (this.$root.$emit(\"hidden::dropdown\", this), \"undefined\" != typeof document && \"ontouchstart\" in document.documentElement && Array.prototype.slice.call(document.body.children).forEach(function (t) {\n        t.removeEventListener(\"mouseover\", n.noop);\n      })));\n    } }, methods: { noop: function noop() {}, toggle: function toggle() {\n      this.disabled ? this.visible = !1 : (this.visible = !this.visible, this.visible && this.$nextTick(function () {\n        var t = this.getFirstItem();t && this.focusItem(0, [t]);\n      }));\n    }, onTab: function onTab() {\n      this.visible && (this.visible = !1);\n    }, onEsc: function onEsc(t) {\n      this.visible && (this.visible = !1, t.preventDefault(), t.stopPropagation(), this.$nextTick(function () {\n        var t;(t = this.split && this.$refs.toggle ? this.$refs.toggle.$el || this.$refs.toggle : this.$refs.button.$el || this.$refs.button) && t.focus && t.focus();\n      }));\n    }, focusNext: function focusNext(t, e) {\n      if (this.visible) {\n        t.preventDefault(), t.stopPropagation();var n = this.getItems();if (!(n.length < 1)) {\n          var i = n.indexOf(t.target);e && i > 0 ? i-- : !e && i < n.length - 1 && i++, i < 0 && (i = 0), this.focusItem(i, n);\n        }\n      }\n    }, focusHovered: function focusHovered(t) {\n      if (this.visible) {\n        var e = this.getItems();if (!(e.length < 1)) {\n          var n = e.indexOf(t.target);n > -1 && (t.preventDefault(), t.stopPropagation(), this.focusItem(n, e));\n        }\n      }\n    }, focusItem: function focusItem(t, e) {\n      e.forEach(function (e, n) {\n        n === t ? (e.classList.add(\"active\"), e.focus()) : e.classList.remove(\"active\");\n      });\n    }, getItems: function getItems() {\n      return Array.prototype.slice.call(this.$refs.menu.querySelectorAll(ALL_SELECTOR));\n    }, getFirstItem: function getFirstItem() {\n      var t = this.$refs.menu.querySelector(ITEM_SELECTOR$1);return t || (t = this.$refs.menu.querySelector(HEADER_SELECTOR)), t || null;\n    } } },\n    buttonGroupDropdown = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"btn-group\", \"dropdown\", { dropup: t.dropup, show: t.visible }], attrs: { id: t.id || null } }, [n(\"b-button\", { ref: \"button\", class: { \"dropdown-toggle\": !t.split, \"btn-link\": t.link }, attrs: { id: t.id ? t.id + \"__BV_button_\" : null, \"aria-expanded\": t.visible ? \"true\" : \"false\", variant: t.variant, size: t.size, disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.click(e);\n        }, kedown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.click(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.click(e);\n        }] } }, [t._t(\"text\", [t._v(t._s(t.text))])], 2), n(\"div\", { ref: \"menu\", class: [\"dropdown-menu\", { \"dropdown-menu-right\": t.right }], attrs: { role: \"menu\", \"aria-labelledby\": t.id ? t.id + \"__BV_button_\" : null }, on: { keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"tab\", 9)) return null;t.onTab(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }], mouseover: function mouseover(e) {\n          t.focusHovered(e);\n        } } }, [t._t(\"default\")], 2)], 1);\n  }, staticRenderFns: [], mixins: [clickOut, dropdown], data: function data() {\n    return { visible: !1 };\n  }, computed: { dropdownToggle: function dropdownToggle() {\n      return this.caret ? \"dropdown-toggle\" : \"\";\n    } }, props: { id: { type: String }, caret: { type: Boolean, default: !0 } }, methods: { clickOutListener: function clickOutListener() {\n      this.visible = !1;\n    } } },\n    inputGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: t.classObject, attrs: { role: \"group\" } }, [t._t(\"left\", [t.left ? n(\"div\", { staticClass: \"input-group-addon\", domProps: { innerHTML: t._s(t.left) } }) : t._e()]), t._t(\"default\"), t._t(\"right\", [t.right ? n(\"div\", { staticClass: \"input-group-addon\", domProps: { innerHTML: t._s(t.right) } }) : t._e()])], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"input-group\", this.size ? \"input-group-\" + this.size : \"\", this.state ? \"has-\" + this.state : \"\"];\n    } }, props: { size: { type: String, default: null }, state: { type: String, default: null }, left: { type: String, default: null }, right: { type: String, default: null } } },\n    inputGroupAddon = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { staticClass: \"input-group-addon\", attrs: { id: t.id || null } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { id: { type: String, default: null } } },\n    inputGroupButton = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { staticClass: \"input-group-btn\" }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: {} },\n    card = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(t.tag, { tag: \"component\", class: [\"card\", t.cardVariant, t.cardAlign, t.cardInverse] }, [t._t(\"img\", [t.img ? n(\"img\", { staticClass: \"card-img\", attrs: { src: t.img, alt: t.imgAlt } }) : t._e()]), t.header || t.$slots.header ? n(t.headerTag, { tag: \"component\", class: [\"card-header\", t.headerVariant ? \"bg-\" + t.headerVariant : \"\", t.headerClass] }, [t._t(\"header\", [n(\"div\", { domProps: { innerHTML: t._s(t.header) } })])], 2) : t._e(), t.noBlock ? [t._t(\"default\")] : n(\"div\", { class: t.blockClass }, [t.title ? n(\"h4\", { staticClass: \"card-title\", domProps: { innerHTML: t._s(t.title) } }) : t._e(), t.subTitle ? n(\"h6\", { staticClass: \"card-subtitle mb-2 text-muted\", domProps: { innerHTML: t._s(t.subTitle) } }) : t._e(), t._t(\"default\")], 2), t.footer || t.$slots.footer ? n(t.footerTag, { tag: \"component\", class: [\"card-footer\", t.footerVariant ? \"bg-\" + t.footerVariant : \"\", t.footerClass] }, [t._t(\"footer\", [n(\"div\", { domProps: { innerHTML: t._s(t.footer) } })])], 2) : t._e()], 2);\n  }, staticRenderFns: [], computed: { blockClass: function blockClass() {\n      return [\"card-block\", this.overlay ? \"card-img-overlay\" : null];\n    }, cardVariant: function cardVariant() {\n      return this.variant ? \"card-\" + this.variant : null;\n    }, cardInverse: function cardInverse() {\n      return this.overlay || this.inverse ? \"card-inverse\" : null === this.inverse && this.variant && this.variant.length > 0 && -1 === this.variant.indexOf(\"outline\") ? \"card-inverse\" : void 0;\n    }, cardAlign: function cardAlign() {\n      return this.align ? \"text-\" + this.align : null;\n    } }, props: { align: { type: String, default: null }, inverse: { type: Boolean, default: null }, variant: { type: String, default: null }, tag: { type: String, default: \"div\" }, header: { type: String, default: null }, headerVariant: { type: String, default: null }, headerClass: { type: [String, Array], default: \"\" }, headerTag: { type: String, default: \"div\" }, footer: { type: String, default: null }, footerVariant: { type: String, default: null }, footerClass: { type: [String, Array], default: \"\" }, footerTag: { type: String, default: \"div\" }, title: { type: String, default: null }, subTitle: { type: String, default: null }, noBlock: { type: Boolean, default: !1 }, img: { type: String, default: null }, imgAlt: { type: String, default: null }, overlay: { type: Boolean, default: !1 } } },\n    cardGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.tag, { tag: \"component\", class: [\"card-\" + t.type] }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { type: function type() {\n      return this.deck ? \"deck\" : this.columns ? \"columns\" : \"group\";\n    } }, props: { tag: { type: String, default: \"div\" }, deck: { type: Boolean, default: !1 }, columns: { type: Boolean, default: !1 } } },\n    DIRECTION = { next: { current: \"carousel-item-left\", next: \"carousel-item-right\", overlay: \"carousel-item-next\" }, prev: { current: \"carousel-item-right\", next: \"carousel-item-left\", overlay: \"carousel-item-prev\" } },\n    carousel = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"carousel slide\", style: { background: t.background, height: t.height }, attrs: { role: \"region\", id: t.id || null, \"aria-busy\": t.isSliding ? \"true\" : \"false\" }, on: { mouseenter: t.pause, mouseleave: t.start, focusin: t.pause, focusout: function focusout(e) {\n          t.restart(e);\n        }, keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : (e.stopPropagation(), e.preventDefault(), void t.prev(e)) : null;\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : (e.stopPropagation(), e.preventDefault(), void t.next(e)) : null;\n        }] } }, [n(\"div\", { staticClass: \"carousel-inner\", attrs: { role: \"list\", id: t.id ? t.id + \"__BV_inner_\" : null } }, [t._t(\"default\")], 2), t.controls ? [n(\"a\", { staticClass: \"carousel-control-prev\", attrs: { href: \"#\", role: \"button\", \"aria-controls\": t.id ? t.id + \"__BV_inner_\" : null }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.prev(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.prev(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.prev(e);\n        }] } }, [n(\"span\", { staticClass: \"carousel-control-prev-icon\", attrs: { \"aria-hidden\": \"true\" } }), t._v(\" \"), n(\"span\", { staticClass: \"sr-only\" }, [t._v(t._s(t.labelPrev))])]), n(\"a\", { staticClass: \"carousel-control-next\", attrs: { href: \"#\", role: \"button\", \"aria-controls\": t.id ? t.id + \"__BV_inner_\" : null }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.next(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.next(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.next(e);\n        }] } }, [n(\"span\", { staticClass: \"carousel-control-next-icon\", attrs: { \"aria-hidden\": \"true\" } }), t._v(\" \"), n(\"span\", { staticClass: \"sr-only\" }, [t._v(t._s(t.labelNext))])])] : t._e(), n(\"ol\", { directives: [{ name: \"show\", rawName: \"v-show\", value: t.indicators, expression: \"indicators\" }], staticClass: \"carousel-indicators\", attrs: { role: \"group\", id: t.id ? t.id + \"__BV_indicators_\" : null, \"aria-hidden\": t.indicators ? \"false\" : \"true\", \"aria-label\": t.indicators && t.labelIndicators ? t.labelIndicators : null, \"aria-owns\": t.indicators && t.id ? t.id + \"__BV_inner_\" : null } }, t._l(t.slides.length, function (e) {\n      return n(\"li\", { class: { active: e - 1 === t.index }, attrs: { role: \"button\", id: t.id ? t.id + \"__BV_indicator_\" + e + \"_\" : null, tabindex: t.indicators ? \"0\" : \"-1\", \"aria-current\": e - 1 === t.index ? \"true\" : \"false\", \"aria-posinset\": e, \"aria-setsize\": t.slides.length, \"aria-label\": t.labelGotoSlide + \" \" + e, \"aria-describedby\": t.slides[e - 1].id || null, \"aria-controls\": t.id ? t.id + \"__BV_inner_\" : null }, on: { click: function click(n) {\n            t.index = e - 1;\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.stopPropagation(), n.preventDefault(), t.index = e - 1;\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.stopPropagation(), n.preventDefault(), t.index = e - 1;\n          }] } });\n    }))], 2);\n  }, staticRenderFns: [], data: function data() {\n    return { index: 0, isSliding: !1, slides: [] };\n  }, props: { id: { type: String }, labelPrev: { type: String, default: \"Previous Slide\" }, labelNext: { type: String, default: \"Next Slide\" }, labelGotoSlide: { type: String, default: \"Goto Slide\" }, labelIndicators: { type: String, default: \"Select a slide to display\" }, interval: { type: Number, default: 5e3 }, indicators: { type: Boolean, default: !1 }, controls: { type: Boolean, default: !1 }, height: { type: String }, background: { type: String } }, methods: { prev: function prev() {\n      this.index <= 0 ? this.index = this.slides.length - 1 : this.index--;\n    }, next: function next() {\n      \"undefined\" != typeof document && document.visibilityState && document.hidden || (this.index >= this.slides.length - 1 ? this.index = 0 : this.index++);\n    }, pause: function pause() {\n      0 !== this.interval && void 0 !== this.interval && (clearInterval(this._intervalId), this._intervalId = null, this.slides[this.index].tabIndex = 0);\n    }, start: function start() {\n      var t = this;0 !== this.interval && void 0 !== this.interval && (this.slides.forEach(function (t) {\n        t.tabIndex = -1;\n      }), this._intervalId = setInterval(function () {\n        t.next();\n      }, this.interval));\n    }, restart: function restart(t) {\n      t.relatedTarget && this.$el.contains(t.relatedTarget) || this.start();\n    } }, mounted: function mounted() {\n    this.slides = Array.prototype.slice.call(this.$el.querySelectorAll(\".carousel-item\")), this.slides[0].classList.add(\"active\");var t = this;this.slides.forEach(function (e, n) {\n      var i = n + 1;e.setAttribute(\"aria-current\", 0 === n ? \"true\" : \"false\"), e.setAttribute(\"aria-posinset\", String(i)), e.setAttribute(\"aria-setsize\", String(t.slides.length)), e.tabIndex = -1, t.id && e.setAttribute(\"aria-controlledby\", t.id + \"__BV_indicator_\" + i + \"_\");\n    }), this._intervalId = null, this.start();\n  }, watch: { index: function index(t, e) {\n      var n = this;if (t !== e) if (this.isSliding) this.index = e;else {\n        var i = t > e ? DIRECTION.next : DIRECTION.prev;0 === e && t === this.slides.length - 1 ? i = DIRECTION.prev : e === this.slides.length - 1 && 0 === t && (i = DIRECTION.next);var o = this.slides[e],\n            r = this.slides[t];o && r && (this.isSliding = !0, r.classList.add(i.next, i.overlay), o.classList.add(i.current), this._carouselAnimation = setTimeout(function () {\n          n.$emit(\"slide\", t), o.classList.remove(\"active\"), o.setAttribute(\"aria-current\", \"false\"), o.setAttribute(\"aria-hidden\", \"true\"), o.tabIndex = -1, o.classList.remove(i.current), r.classList.add(\"active\"), r.setAttribute(\"aria-current\", \"true\"), r.setAttribute(\"aria-hidden\", \"false\"), r.tabIndex = -1, r.classList.remove(i.next, i.overlay), n._intervalId || (o.tabIndex = 0, n.$nextTick(function () {\n            o.focus();\n          })), n.isSliding = !1;\n        }, 500));\n      }\n    } }, destroyed: function destroyed() {\n    clearTimeout(this._carouselAnimation), clearInterval(this._intervalId);\n  } },\n    carouselSlide = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"carousel-item\", style: { background: t.background, height: t.height }, attrs: { role: \"listitem\", id: t.id || null } }, [t.img ? n(\"img\", { staticClass: \"d-block img-fluid\", attrs: { src: t.img, alt: t.imgAlt } }) : t._e(), n(\"div\", { class: t.contentClasses }, [t.caption ? n(\"h3\", { domProps: { innerHTML: t._s(t.caption) } }) : t._e(), t.text ? n(\"p\", { domProps: { innerHTML: t._s(t.text) } }) : t._e(), t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], props: { id: { type: String }, img: { type: String }, imgAlt: { type: String }, contentVisibleUp: { type: String }, caption: { type: String }, text: { type: String }, background: { type: String }, height: { type: String } }, computed: { contentClasses: function contentClasses() {\n      var t = { \"carousel-caption\": Boolean(this.caption) };return this.contentVisibleUp && (t[\"d-none\"] = !0, t[\"d-\" + this.contentVisibleUp + \"-block\"] = !0), t;\n    } } },\n    collapse = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"transition\", { attrs: { name: \"collapse\" }, on: { enter: t.enter, \"after-enter\": t.clearHeight, leave: t.leave, \"after-leave\": t.clearHeight } }, [n(\"div\", { directives: [{ name: \"show\", rawName: \"v-show\", value: t.show, expression: \"show\" }], class: t.classObject, attrs: { id: t.id || null } }, [t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], _scopeId: \"data-v-67b0a2de\", data: function data() {\n    return { show: this.visible };\n  }, computed: { classObject: function classObject() {\n      return { \"navbar-collapse\": this.isNav, show: this.show };\n    } }, model: { prop: \"visible\", event: \"input\" }, watch: { visible: function visible(t) {\n      t !== this.show && (this.show = t, this.emitState());\n    } }, props: { isNav: { type: Boolean, default: !1 }, id: { type: String, required: !0 }, accordion: { type: String, default: null }, visible: { type: Boolean, default: !1 } }, methods: { toggle: function toggle() {\n      this.show = !this.show, this.emitState();\n    }, enter: function enter(t) {\n      t.style.height = \"auto\";var e = getComputedStyle(t).height;t.style.height = \"0px\", t.offsetHeight, t.style.height = e;\n    }, leave: function leave(t) {\n      t.style.height = \"auto\";var e = getComputedStyle(t).height;t.style.height = e, t.offsetHeight, t.style.height = \"0px\";\n    }, clearHeight: function clearHeight(t) {\n      t.style.height = null;\n    }, emitState: function emitState() {\n      this.$emit(\"input\", this.show), this.$root.$emit(\"collapse::toggle::state\", this.id, this.show), this.accordion && this.show && this.$root.$emit(\"accordion::toggle\", this.id, this.accordion);\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"collapse::toggle\", function (e) {\n      e === t.id && t.toggle();\n    }), this.$root.$on(\"accordion::toggle\", function (e, n) {\n      t.accordion && n === t.accordion && (e === t.id ? t.show || t.toggle() : t.show && t.toggle());\n    });\n  }, mounted: function mounted() {\n    this.emitState();\n  } },\n    dropdown$1 = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"dropdown\", \"btn-group\", { dropup: t.dropup, show: t.visible }], attrs: { id: t.id || null } }, [n(\"b-button\", { ref: \"button\", class: { \"dropdown-toggle\": !t.split, \"btn-link\": t.link }, attrs: { id: t.id ? t.id + \"__BV_button_\" : null, \"aria-haspopup\": t.split ? null : \"true\", \"aria-expanded\": t.split ? null : t.visible ? \"true\" : \"false\", variant: t.variant, size: t.size, disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.click(e);\n        } } }, [t._t(\"text\", [t._v(t._s(t.text))])], 2), t.split ? n(\"b-button\", { ref: \"toggle\", class: [\"dropdown-toggle\", \"dropdown-toggle-split\", { \"btn-link\": t.link }], attrs: { id: t.id ? t.id + \"__BV_toggle_\" : null, \"aria-haspopup\": t.split ? \"true\" : null, \"aria-expanded\": t.split ? t.visible ? \"true\" : \"false\" : null, variant: t.variant, size: t.size, disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        } } }, [n(\"span\", { staticClass: \"sr-only\" }, [t._v(t._s(t.toggleText))])]) : t._e(), n(\"div\", { ref: \"menu\", class: [\"dropdown-menu\", { \"dropdown-menu-right\": t.right }], attrs: { role: \"menu\", \"aria-labelledby\": t.id ? t.id + (t.split ? \"__BV_toggle_\" : \"__BV_button_\") : null }, on: { keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"tab\", 9)) return null;t.onTab(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }], mouseover: function mouseover(e) {\n          t.focusHovered(e);\n        } } }, [t._t(\"default\")], 2)], 1);\n  }, staticRenderFns: [], mixins: [clickOut, dropdown], components: { bButton: bBtn }, data: function data() {\n    return { visible: !1 };\n  }, props: { id: { type: String }, toggleText: { type: String, default: \"Toggle Dropdown\" }, size: { type: String, default: null }, variant: { type: String, default: null }, link: { type: Boolean, default: !1 } }, methods: { clickOutListener: function clickOutListener() {\n      this.visible = !1;\n    }, click: function click(t) {\n      this.disabled ? this.visible = !1 : this.split ? (this.$emit(\"click\", t), this.$root.$emit(\"shown::dropdown\", this)) : this.toggle();\n    } } },\n    dropdownItem = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"b-link\", t._b({ staticClass: \"dropdown-item\", attrs: { role: \"menuitem\" }, on: { click: function click(e) {\n          t.$emit(\"click\", e);\n        } } }, \"b-link\", t.linkProps), [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, props: props, computed: { linkProps: computed.linkProps } },\n    dropdownItemButton = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"button\", { staticClass: \"dropdown-item\", attrs: { type: \"button\", role: \"menuitem\", disabled: t.disabled }, on: { click: t.onClick } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { disabled: { type: Boolean, default: !1 } }, methods: { onClick: function onClick(t) {\n      this.$root.$emit(\"clicked::link\", this), this.$emit(\"click\", t);\n    } } },\n    dropdownDivider = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { staticClass: \"dropdown-divider\", attrs: { role: \"separator\" } });\n  }, staticRenderFns: [], props: {} },\n    dropdownHeader = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.tag, { tag: \"component\", staticClass: \"dropdown-header\", attrs: { tabindex: \"-1\" } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { tag: { type: String, default: \"h6\" } } },\n    dropdownSelect = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"dropdown-select\", class: { open: t.show, dropdown: !t.dropup, dropup: t.dropup } }, [n(\"button\", { class: [\"btn\", \"dropdown\", t.dropdownToggle, t.btnVariant, t.btnSize], attrs: { id: t.id, role: \"button\", \"aria-haspopup\": \"true\", \"aria-expanded\": \"show\", disabled: t.disabled }, on: { click: function click(e) {\n          e.preventDefault(), t.toggle(e);\n        } } }, [n(\"span\", { staticClass: \"checked-items\", domProps: { innerHTML: t._s(t.displayItem) } })]), n(\"ul\", { staticClass: \"dropdown-menu\", class: { \"dropdown-menu-right\": \"right\" == t.position }, attrs: { \"aria-labelledby\": \"dLabel\" } }, t._l(t.list, function (e) {\n      return n(\"li\", [n(\"button\", { staticClass: \"dropdown-item\", attrs: { click: t.select(e) } }, [t._v(t._s(e.text))])]);\n    }))]);\n  }, staticRenderFns: [], data: function data() {\n    return { show: !1, selected: !1 };\n  }, computed: { btnVariant: function btnVariant() {\n      return this.variant && \"default\" !== this.variant ? \"btn-\" + this.variant : \"btn-secondary\";\n    }, btnSize: function btnSize() {\n      return this.size && \"default\" !== this.size ? \"btn-\" + this.size : \"\";\n    }, dropdownToggle: function dropdownToggle() {\n      return this.caret ? \"dropdown-toggle\" : \"\";\n    }, displayItem: function displayItem() {\n      if (this.returnObject && this.model && !this.model.text || !this.returnObject && this.model && 0 === this.model.length || this.forceDefault) return this.defaultText;if (this.returnObject && this.model && this.model.text) return this.model.text;if (!this.returnObject && this.model) {\n        var t = this.model || \"\";return this.list.forEach(function (e) {\n          e.value === this.model && (t = e.text);\n        }), t;\n      }return \"\";\n    } }, props: { id: { type: String }, model: { required: !1 }, list: { type: Array, default: [], required: !0 }, caret: { type: Boolean, default: !0 }, position: { type: String, default: \"left\" }, size: { type: String, default: \"\" }, variant: { type: String, default: \"default\" }, defaultText: { type: String, default: \"Plase select one\" }, forceDefault: { type: Boolean, default: !1 }, returnObject: { type: Boolean, default: !1 }, dropup: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 } }, methods: { toggle: function toggle(t) {\n      this.show = !this.show, this.show ? (this.$root.$emit(\"shown:dropdown\", this.id), t.stopPropagation()) : this.$root.$emit(\"hidden::dropdown\", this.id);\n    }, select: function select(t) {\n      this.returnObject ? this.model = t : this.model = t.value, this.show = !1, this.$root.$emit(\"selected::dropdown\", this.id, this.model);\n    } }, created: function created() {\n    this.$root.$on(\"hide::dropdown\", function () {\n      this.show = !1;\n    });\n  } },\n    bForm = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"form\", { class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [this.inline ? \"form-inline\" : \"\"];\n    } }, props: { inline: { type: Boolean, default: !1 } } },\n    formFieldset = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"form-group\", \"row\", t.inputState], attrs: { id: t.id || null, role: \"group\", \"aria-describedby\": t.describedBy } }, [t.label ? n(\"label\", { class: [t.labelSrOnly ? \"sr-only\" : \"col-form-label\", t.labelLayout, t.labelAlignClass], attrs: { for: t.target, id: t.labelId }, domProps: { innerHTML: t._s(t.label) } }) : t._e(), n(\"div\", { ref: \"content\", class: t.inputLayout }, [t._t(\"default\"), t.feedback ? n(\"div\", { staticClass: \"form-text form-control-feedback\", attrs: { id: t.feedbackId, role: \"alert\", \"aria-live\": \"assertive\", \"aria-atomic\": \"true\" }, domProps: { innerHTML: t._s(t.feedback) } }) : t._e(), t.description ? n(\"small\", { staticClass: \"form-text text-muted\", attrs: { id: t.descriptionId }, domProps: { innerHTML: t._s(t.description) } }) : t._e()], 2)]);\n  }, staticRenderFns: [], data: function data() {\n    return { target: null };\n  }, computed: { labelId: function labelId() {\n      return this.id && this.label ? this.id + \"__BV_label_\" : null;\n    }, descriptionId: function descriptionId() {\n      return this.id && this.description ? this.id + \"__BV_description_\" : null;\n    }, feedbackId: function feedbackId() {\n      return this.id && this.feedback ? this.id + \"__BV_feedback_\" : null;\n    }, describedBy: function describedBy() {\n      return this.id && (this.label || this.feedback || this.description) ? [this.labelId, this.descriptionId, this.feedbackId].filter(function (t) {\n        return t;\n      }).join(\" \") : null;\n    }, inputState: function inputState() {\n      return this.state ? \"has-\" + this.state : \"\";\n    }, labelLayout: function labelLayout() {\n      return this.labelSrOnly ? null : this.horizontal ? \"col-sm-\" + this.labelSize : \"col-12\";\n    }, labelAlignClass: function labelAlignClass() {\n      return this.labelSrOnly ? null : this.labelTextAlign ? \"text-\" + this.labelTextAlign : null;\n    }, inputLayout: function inputLayout() {\n      return this.horizontal ? \"col-sm-\" + (12 - this.labelSize) : \"col-12\";\n    } }, methods: { updateTarget: function updateTarget() {\n      if (this.for && this.$el && this.$el.querySelector(\"#\" + this.for)) return this.for;var t = this.$refs.content;if (!t) return null;var e = t.querySelector(this.inputSelector);this.target = e && e.id ? e.id : null;\n    } }, mounted: function mounted() {\n    this.updateTarget();\n  }, updated: function updated() {\n    this.updateTarget();\n  }, props: { id: { type: String, default: null }, for: { type: String, default: null }, state: { type: String, default: null }, horizontal: { type: Boolean, default: !1 }, labelSize: { type: Number, default: 3 }, labelTextAlign: { type: String, default: null }, label: { type: String, default: null }, labelSrOnly: { type: Boolean, default: !1 }, description: { type: String, default: null }, feedback: { type: String, default: null }, inputSelector: { type: String, default: '[role=\"radiogroup\"],input,select,textarea,.form-control,.form-control-static,.dropdown,.dropup' } } },\n    formMixin = { computed: { inputClass: function inputClass() {\n      return [this.size ? \"form-control-\" + this.size : null, this.state ? \"form-control-\" + this.state : null];\n    }, custom: function custom() {\n      return !this.plain;\n    } }, props: { name: { type: String }, disabled: { type: Boolean }, plain: { type: Boolean, default: !1 }, state: { type: String }, size: { type: String }, id: { type: String } } },\n    formCheckBoxMixin = { computed: { checkboxClass: function checkboxClass() {\n      return { \"custom-control\": this.custom, \"form-check-inline\": this.inline };\n    } } },\n    formCheckbox = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"label\", { class: [t.inputClass, t.checkboxClass, t.custom ? \"custom-checkbox\" : null] }, [n(\"input\", { class: [t.custom ? \"custom-control-input\" : null], attrs: { type: \"checkbox\", id: t.id || null, name: t.name, disabled: t.disabled }, domProps: { value: t.value, checked: t.isChecked }, on: { change: t.handleChange } }), t._v(\" \"), t.custom ? n(\"span\", { staticClass: \"custom-control-indicator\", attrs: { \"aria-hidden\": \"true\" } }) : t._e(), t._v(\" \"), n(\"span\", { class: [t.custom ? \"custom-control-description\" : null] }, [t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], mixins: [formMixin, formCheckBoxMixin], model: { prop: \"checked\", event: \"change\" }, props: { value: { default: !0 }, uncheckedValue: { default: !1 }, checked: { default: !0 } }, computed: { isChecked: function isChecked() {\n      return this.checked.includes(this.value);\n    } }, methods: { handleChange: function handleChange(t) {\n      var e = this,\n          n = t.target.checked;Array.isArray(this.checked) ? this.isChecked ? this.$emit(\"change\", this.checked.filter(function (t) {\n        return t !== e.value;\n      })) : this.$emit(\"change\", this.checked.concat([this.value])) : this.$emit(\"change\", n ? this.value : this.uncheckedValue);\n    } } },\n    formOptions = { computed: { formOptions: function formOptions() {\n      var t = this,\n          e = this.options || {};return e = Array.isArray(e) ? e.map(function (e) {\n        return \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) ? { value: e[t.valueField], text: e[t.textField], disabled: e.disabled || !1 } : { text: String(e), value: e || {} };\n      }) : Object.keys(e).map(function (n) {\n        var i = e[n] || {};return \"object\" != (typeof i === \"undefined\" ? \"undefined\" : _typeof(i)) && (i = { text: String(i) }), i.value = i[t.valueField] || n, i;\n      });\n    }, selectedValue: function selectedValue() {\n      for (var t = this, e = this.formOptions, n = 0; n < e.length; n++) {\n        if (e[n].value === t.localValue) return t.returnObject ? e[n] : e[n].value;\n      }\n    } }, props: { valueField: { type: [String], default: \"value\" }, textField: { type: [String], default: \"text\" } }, watch: { localValue: function localValue(t, e) {\n      t !== e && this.$emit(\"input\", this.selectedValue);\n    }, value: function value(t, e) {\n      t !== e && (this.localValue = t);\n    } } },\n    formRadio = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [t.inputClass, t.inputState, this.stacked ? \"custom-controls-stacked\" : \"\"], attrs: { id: t.id || null, role: \"radiogroup\" } }, t._l(t.formOptions, function (e) {\n      return n(\"label\", { class: [t.checkboxClass, t.custom ? \"custom-radio\" : null] }, [n(\"input\", { directives: [{ name: \"model\", rawName: \"v-model\", value: t.localValue, expression: \"localValue\" }], ref: \"inputs\", refInFor: !0, class: t.custom ? \"custom-control-input\" : null, attrs: { id: e.id || null, type: \"radio\", name: e.name, disabled: e.disabled }, domProps: { value: e.value, checked: t._q(t.localValue, e.value) }, on: { change: function change(n) {\n            t.$emit(\"change\", t.returnObject ? e : e.value);\n          }, __c: function __c(n) {\n            t.localValue = e.value;\n          } } }), t._v(\" \"), t.custom ? n(\"span\", { staticClass: \"custom-control-indicator\", attrs: { \"aria-hidden\": \"true\" } }) : t._e(), t._v(\" \"), n(\"span\", { class: t.custom ? \"custom-control-description\" : null, domProps: { innerHTML: t._s(e.text) } })]);\n    }));\n  }, staticRenderFns: [], mixins: [formMixin, formCheckBoxMixin, formOptions], data: function data() {\n    return { localValue: this.value };\n  }, computed: { inputState: function inputState() {\n      return this.state ? \"has-\" + this.state : \"\";\n    } }, props: { value: {}, options: { type: [Array, Object], default: null, required: !0 }, stacked: { type: Boolean, default: !1 }, returnObject: { type: Boolean, default: !1 } } },\n    bFormInputStatic = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"p\", { class: [\"form-control-static\", t.inputClass], attrs: { id: t.id || null }, domProps: { innerHTML: t._s(t.staticValue) } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], mixins: [formMixin], computed: { staticValue: function staticValue() {\n      return this.formatter ? this.formatter(this.value) : this.value;\n    } }, props: { value: { default: null }, formatter: { type: Function } } },\n    formInput = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return t.static ? n(\"b-form-input-static\", { attrs: { id: t.id || null, value: t.value, formatter: t.formatter } }) : n(t.textarea ? \"textarea\" : \"input\", { ref: \"input\", tag: \"input\", class: [\"form-control\", t.inputClass], attrs: { type: t.type, name: t.name, id: t.id || null, disabled: t.disabled, readonly: t.readonly, rows: t.rows || t.rowsCount, placeholder: t.placeholder }, domProps: { value: t.value }, on: { input: function input(e) {\n          t.onInput(e.target.value);\n        }, change: function change(e) {\n          t.onChange(e.target.value);\n        }, keyup: function keyup(e) {\n          t.onKeyUp(e);\n        }, focus: function focus(e) {\n          t.$emit(\"focus\");\n        }, blur: function blur(e) {\n          t.$emit(\"blur\");\n        } } });\n  }, staticRenderFns: [], mixins: [formMixin], components: { bFormInputStatic: bFormInputStatic }, computed: { rowsCount: function rowsCount() {\n      return (this.value || \"\").toString().split(\"\\n\").length;\n    } }, methods: { format: function format(t) {\n      if (this.formatter) {\n        var e = this.formatter(t);e !== t && (t = e, this.$refs.input.value = e);\n      }return t;\n    }, onInput: function onInput(t) {\n      this.lazyFormatter || (t = this.format(t)), this.$emit(\"input\", t);\n    }, onChange: function onChange(t) {\n      t = this.format(t), this.$emit(\"input\", t), this.$emit(\"change\", t);\n    }, onKeyUp: function onKeyUp(t) {\n      this.$emit(\"keyup\", t);\n    }, focus: function focus() {\n      this.$refs.input.focus();\n    } }, props: { value: { default: null }, type: { type: String, default: \"text\" }, readonly: { type: Boolean, default: !1 }, static: { type: Boolean, default: !1 }, placeholder: { type: String, default: null }, rows: { type: Number, default: null }, textarea: { type: Boolean, default: !1 }, formatter: { type: Function }, lazyFormatter: { type: Boolean, default: !1 } } },\n    formFile = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"form-control\", t.custom ? \"custom-file\" : null, t.inputClass], attrs: { id: t.id ? t.id + \"__BV_file_outer_\" : null }, on: { dragover: function dragover(e) {\n          e.stopPropagation(), e.preventDefault(), t.dragover(e);\n        } } }, [t.dragging && t.custom ? n(\"span\", { staticClass: \"drop-here\", attrs: { \"data-drop\": t.dropLabel }, on: { dragover: function dragover(e) {\n          e.stopPropagation(), e.preventDefault(), t.dragover(e);\n        }, drop: function drop(e) {\n          e.stopPropagation(), e.preventDefault(), t.drop(e);\n        }, dragleave: function dragleave(e) {\n          e.stopPropagation(), e.preventDefault(), t.dragging = !1;\n        } } }) : t._e(), n(\"input\", { ref: \"input\", class: t.custom ? \"custom-file-input\" : \"\", attrs: { type: \"file\", name: t.name, id: t.id || null, disabled: t.disabled, accept: t.accept || null, multiple: t.multiple, webkitdirectory: t.directory, \"aria-describedby\": t.custom && t.id ? t.id + \"__BV_file_control_\" : null }, on: { change: t.onFileChange } }), t._v(\" \"), t.custom ? n(\"span\", { class: [\"custom-file-control\", t.dragging ? \"dragging\" : null, t.inputClass], attrs: { id: t.id ? t.id + \"__BV_file_control_\" : null, \"data-choose\": t.computedChooseLabel, \"data-selected\": t.selectedLabel } }) : t._e()]);\n  }, staticRenderFns: [], _scopeId: \"data-v-c68bd5f8\", mixins: [formMixin], data: function data() {\n    return { selectedFile: null, dragging: !1 };\n  }, computed: { selectedLabel: function selectedLabel() {\n      return this.selectedFile && 0 !== this.selectedFile.length ? this.multiple ? 1 === this.selectedFile.length ? this.selectedFile[0].name : this.selectedFormat.replace(\":names\", this.selectedFile.map(function (t) {\n        return t.name;\n      }).join(\",\")).replace(\":count\", this.selectedFile.length) : this.selectedFile.name : this.placeholder || \"No file chosen\";\n    }, computedChooseLabel: function computedChooseLabel() {\n      return this.chooseLabel || (this.multiple ? \"Choose Files\" : \"Choose File\");\n    } }, watch: { selectedFile: function selectedFile(t, e) {\n      t !== e && (!t && this.multiple ? this.$emit(\"input\", []) : this.$emit(\"input\", t));\n    } }, methods: { reset: function reset() {\n      try {\n        this.$refs.input.value = \"\";\n      } catch (t) {}this.$refs.input.type = \"\", this.$refs.input.type = \"file\", this.selectedFile = this.multiple ? [] : null;\n    }, onFileChange: function onFileChange(t) {\n      var e = this;this.$emit(\"change\", t);var n = t.dataTransfer && t.dataTransfer.items;if (!n || this.noTraverse) this.setFiles(t.target.files || t.dataTransfer.files);else {\n        for (var i = [], o = 0; o < n.length; o++) {\n          var r = n[o].webkitGetAsEntry();r && i.push(e.traverseFileTree(r));\n        }Promise.all(i).then(function (t) {\n          e.setFiles(Array.prototype.concat.apply([], t));\n        });\n      }\n    }, setFiles: function setFiles(t) {\n      var e = this;if (t) {\n        if (this.multiple) {\n          for (var n = [], i = 0; i < t.length; i++) {\n            t[i].type.match(e.accept) && n.push(t[i]);\n          }this.selectedFile = n;\n        } else this.selectedFile = t[0];\n      } else this.selectedFile = null;\n    }, dragover: function dragover(t) {\n      !this.noDrop && this.custom && (this.dragging = !0, t.dataTransfer.dropEffect = \"copy\");\n    }, drop: function drop(t) {\n      this.noDrop || (this.dragging = !1, t.dataTransfer.files && t.dataTransfer.files.length > 0 && this.onFileChange(t));\n    }, traverseFileTree: function traverseFileTree(t, e) {\n      var n = this;return new Promise(function (i) {\n        e = e || \"\", t.isFile ? t.file(function (t) {\n          t.$path = e, i(t);\n        }) : t.isDirectory && t.createReader().readEntries(function (o) {\n          for (var r = [], s = 0; s < o.length; s++) {\n            r.push(n.traverseFileTree(o[s], e + t.name + \"/\"));\n          }Promise.all(r).then(function (t) {\n            i(Array.prototype.concat.apply([], t));\n          });\n        });\n      });\n    } }, props: { accept: { type: String, default: \"\" }, placeholder: { type: String, default: null }, chooseLabel: { type: String, default: null }, multiple: { type: Boolean, default: !1 }, directory: { type: Boolean, default: !1 }, noTraverse: { type: Boolean, default: !1 }, selectedFormat: { type: String, default: \":count Files\" }, noDrop: { type: Boolean, default: !1 }, dropLabel: { type: String, default: \"Drop files here\" } } },\n    formSelect = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"select\", { directives: [{ name: \"model\", rawName: \"v-model\", value: t.localValue, expression: \"localValue\" }], ref: \"input\", class: [\"form-control\", t.inputClass, t.custom ? \"custom-select\" : null], attrs: { name: t.name, id: t.id || null, disabled: t.disabled }, on: { change: function change(e) {\n          var n = Array.prototype.filter.call(e.target.options, function (t) {\n            return t.selected;\n          }).map(function (t) {\n            return \"_value\" in t ? t._value : t.value;\n          });t.localValue = e.target.multiple ? n : n[0];\n        } } }, t._l(t.formOptions, function (e) {\n      return n(\"option\", { attrs: { disabled: e.disabled }, domProps: { value: e.value, innerHTML: t._s(e.text) } });\n    }));\n  }, staticRenderFns: [], mixins: [formMixin, formOptions], data: function data() {\n    return { localValue: this.value };\n  }, props: { value: {}, options: { type: [Array, Object], required: !0 }, returnObject: { type: Boolean, default: !1 } } },\n    jumbotron = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"jumbotron\", t.fluid ? \"jumbotron-fluid\" : null] }, [n(\"div\", { class: t.containerFluid ? \"container-fluid\" : \"container\" }, [t.header ? n(\"h1\", { staticClass: \"display-3\", domProps: { innerHTML: t._s(t.header) } }) : t._e(), t.lead ? n(\"p\", { staticClass: \"lead\", domProps: { innerHTML: t._s(t.lead) } }) : t._e(), t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], computed: {}, props: { fluid: { type: Boolean, default: !1 }, containerFluid: { type: Boolean, default: !1 }, header: { type: String, default: null }, lead: { type: String, default: null } } },\n    badge = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"span\", { class: [\"badge\", t.badgeVariant, t.badgePill] }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { badgeVariant: function badgeVariant() {\n      return this.variant && \"default\" !== this.variant ? \"badge-\" + this.variant : \"badge-default\";\n    }, badgePill: function badgePill() {\n      return this.pill ? \"badge-pill\" : \"\";\n    } }, props: { variant: { type: String, default: \"default\" }, pill: { type: Boolean, default: !1 } } },\n    listGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.tag, { tag: \"component\", class: [\"list-group\", t.flush ? \"list-group-flush\" : null] }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { tag: { type: String, default: \"div\" }, flush: { type: Boolean, default: !1 } } },\n    linkProps$1 = Object.assign(omitLinkProps(\"href\", \"to\"), { href: { type: props.href.type }, to: { type: props.to.type }, tag: { type: props.tag.type } }),\n    actionTags = [\"a\", \"router-link\", \"button\", \"b-link\"],\n    listGroupItem = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.myTag, t._b({ ref: \"item\", tag: \"component\", class: t.classObject }, \"component\", t.conditionalLinkProps), [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, computed: { linkProps: computed.linkProps, classObject: function classObject() {\n      return [\"list-group-item\", this.listState, this.active ? \"active\" : null, this.disabled ? \"disabled\" : null, this.isAction ? \"list-group-item-action\" : null];\n    }, isAction: function isAction() {\n      return !1 !== this.action && !!(this.action || this.to || this.href || actionTags.includes(this.tag));\n    }, listState: function listState() {\n      return this.variant ? \"list-group-item-\" + this.variant : null;\n    }, myTag: function myTag() {\n      return this.tag ? this.tag : this.to || this.href ? \"b-link\" : \"div\";\n    }, conditionalLinkProps: function conditionalLinkProps() {\n      return \"b-link\" !== this.myTag ? {} : this.linkProps;\n    } }, props: Object.assign(linkProps$1, { action: { type: Boolean, default: null }, variant: { type: String, default: null } }) },\n    media = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"media\" }, [t.rightAlign ? t._e() : n(\"div\", { class: [\"d-flex\", \"mr-3\", t.verticalAlignClass] }, [t._t(\"aside\")], 2), n(\"div\", { staticClass: \"media-body\" }, [t._t(\"default\")], 2), t.rightAlign ? n(\"div\", { class: [\"d-flex\", \"ml-3\", t.verticalAlignClass] }, [t._t(\"aside\")], 2) : t._e()]);\n  }, staticRenderFns: [], computed: { verticalAlignClass: function verticalAlignClass() {\n      return \"align-self-\" + this.verticalAlign;\n    } }, props: { rightAlign: { type: Boolean, default: !1 }, verticalAlign: { type: String, default: \"top\" } } },\n    FOCUS_SELECTOR = [\"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"a:not([disabled]):not(.disabled)\", \"[tabindex]:not([disabled]):not(.disabled)\"].join(\",\"),\n    modal = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", [n(\"transition-group\", { attrs: { \"enter-class\": \"hidden\", \"enter-to-class\": \"\", \"enter-active-class\": \"\", \"leave-class\": \"show\", \"leave-active-class\": \"\", \"leave-to-class\": \"hidden\" }, on: { \"after-enter\": t.focusFirst } }, [n(\"div\", { directives: [{ name: \"show\", rawName: \"v-show\", value: t.is_visible, expression: \"is_visible\" }], key: \"modal\", ref: \"modal\", class: [\"modal\", { fade: !t.noFade, show: t.is_visible }], attrs: { id: t.id || null, role: \"dialog\" }, on: { click: function click(e) {\n          t.onClickOut();\n        }, keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc();\n        } } }, [n(\"div\", { class: [\"modal-dialog\", \"modal-\" + t.size] }, [n(\"div\", { ref: \"content\", staticClass: \"modal-content\", attrs: { tabindex: \"-1\", role: \"document\", \"aria-labelledby\": t.hideHeader || !t.id ? null : t.id + \"__BV_title_\", \"aria-describedby\": t.id ? t.id + \"__BV_body_\" : null }, on: { click: function click(t) {\n          t.stopPropagation();\n        } } }, [t.hideHeader ? t._e() : n(\"header\", { ref: \"header\", staticClass: \"modal-header\" }, [t._t(\"modal-header\", [n(\"h5\", { staticClass: \"modal-title\", attrs: { id: t.id ? t.id + \"__BV_title_\" : null } }, [t._t(\"modal-title\", [t._v(t._s(t.title))])], 2), t.hideHeaderClose ? t._e() : n(\"button\", { staticClass: \"close\", attrs: { type: \"button\", \"aria-label\": t.headerCloseLabel }, on: { click: t.hide } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" } }, [t._v(\"×\")])])])], 2), n(\"div\", { ref: \"body\", staticClass: \"modal-body\", attrs: { id: t.id ? t.id + \"__BV_body_\" : null } }, [t._t(\"default\")], 2), t.hideFooter ? t._e() : n(\"footer\", { ref: \"footer\", staticClass: \"modal-footer\" }, [t._t(\"modal-footer\", [t.okOnly ? t._e() : n(\"b-btn\", { attrs: { variant: \"secondary\", size: t.buttonSize }, on: { click: function click(e) {\n          t.hide(!1);\n        } } }, [t._t(\"modal-cancel\", [t._v(t._s(t.closeTitle))])], 2), n(\"b-btn\", { attrs: { variant: \"primary\", size: t.buttonSize, disabled: t.okDisabled }, on: { click: function click(e) {\n          t.hide(!0);\n        } } }, [t._t(\"modal-ok\", [t._v(t._s(t.okTitle))])], 2)])], 2)])])]), t.is_visible ? n(\"div\", { key: \"modal-backdrop\", class: [\"modal-backdrop\", { fade: !t.noFade, show: t.is_visible }] }) : t._e()])], 1);\n  }, staticRenderFns: [], _scopeId: \"data-v-1b4cbb68\", components: { bBtn: bBtn }, data: function data() {\n    return { is_visible: !1, return_focus: this.returnFocus || null };\n  }, model: { prop: \"visible\", event: \"change\" }, computed: { body: function body() {\n      if (\"undefined\" != typeof document) return document.querySelector(\"body\");\n    } }, watch: { visible: function visible(t, e) {\n      t !== e && (t ? this.show() : this.hide());\n    } }, props: { id: { type: String, default: null }, title: { type: String, default: \"\" }, size: { type: String, default: \"md\" }, buttonSize: { type: String, default: \"md\" }, noFade: { type: Boolean, default: !1 }, noCloseOnBackdrop: { type: Boolean, default: !1 }, noCloseOnEsc: { type: Boolean, default: !1 }, noAutoFocus: { type: Boolean, default: !1 }, hideHeader: { type: Boolean, default: !1 }, hideFooter: { type: Boolean, default: !1 }, okOnly: { type: Boolean, default: !1 }, okDisabled: { type: Boolean, default: !1 }, hideHeaderClose: { type: Boolean, default: !1 }, visible: { type: Boolean, default: !1 }, returnFocus: { default: null }, headerCloseLabel: { type: String, default: \"Close\" }, closeTitle: { type: String, default: \"Close\" }, okTitle: { type: String, default: \"OK\" } }, methods: { show: function show() {\n      this.is_visible || (this.$emit(\"show\"), this.is_visible = !0, this.$root.$emit(\"shown::modal\", this.id), this.body.classList.add(\"modal-open\"), this.$emit(\"shown\"), this.$emit(\"change\", !0), \"undefined\" != typeof document && (document.removeEventListener(\"focusin\", this.enforceFocus, !1), document.addEventListener(\"focusin\", this.enforceFocus, !1)));\n    }, hide: function hide(t) {\n      if (this.is_visible) {\n        var e = !1,\n            n = { isOK: t, cancel: function cancel() {\n            e = !0;\n          } };this.$emit(\"change\", !1), this.$emit(\"hide\", n), !0 === t ? this.$emit(\"ok\", n) : !1 === t && this.$emit(\"cancel\", n), e || (\"undefined\" != typeof document && (document.removeEventListener(\"focusin\", this.enforceFocus, !1), this.returnFocusTo()), this.is_visible = !1, this.$root.$emit(\"hidden::modal\", this.id), this.$emit(\"hidden\", n), this.body.classList.remove(\"modal-open\"));\n      }\n    }, onClickOut: function onClickOut() {\n      this.is_visible && !this.noCloseOnBackdrop && this.hide();\n    }, onEsc: function onEsc() {\n      this.is_visible && !this.noCloseOnEsc && this.hide();\n    }, focusFirst: function focusFirst() {\n      var t = this;\"undefined\" != typeof document && this.$nextTick(function () {\n        if (!document.activeElement || !t.$refs.content.contains(document.activeElement)) {\n          var e;t.noAutoFocus || (t.$refs.body && (e = findFirstVisible(t.$refs.body, FOCUS_SELECTOR)), !e && t.$refs.footer && (e = findFirstVisible(t.$refs.footer, FOCUS_SELECTOR)), !e && t.$refs.header && (e = findFirstVisible(t.$refs.header, FOCUS_SELECTOR))), e || (e = t.$refs.content), e && e.focus && e.focus();\n        }\n      });\n    }, returnFocusTo: function returnFocusTo() {\n      var t = this.returnFocus || this.return_focus || null;t && (\"string\" == typeof t && (t = document.querySelector(t)), t && t.$el && \"function\" == typeof t.$el.focus ? t.$el.focus() : t && \"function\" == typeof t.focus && t.focus());\n    }, enforceFocus: function enforceFocus(t) {\n      this.is_visible && document !== t.target && this.$refs.content && this.$refs.content !== t.target && !this.$refs.content.contains(t.target) && this.$refs.content.focus();\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"show::modal\", function (e, n) {\n      e === t.id && (t.return_focus = n || null, t.show());\n    }), this.$root.$on(\"hide::modal\", function (e) {\n      e === t.id && t.hide();\n    });\n  }, mounted: function mounted() {\n    !0 === this.visible && this.show();\n  }, destroyed: function destroyed() {\n    \"undefined\" != typeof document && document.removeEventListener(\"focusin\", this.enforceFocus, !1);\n  } },\n    nav = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.type, { tag: \"component\", class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return { nav: !0, \"navbar-nav\": this.isNavBar, \"nav-tabs\": this.tabs, \"nav-pills\": this.pills, \"flex-column\": this.vertical, \"nav-fill\": this.fill, \"nav-justified\": this.justified };\n    } }, props: { type: { type: String, default: \"ul\" }, fill: { type: Boolean, default: !1 }, justified: { type: Boolean, default: !1 }, tabs: { type: Boolean, default: !1 }, pills: { type: Boolean, default: !1 }, vertical: { type: Boolean, default: !1 }, isNavBar: { type: Boolean, default: !1 } } },\n    navItem = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"li\", { staticClass: \"nav-item\" }, [n(\"b-link\", t._b({ staticClass: \"nav-link\", on: { click: function click(e) {\n          t.$emit(\"click\", e);\n        } } }, \"b-link\", t.linkProps), [t._t(\"default\")], 2)], 1);\n  }, staticRenderFns: [], components: { bLink: bLink }, props: props, computed: { linkProps: computed.linkProps } },\n    navItemDropdown = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"li\", { class: [\"nav-item\", \"dropdown\", { dropup: t.dropup, show: t.visible }], attrs: { id: t.id || null } }, [n(\"a\", { ref: \"button\", class: [\"nav-link\", t.dropdownToggle, { disabled: t.disabled }], attrs: { href: \"#\", id: t.id ? t.id + \"__BV_button_\" : null, \"aria-haspopup\": \"true\", \"aria-expanded\": t.visible ? \"true\" : \"false\", disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        }] } }, [t._t(\"text\", [n(\"span\", { domProps: { innerHTML: t._s(t.text) } })])], 2), n(\"div\", { ref: \"menu\", class: [\"dropdown-menu\", { \"dropdown-menu-right\": t.right }], attrs: { role: \"menu\", \"aria-labelledby\": t.id ? t.id + \"__BV_button_\" : null }, on: { keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"tab\", 9)) return null;t.onTab(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }], mouseover: function mouseover(e) {\n          t.focusHovered(e);\n        } } }, [t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], mixins: [clickOut, dropdown], data: function data() {\n    return { visible: !1 };\n  }, computed: { dropdownToggle: function dropdownToggle() {\n      return this.caret ? \"dropdown-toggle\" : \"\";\n    } }, props: { id: { type: String }, caret: { type: Boolean, default: !0 } }, methods: { clickOutListener: function clickOutListener() {\n      this.visible = !1;\n    } } },\n    navToggle = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"button\", { class: t.classObject, attrs: { type: \"button\", \"aria-label\": t.label, \"aria-controls\": t.target.id ? t.target.id : t.target, \"aria-expanded\": t.toggleState ? \"true\" : \"false\" }, on: { click: t.onclick } }, [n(\"span\", { staticClass: \"navbar-toggler-icon\" })]);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"navbar-toggler\", \"navbar-toggler-\" + this.position];\n    } }, data: function data() {\n    return { toggleState: !1 };\n  }, props: { label: { type: String, default: \"Toggle navigation\" }, position: { type: String, default: \"right\" }, target: { required: !0 } }, methods: { onclick: function onclick() {\n      var t = this.target;t.toggle && t.toggle(), this.$root.$emit(\"collapse::toggle\", this.target);\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"collapse::toggle::state\", function (e, n) {\n      e !== t.target && e !== t.target.id || (t.toggleState = n);\n    });\n  } },\n    navbar = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"nav\", { class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"navbar\", this.type ? \"navbar-\" + this.type : null, this.variant ? \"bg-\" + this.variant : null, this.fixed ? \"fixed-\" + this.fixed : null, this.sticky ? \"sticky-top\" : null, this.toggleable ? this.toggleableClass : null];\n    }, toggleableClass: function toggleableClass() {\n      var t = \"navbar-toggleable\";return this.toggleBreakpoint && (t += \"-\" + this.toggleBreakpoint), t;\n    } }, props: { type: { type: String, default: \"light\" }, variant: { type: String }, toggleable: { type: Boolean, default: !1 }, toggleBreakpoint: { type: String, default: null }, fixed: { type: String }, sticky: { type: Boolean, default: !1 } } },\n    navText = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"span\", { staticClass: \"navbar-text\" }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: {} },\n    navForm = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"b-form\", { attrs: { id: t.id || null, inline: \"\" } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: [bForm], props: { id: { type: String } } },\n    ELLIPSIS_THRESHOLD = 3,\n    pagination = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"ul\", { class: [\"pagination\", t.btnSize], attrs: { role: t.role, \"aria-disabled\": t.disabled ? \"true\" : \"false\", \"aria-label\": t.ariaLabel ? t.ariaLabel : null }, on: { focusin: function focusin(e) {\n          if (e.target !== e.currentTarget) return null;t.focusCurrent(e);\n        }, keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : (e.preventDefault(), void t.focusPrev(e)) : null;\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : (e.preventDefault(), void t.focusNext(e)) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"left\", 37)) && e.shiftKey ? \"button\" in e && 0 !== e.button ? null : (e.preventDefault(), void t.focusFirst(e)) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"right\", 39)) && e.shiftKey ? \"button\" in e && 2 !== e.button ? null : (e.preventDefault(), void t.focusLast(e)) : null;\n        }] } }, [t.hideGotoEndButtons ? t._e() : [t.isActive(1) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.firstText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelFirstPage, tabindex: \"-1\", href: \"#\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, 1);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, 1);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, 1);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.firstText) } })])])], t.isActive(1) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.prevText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelPrevPage, tabindex: \"-1\", href: \"#\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, t.currentPage - 1);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, t.currentPage - 1);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, t.currentPage - 1);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.prevText) } })])]), t.showFirstDots ? n(\"li\", { staticClass: \"page-item disabled hidden-xs-down\", attrs: { role: \"seperator\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.ellipsisText) } })]) : t._e(), t._l(t.pageList, function (e) {\n      return n(\"li\", { key: e.number, class: t.pageItemClasses(e) }, [n(\"a\", { class: t.pageLinkClasses(e), attrs: { role: t.buttonRole, disabled: t.disabled, \"aria-disabled\": t.disabled ? \"true\" : \"false\", \"aria-label\": t.labelPage + \" \" + e.number, \"aria-current\": t.isActive(e) ? \"true\" : \"false\", \"aria-posinset\": e.number, \"aria-setsize\": t.numberOfPages, tabindex: \"-1\" }, on: { click: function click(n) {\n            n.preventDefault(), t.setPage(n, e.number);\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.preventDefault(), t.setPage(n, e.number);\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.preventDefault(), t.setPage(n, e.number);\n          }] } }, [t._v(t._s(e.number))])]);\n    }), t.showLastDots ? n(\"li\", { staticClass: \"page-item disabled hidden-xs-down\", attrs: { role: \"seperator\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.ellipsisText) } })]) : t._e(), t.isActive(t.numberOfPages) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.nextText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelNextPage, tabindex: \"-1\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, t.currentPage + 1);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, t.currentPage + 1);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, t.currentPage + 1);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.nextText) } })])]), t.hideGotoEndButtons ? t._e() : [t.isActive(t.numberOfPages) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.lastText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelLastPage, tabindex: \"-1\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, t.numberOfPages);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, t.numberOfPages);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, t.numberOfPages);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.lastText) } })])])]], 2);\n  }, staticRenderFns: [], _scopeId: \"data-v-2792960b\", data: function data() {\n    return { showFirstDots: !1, showLastDots: !1, currentPage: this.value };\n  }, computed: { numberOfPages: function numberOfPages() {\n      var t = Math.ceil(this.totalRows / this.perPage);return t < 1 ? 1 : t;\n    }, btnSize: function btnSize() {\n      return this.size ? \"pagination-\" + this.size : \"\";\n    }, pageList: function pageList() {\n      this.currentPage > this.numberOfPages ? this.currentPage = this.numberOfPages : this.currentPage < 1 && (this.currentPage = 1), this.showFirstDots = !1, this.showLastDots = !1;var t = this.limit,\n          e = 1;this.numberOfPages <= this.limit ? t = this.numberOfPages : this.currentPage < this.limit - 1 && this.limit > ELLIPSIS_THRESHOLD ? this.hideEllipsis || (t = this.limit - 1, this.showLastDots = !0) : this.numberOfPages - this.currentPage + 2 < this.limit && this.limit > ELLIPSIS_THRESHOLD ? (this.hideEllipsis || (this.showFirstDots = !0, t = this.limit - 1), e = this.numberOfPages - t + 1) : (this.limit > ELLIPSIS_THRESHOLD && !this.hideEllipsis && (this.showFirstDots = !0, this.showLastDots = !0, t = this.limit - 2), e = this.currentPage - Math.floor(t / 2)), e < 1 ? e = 1 : e > this.numberOfPages - t && (e = this.numberOfPages - t + 1);var n = makePageArray(e, t);if (n.length > 3) {\n        var i = this.currentPage - e;if (0 === i) for (var o = 3; o < n.length; o++) {\n          n[o].className = \"hidden-xs-down\";\n        } else if (i === n.length - 1) for (var r = 0; r < n.length - 3; r++) {\n          n[r].className = \"hidden-xs-down\";\n        } else {\n          for (var s = 0; s < i - 1; s++) {\n            n[s].className = \"hidden-xs-down\";\n          }for (var a = n.length - 1; a > i + 1; a--) {\n            n[a].className = \"hidden-xs-down\";\n          }\n        }\n      }return n;\n    } }, methods: { isActive: function isActive(t) {\n      return t === this.currentPage;\n    }, pageItemClasses: function pageItemClasses(t) {\n      var e = this.isActive(t.number);return [\"page-item\", this.disabled ? \"disabled\" : \"\", e ? \"active\" : \"\", t.className];\n    }, pageLinkClasses: function pageLinkClasses(t) {\n      var e = this.isActive(t.number);return [\"page-link\", this.disabled ? \"disabled\" : \"\", e ? \"active\" : \"\"];\n    }, setPage: function setPage(t, e) {\n      var n = this;if (this.disabled) return t.preventDefault(), void t.stopPropagation();e > this.numberOfPages ? this.currentPage = this.numberOfPages : e < 1 ? this.currentpage = 1 : this.currentPage = e, this.$nextTick(function () {\n        isVisible$1(t.target) && t.target.focus ? t.target.focus() : n.focusCurrent();\n      }), this.$emit(\"change\", this.currentPage);\n    }, getButtons: function getButtons() {\n      return Array.prototype.slice.call(this.$el.querySelectorAll(\"a.page-link\")).filter(function (t) {\n        return isVisible$1(t);\n      });\n    }, setBtnFocus: function setBtnFocus(t) {\n      this.$nextTick(function () {\n        t.focus();\n      });\n    }, focusFirst: function focusFirst() {\n      var t = this.getButtons().find(function (t) {\n        return !t.disabled;\n      });t && t.focus && t !== document.activeElement && this.setBtnFocus(t);\n    }, focusLast: function focusLast() {\n      var t = this.getButtons().reverse().find(function (t) {\n        return !t.disabled;\n      });t && t.focus && t !== document.activeElement && this.setBtnFocus(t);\n    }, focusCurrent: function focusCurrent() {\n      var t = this,\n          e = this.getButtons().find(function (e) {\n        return parseInt(e.getAttribute(\"aria-posinset\"), 10) === t.currentPage;\n      });e && e.focus ? this.setBtnFocus(e) : this.focusFirst();\n    }, focusPrev: function focusPrev() {\n      var t = this.getButtons(),\n          e = t.indexOf(document.activeElement);e > 0 && !t[e - 1].disabled && t[e - 1].focus && this.setBtnFocus(t[e - 1]);\n    }, focusNext: function focusNext() {\n      var t = this.getButtons(),\n          e = t.indexOf(document.activeElement);e < t.length - 1 && !t[e + 1].disabled && t[e + 1].focus && this.setBtnFocus(t[e + 1]);\n    } }, watch: { currentPage: function currentPage(t, e) {\n      t !== e && this.$emit(\"input\", t);\n    }, value: function value(t, e) {\n      t !== e && (this.currentPage = t);\n    } }, props: { disabled: { type: Boolean, default: !1 }, value: { type: Number, default: 1 }, limit: { type: Number, default: 5 }, perPage: { type: Number, default: 20 }, totalRows: { type: Number, default: 20 }, size: { type: String, default: \"md\" }, hideGotoEndButtons: { type: Boolean, default: !1 }, ariaLabel: { type: String, default: \"Pagination\" }, labelFirstPage: { type: String, default: \"Goto first page\" }, firstText: { type: String, default: \"&laquo\" }, labelPrevPage: { type: String, default: \"Goto previous page\" }, prevText: { type: String, default: \"&lsaquo;\" }, labelNextPage: { type: String, default: \"Goto next page\" }, nextText: { type: String, default: \"&rsaquo;\" }, labelLastPage: { type: String, default: \"Goto last page\" }, lastText: { type: String, default: \"&raquo;\" }, labelPage: { type: String, default: \"Goto page\" }, hideEllipsis: { type: Boolean, default: !1 }, ellipsisText: { type: String, default: \"&hellip;\" }, role: { type: String, default: \"group\" }, buttonRole: { type: String, default: \"button\" } } },\n    TRIGGER_LISTENERS = { click: { click: \"toggle\" }, hover: { mouseenter: \"show\", mouseleave: \"hide\" }, focus: { focus: \"show\", blur: \"hide\" } },\n    PLACEMENT_PARAMS = { top: \"bottom center\", bottom: \"top center\", left: \"middle right\", right: \"middle left\" },\n    TETHER_CLASS_PREFIX = \"bs-tether\",\n    TETHER_CLASSES = { element: !1, enabled: !1 },\n    TRANSITION_DURATION = 150,\n    popover$1 = { props: { constraints: { type: Array, default: function _default() {\n        return [];\n      } }, debounce: { type: [Number], default: 300, validator: function validator(t) {\n        return t >= 0;\n      } }, delay: { type: [Number, Object], default: 0, validator: function validator(t) {\n        return \"number\" == typeof t ? t >= 0 : null !== t && \"object\" == (typeof t === \"undefined\" ? \"undefined\" : _typeof(t)) && \"number\" == typeof t.show && \"number\" == typeof t.hide && t.show >= 0 && t.hide >= 0;\n      } }, offset: { type: String, default: \"0 0\", validator: function validator(t) {\n        return (/^((0\\s?)|([+-]?[0-9]+(px|%)\\s?)){2}$/.test(t)\n        );\n      } }, placement: { type: String, default: \"top\", validator: function validator(t) {\n        return -1 !== Object.keys(PLACEMENT_PARAMS).indexOf(t);\n      } }, popoverStyle: { type: Object, default: null }, show: { type: Boolean, default: null }, targetOffset: { type: String, default: \"0 0\", validator: function validator(t) {\n        return (/^((0\\s?)|([+-]?[0-9]+(px|%)\\s?)){2}$/.test(t)\n        );\n      } }, triggers: { type: [Boolean, String, Array], default: function _default() {\n        return [\"click\", \"focus\"];\n      }, validator: function validator(t) {\n        if (!1 === t || \"\" === t) return !0;if (\"string\" == typeof t) return -1 !== Object.keys(TRIGGER_LISTENERS).indexOf(t);if (Array.isArray(t)) {\n          var e = Object.keys(TRIGGER_LISTENERS);return t.forEach(function (t) {\n            if (-1 === e.indexOf(t)) return !1;\n          }), !0;\n        }return !1;\n      } } }, data: function data() {\n    return { triggerState: this.show, classState: this.show, lastEvent: null };\n  }, computed: { normalizedTriggers: function normalizedTriggers() {\n      return !1 === this.triggers ? [] : \"string\" == typeof this.triggers ? [this.triggers] : this.triggers;\n    }, popoverAlignment: function popoverAlignment() {\n      return this.placement && \"default\" !== this.placement ? \"popover-\" + this.placement : \"popover-top\";\n    }, showState: function showState() {\n      return !1 !== this.show && (this.triggerState || this.show);\n    } }, watch: { constraints: function constraints() {\n      this.setOptions();\n    }, normalizedTriggers: function normalizedTriggers(t, e) {\n      this.updateListeners(t, e);\n    }, offset: function offset() {\n      this.setOptions();\n    }, placement: function placement() {\n      this.setOptions();\n    }, showState: function showState(t) {\n      var e = this,\n          n = this.getDelay(t);clearTimeout(this.$data._timeout), n ? this.$data._timeout = setTimeout(function () {\n        return e.togglePopover(t);\n      }, n) : this.togglePopover(t);\n    } }, methods: { addListener: function addListener(t) {\n      var e = this;for (var n in TRIGGER_LISTENERS[t]) {\n        e.$data._trigger.addEventListener(n, function (t) {\n          return e.eventHandler(t);\n        });\n      }\n    }, destroyTether: function destroyTether() {\n      if (this.$data._tether && !this.showState) {\n        this.$data._tether.destroy(), this.$data._tether = null;var t = new RegExp(\"(^|[^-]\\\\b)(\" + TETHER_CLASS_PREFIX + \"\\\\S*)\", \"g\");this.$data._trigger.className = this.$data._trigger.className.replace(t, \"\");\n      }\n    }, eventHandler: function eventHandler(t) {\n      var e = this;if (!(this.normalizedTriggers.length > 1 && this.debounce > 0 && null !== this.lastEvent && t.timeStamp <= this.lastEvent + this.debounce)) for (var n in TRIGGER_LISTENERS) {\n        for (var i in TRIGGER_LISTENERS[n]) {\n          if (i === t.type) {\n            var o = TRIGGER_LISTENERS[n][i];return void ((\"toggle\" === o || e.triggerState && \"hide\" === o || !e.triggerState && \"show\" === o) && (e.triggerState = !e.triggerState, e.lastEvent = t.timeStamp));\n          }\n        }\n      }\n    }, getDelay: function getDelay(t) {\n      return \"object\" == _typeof(this.delay) ? t ? this.delay.show : this.delay.hide : this.delay;\n    }, getTetherOptions: function getTetherOptions() {\n      return { attachment: PLACEMENT_PARAMS[this.placement], element: this.$data._popover, target: this.$data._trigger, classes: TETHER_CLASSES, classPrefix: TETHER_CLASS_PREFIX, offset: this.offset, constraints: this.constraints, targetOffset: this.targetOffset };\n    }, hidePopover: function hidePopover() {\n      var t = this;this.classState = !1, clearTimeout(this.$data._timeout), this.$data._timeout = setTimeout(function () {\n        t.$data._popover.style.display = \"none\", t.destroyTether();\n      }, TRANSITION_DURATION);\n    }, refreshPosition: function refreshPosition() {\n      var t = this;this.$data._tether && this.$nextTick(function () {\n        t.$data._tether.position();\n      });\n    }, removeListener: function removeListener(t) {\n      var e = this;for (var n in TRIGGER_LISTENERS[t]) {\n        e.$data._trigger.removeEventListener(n, function (t) {\n          return e.eventHandler(t);\n        });\n      }\n    }, setOptions: function setOptions() {\n      this.$data._tether && this.$data._tether.setOptions(this.getTetherOptions());\n    }, showPopover: function showPopover() {\n      var t = this;clearTimeout(this.$data._timeout), this.$data._tether || (this.$data._tether = new __WEBPACK_IMPORTED_MODULE_0_tether___default.a(this.getTetherOptions())), this.$data._popover.style.display = \"block\", this.refreshPosition(), this.$nextTick(function () {\n        t.classState = !0;\n      });\n    }, togglePopover: function togglePopover(t) {\n      this.$emit(\"showChange\", t), t ? (this.showPopover(), this.$root.$emit(\"shown::popover\")) : (this.hidePopover(), this.$root.$emit(\"hidden::popover\"));\n    }, updateListeners: function updateListeners(t, e) {\n      var n = this;void 0 === e && (e = []);var i = [],\n          o = [];t.forEach(function (t) {\n        -1 === e.indexOf(t) && i.push(t);\n      }), e.forEach(function (e) {\n        -1 === t.indexOf(e) && o.push(e);\n      }), i.forEach(function (t) {\n        return n.addListener(t);\n      }), o.forEach(function (t) {\n        return n.removeListener(t);\n      });\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"hide::popover\", function () {\n      t.triggerState = !1;\n    });\n  }, mounted: function mounted() {\n    this.$data._trigger = this.$refs.trigger.children[0] || this.$refs.trigger, this.$data._popover = this.$refs.popover, this.$data._popover.style.display = \"none\", this.$data._tether = new __WEBPACK_IMPORTED_MODULE_0_tether___default.a(this.getTetherOptions()), this.$data._timeout = 0, this.updateListeners(this.normalizedTriggers), this.showState && this.showPopover();\n  }, updated: function updated() {\n    this.refreshPosition();\n  }, beforeDestroy: function beforeDestroy() {\n    var t = this;this.normalizedTriggers.forEach(function (e) {\n      return t.removeListener(e);\n    }), clearTimeout(this.$data._timeout), this.destroyTether();\n  }, destroyed: function destroyed() {\n    this.$data._popover.parentElement === document.body && document.body.removeChild(this.$data._popover);\n  } },\n    popover = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", [n(\"span\", { ref: \"trigger\" }, [t._t(\"default\")], 2), n(\"div\", { ref: \"popover\", class: [\"popover\", \"fade\", t.classState ? \"show\" : \"\", t.popoverAlignment], style: t.popoverStyle, attrs: { tabindex: \"-1\" }, on: { focus: function focus(e) {\n          t.$emit(\"focus\");\n        }, blur: function blur(e) {\n          t.$emit(\"blur\");\n        } } }, [n(\"div\", { staticClass: \"popover-arrow\" }), t.title ? n(\"h3\", { staticClass: \"popover-title\", domProps: { innerHTML: t._s(t.title) } }) : t._e(), n(\"div\", { staticClass: \"popover-content\" }, [n(\"div\", { staticClass: \"popover-content-wrapper\" }, [t._t(\"content\", [n(\"span\", { domProps: { innerHTML: t._s(t.content) } })])], 2)])])]);\n  }, staticRenderFns: [], mixins: [popover$1], props: { title: { type: String, default: \"\" }, content: { type: String, default: \"\" }, popoverStyle: { type: Object, default: null } } },\n    progress = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"progress\" }, [n(\"transition\", [n(\"div\", { class: t.classObject, style: t.styleObject, attrs: { role: \"progressbar\", \"aria-valuenow\": t.value, \"aria-valuemin\": 0, \"aria-valuemax\": t.max } }, [t._t(\"default\", [t.showProgress ? [t._v(t._s(t.progress) + \"%\")] : t.showValue ? [t._v(t._s(t.value))] : t._e()])], 2)])], 1);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"progress-bar\", this.progressVariant, this.striped || this.animated ? \"progress-bar-striped\" : \"\", this.animated ? \"progress-bar-animated\" : \"\"];\n    }, styleObject: function styleObject() {\n      return { width: this.progress + \"%\" };\n    }, progressVariant: function progressVariant() {\n      return this.variant ? \"bg-\" + this.variant : null;\n    }, progress: function progress() {\n      var t = Math.pow(10, this.precision);return Math.round(100 * t * this.value / this.max) / t;\n    } }, props: { striped: { type: Boolean, default: !1 }, animated: { type: Boolean, default: !1 }, precision: { type: Number, default: 0 }, value: { type: Number, default: 0 }, max: { type: Number, default: 100 }, variant: { type: String, default: null }, showProgress: { type: Boolean, default: !1 }, showValue: { type: Boolean, default: !1 } } },\n    toString = function toString(t) {\n  return t ? t instanceof Object ? Object.keys(t).map(function (e) {\n    return toString(t[e]);\n  }).join(\" \") : String(t) : \"\";\n},\n    recToString = function recToString(t) {\n  if (!(t instanceof Object)) return \"\";var e = { state: !0, _rowVariant: !0 };return toString(Object.keys(t).reduce(function (n, i) {\n    return e[i] || (n[i] = t[i]), n;\n  }, {}));\n},\n    defaultSortCompare = function defaultSortCompare(t, e, n) {\n  return \"number\" == typeof t[n] && \"number\" == typeof e[n] ? t[n] < e[n] ? -1 : t[n] > e[n] ? 1 : 0 : toString(t[n]).localeCompare(toString(e[n]), void 0, { numeric: !0 });\n},\n    table = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"table\", { class: t.tableClass, attrs: { id: t.id || null, role: \"grid\", \"aria-busy\": t.busy ? \"true\" : \"false\" } }, [n(\"thead\", { class: t.headClass }, [n(\"tr\", { attrs: { role: \"row\" } }, t._l(t.fields, function (e, i) {\n      return n(\"th\", { key: i, class: t.fieldClass(e, i), style: e.thStyle || {}, attrs: { \"aria-label\": e.sortable ? t.sortDesc && t.sortBy === i ? t.labelSortAsc : t.labelSortDesc : null, \"aria-sort\": e.sortable && t.sortBy === i ? t.sortDesc ? \"descending\" : \"ascending\" : null, tabindex: e.sortable ? \"0\" : null }, on: { click: function click(n) {\n            n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }] } }, [t._t(\"HEAD_\" + i, [n(\"div\", { domProps: { innerHTML: t._s(e.label) } })], { label: e.label, column: i, field: e })], 2);\n    }))]), t.footClone ? n(\"tfoot\", { class: t.footClass }, [n(\"tr\", { attrs: { role: \"row\" } }, t._l(t.fields, function (e, i) {\n      return n(\"th\", { key: i, class: t.fieldClass(e, i), style: e.thStyle || {}, attrs: { \"aria-label\": e.sortable ? t.sortDesc && t.sortBy === i ? t.labelSortAsc : t.labelSortDesc : null, \"aria-sort\": e.sortable && t.sortBy === i ? t.sortDesc ? \"descending\" : \"ascending\" : null, tabindex: e.sortable ? \"0\" : null }, on: { click: function click(n) {\n            n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }] } }, [t.$scopedSlots[\"FOOT_\" + i] ? t._t(\"FOOT_\" + i, [n(\"div\", { domProps: { innerHTML: t._s(e.label) } })], { label: e.label, column: i, field: e }) : t._t(\"HEAD_\" + i, [n(\"div\", { domProps: { innerHTML: t._s(e.label) } })], { label: e.label, column: i, field: e })], 2);\n    }))]) : t._e(), n(\"tbody\", [t._l(t._items, function (e, i) {\n      return n(\"tr\", { key: i, class: t.rowClass(e), attrs: { role: \"row\" }, on: { click: function click(n) {\n            t.rowClicked(n, e, i);\n          }, hover: function hover(n) {\n            t.rowHovered(n, e, i);\n          } } }, t._l(t.fields, function (o, r) {\n        return n(\"td\", { key: r, class: t.tdClass(o, e, r) }, [t._t(r, [t._v(t._s(e[r]))], { value: e[r], item: e, index: i })], 2);\n      }));\n    }), !t.showEmpty || t._items && 0 !== t._items.length ? t._e() : n(\"tr\", { attrs: { role: \"row\" } }, [n(\"td\", { attrs: { colspan: Object.keys(t.fields).length } }, [t.filter ? n(\"div\", { attrs: { role: \"alert\", \"aria-live\": \"polite\" } }, [t._t(\"emptyfiltered\", [n(\"div\", { staticClass: \"text-center my-2\", domProps: { innerHTML: t._s(t.emptyFilteredText) } })])], 2) : n(\"div\", { attrs: { role: \"alert\", \"aria-live\": \"polite\" } }, [t._t(\"empty\", [n(\"div\", { staticClass: \"text-center my-2\", domProps: { innerHTML: t._s(t.emptyText) } })])], 2)])])], 2)], 1);\n  }, staticRenderFns: [], data: function data() {\n    return { sortBy: null, sortDesc: !0, localItems: [] };\n  }, props: { id: { type: String, default: \"\" }, items: { type: [Array, Function], default: function _default() {\n        return this && this.itemsProvider ? (warn(\"b-table: prop items-provider has been deprecated. Pass a function to items instead\"), this.itemsProvider) : [];\n      } }, fields: { type: Object, default: {} }, striped: { type: Boolean, default: !1 }, bordered: { type: Boolean, default: !1 }, inverse: { type: Boolean, default: !1 }, hover: { type: Boolean, default: !1 }, small: { type: Boolean, default: !1 }, responsive: { type: Boolean, default: !1 }, headVariant: { type: String, default: \"\" }, footVariant: { type: String, default: \"\" }, perPage: { type: Number, default: null }, currentPage: { type: Number, default: 1 }, filter: { type: [String, RegExp, Function], default: null }, sortCompare: { type: Function, default: null }, itemsProvider: { type: Function, default: null }, noProviderPaging: { type: Boolean, default: !1 }, noProviderSorting: { type: Boolean, default: !1 }, noProviderFiltering: { type: Boolean, default: !1 }, busy: { type: Boolean, default: !1 }, value: { type: Array, default: function _default() {\n        return [];\n      } }, footClone: { type: Boolean, default: !1 }, labelSortAsc: { type: String, default: \"Click to sort Ascending\" }, labelSortDesc: { type: String, default: \"Click to sort Descending\" }, showEmpty: { type: Boolean, default: !1 }, emptyText: { type: String, default: \"There are no records to show\" }, emptyFilteredText: { type: String, default: \"There are no records matching your request\" } }, watch: { items: function items(t, e) {\n      e !== t && this._providerUpdate();\n    }, sortDesc: function sortDesc(t, e) {\n      e === t || this.noProviderSorting || this._providerUpdate();\n    }, sortBy: function sortBy(t, e) {\n      e === t || this.noProviderSorting || this._providerUpdate();\n    }, perPage: function perPage(t, e) {\n      e === t || this.noProviderPaging || this._providerUpdate();\n    }, currentPage: function currentPage(t, e) {\n      e === t || this.noProviderPaging || this._providerUpdate();\n    }, filter: function filter(t, e) {\n      e === t || this.noProviderFiltering || this._providerUpdate();\n    } }, mounted: function mounted() {\n    var t = this;this.hasProvider && this._providerUpdate(), this.$root.$on(\"table::refresh\", function (e) {\n      e === t.id && t._providerUpdate();\n    });\n  }, computed: { tableClass: function tableClass() {\n      return [\"table\", \"b-table\", this.striped ? \"table-striped\" : \"\", this.hover ? \"table-hover\" : \"\", this.inverse ? \"table-inverse\" : \"\", this.bordered ? \"table-bordered\" : \"\", this.responsive ? \"table-responsive\" : \"\", this.small ? \"table-sm\" : \"\"];\n    }, headClass: function headClass() {\n      return this.headVariant ? \"thead-\" + this.headVariant : \"\";\n    }, footClass: function footClass() {\n      var t = this.footVariant || this.headVariant || null;return t ? \"thead-\" + t : \"\";\n    }, hasProvider: function hasProvider() {\n      return this.items instanceof Function;\n    }, providerFiltering: function providerFiltering() {\n      return Boolean(this.hasProvider && !this.noProviderFiltering);\n    }, providerSorting: function providerSorting() {\n      return Boolean(this.hasProvider && !this.noProviderSorting);\n    }, providerPaging: function providerPaging() {\n      return Boolean(this.hasProvider && !this.noProviderPaging);\n    }, context: function context() {\n      return { perPage: this.perPage, currentPage: this.currentPage, filter: this.filter, sortBy: this.sortBy, sortDesc: this.sortDesc };\n    }, _items: function _items() {\n      var t = this,\n          e = this.perPage,\n          n = this.currentPage,\n          i = this.filter,\n          o = (this.sortBy, this.sortDesc, this.sortCompare || defaultSortCompare),\n          r = this.hasProvider ? this.localItems : this.items;if (!r) return this.$nextTick(this._providerUpdate), [];if (r = r.slice(), i && !this.providerFiltering) if (i instanceof Function) r = r.filter(i);else {\n        var s;s = i instanceof RegExp ? i : new RegExp(\".*\" + i + \".*\", \"ig\"), r = r.filter(function (t) {\n          var e = s.test(recToString(t));return s.lastIndex = 0, e;\n        });\n      }return this.sortBy && !this.providerSorting && (r = r.sort(function (e, n) {\n        var i = o(e, n, t.sortBy);return t.sortDesc ? i : -1 * i;\n      })), e && !this.providerPaging && (r = r.slice((n - 1) * e, n * e)), this.$emit(\"input\", r), r;\n    } }, methods: { fieldClass: function fieldClass(t, e) {\n      return [t.sortable ? \"sorting\" : \"\", t.sortable && this.sortBy === e ? \"sorting_\" + (this.sortDesc ? \"desc\" : \"asc\") : \"\", t.variant ? \"table-\" + t.variant : \"\", t.class ? t.class : \"\", t.thClass ? t.thClass : \"\"];\n    }, tdClass: function tdClass(t, e, n) {\n      var i = \"\";return e._cellVariants && e._cellVariants[n] && (i = (this.inverse ? \"bg-\" : \"table-\") + e._cellVariants[n]), [t.variant && !i ? (this.inverse ? \"bg-\" : \"table-\") + t.variant : \"\", i, t.class ? t.class : \"\", t.tdClass ? t.tdClass : \"\"];\n    }, rowClass: function rowClass(t) {\n      var e = t._rowVariant || t.state || null;return [e ? (this.inverse ? \"bg-\" : \"table-\") + e : \"\"];\n    }, rowClicked: function rowClicked(t, e, n) {\n      if (this.busy) return t.preventDefault(), void t.stopPropagation();this.$emit(\"row-clicked\", e, n);\n    }, rowHovered: function rowHovered(t, e, n) {\n      if (this.busy) return t.preventDefault(), void t.stopPropagation();this.$emit(\"row-hovered\", e, n);\n    }, headClicked: function headClicked(t, e, n) {\n      if (this.busy) return t.preventDefault(), void t.stopPropagation();var i = !1;e.sortable ? (n === this.sortBy ? this.sortDesc = !this.sortDesc : (this.sortBy = n, this.sortDesc = !0), i = !0) : this.sortBy && (this.sortBy = null, i = !0), this.$emit(\"head-clicked\", n, e), i && this.$emit(\"sort-changed\", this.context);\n    }, refresh: function refresh() {\n      this.hasProvider && this._providerUpdate();\n    }, _providerSetLocal: function _providerSetLocal(t) {\n      this.localItems = t && t.length > 0 ? t.slice() : [], this.$emit(\"refreshed\"), this.$root.$emit(\"table::refreshed\", this.id);\n    }, _providerUpdate: function _providerUpdate() {\n      var t = this;if (!this.busy && this.hasProvider) {\n        var e = this.items(this.context, this._providerSetLocal);e && (e.then && \"function\" == typeof e.then ? e.then(function (e) {\n          t._providerSetLocal(e);\n        }) : this._providerSetLocal(e));\n      }\n    } } },\n    tabs = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(t.tag, { tag: \"component\", staticClass: \"tabs\", attrs: { id: t.id || null } }, [t.bottom ? n(\"div\", { ref: \"tabsContainer\", class: [\"tab-content\", { \"card-block\": t.card }] }, [t._t(\"default\"), t.tabs && t.tabs.length ? t._e() : t._t(\"empty\")], 2) : t._e(), n(\"div\", { class: { \"card-header\": t.card } }, [n(\"ul\", { class: [\"nav\", \"nav-\" + t.navStyle, t.card ? \"card-header-\" + t.navStyle : null], attrs: { role: \"tablist\", tabindex: \"0\", \"aria-setsize\": t.tabs.length, \"aria-posinset\": t.currentTab + 1 }, on: { keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : void t.previousTab(e) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.previousTab(e);\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : void t.nextTab(e) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.nextTab(e);\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"left\", 37)) && e.shiftKey ? \"button\" in e && 0 !== e.button ? null : void t.setTab(-1, !1, 1) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"up\", 38)) && e.shiftKey ? void t.setTab(-1, !1, 1) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"right\", 39)) && e.shiftKey ? \"button\" in e && 2 !== e.button ? null : void t.setTab(t.tabs.length, !1, -1) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"down\", 40)) && e.shiftKey ? void t.setTab(t.tabs.length, !1, -1) : null;\n        }] } }, [t._l(t.tabs, function (e, i) {\n      return n(\"li\", { staticClass: \"nav-item\", attrs: { role: \"presentation\" } }, [e.headHtml ? n(\"div\", { class: [\"tab-head\", { small: t.small, active: e.localActive, disabled: e.disabled }], attrs: { role: \"heading\", tabindex: \"-1\" }, domProps: { innerHTML: t._s(e.headHtml) } }) : n(\"a\", { class: [\"nav-link\", { small: t.small, active: e.localActive, disabled: e.disabled }], attrs: { href: e.href, role: \"tab\", \"aria-selected\": e.localActive ? \"true\" : \"false\", \"aria-controls\": e.id || null, id: e.controlledBy || null, tabindex: \"-1\" }, domProps: { innerHTML: t._s(e.title) }, on: { click: function click(e) {\n            e.preventDefault(), e.stopPropagation(), t.setTab(i);\n          }, keydown: [function (e) {\n            if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), e.stopPropagation(), t.setTab(i);\n          }, function (e) {\n            if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), e.stopPropagation(), t.setTab(i);\n          }] } })]);\n    }), t._t(\"tabs\")], 2)]), t.bottom ? t._e() : n(\"div\", { ref: \"tabsContainer\", class: [\"tab-content\", { \"card-block\": t.card }] }, [t._t(\"default\"), t.tabs && t.tabs.length ? t._e() : t._t(\"empty\")], 2)]);\n  }, staticRenderFns: [], data: function data() {\n    return { currentTab: this.value, tabs: [] };\n  }, props: { id: { type: String, default: \"\" }, tag: { type: String, default: \"div\" }, noFade: { type: Boolean, default: !1 }, card: { type: Boolean, default: !1 }, small: { type: Boolean, default: !1 }, value: { type: Number, default: 0 }, pills: { type: Boolean, default: !1 }, lazy: { type: Boolean, default: !1 }, bottom: { type: Boolean, default: !1 } }, watch: { currentTab: function currentTab(t, e) {\n      t !== e && (this.$root.$emit(\"changed::tab\", this, t, this.tabs[t]), this.$emit(\"input\", t), this.tabs[t].$emit(\"click\"));\n    }, value: function value(t, e) {\n      t !== e && this.setTab(t);\n    }, fade: function fade(t, e) {\n      var n = this;t !== e && this.tabs.forEach(function (e) {\n        n.$set(e, \"fade\", t);\n      });\n    } }, computed: { fade: function fade() {\n      return !this.noFade;\n    }, navStyle: function navStyle() {\n      return this.pills ? \"pills\" : \"tabs\";\n    } }, methods: { sign: function sign(t) {\n      return 0 === t ? 0 : t > 0 ? 1 : -1;\n    }, nextTab: function nextTab() {\n      this.setTab(this.currentTab, !1, 1);\n    }, previousTab: function previousTab() {\n      this.setTab(this.currentTab, !1, -1);\n    }, setTab: function setTab(t, e, n) {\n      var i = this;if (n = n || 0, e || t + n !== this.currentTab) {\n        var o = this.tabs[t + n];o && (o.disabled ? n && this.setTab(t, e, n + this.sign(n)) : (this.tabs.forEach(function (t) {\n          t !== o && t.localActive && i.$set(t, \"localActive\", !1);\n        }), this.$set(o, \"localActive\", !0), this.currentTab = t + n));\n      }\n    }, updateTabs: function updateTabs() {\n      var t = this;this.$slots.default ? this.tabs = this.$slots.default.filter(function (t) {\n        return t.componentInstance || !1;\n      }).map(function (t) {\n        return t.componentInstance;\n      }) : this.tabs = [], this.tabs.forEach(function (e) {\n        t.$set(e, \"fade\", t.fade), t.$set(e, \"lazy\", t.lazy);\n      });var e = this.currentTab;null !== e && void 0 !== e || this.tabs.forEach(function (t, n) {\n        t.active && (e = n);\n      });var n = 0;e > this.tabs.length - 1 && (n = -1), this.setTab(e || 0, !0, n);\n    } }, mounted: function mounted() {\n    this.updateTabs(), observeDOM(this.$refs.tabsContainer, this.updateTabs.bind(this), { subtree: !1 });\n  } },\n    tab = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"transition\", { attrs: { mode: \"out-in\" }, on: { enter: t.enter, \"before-leave\": t.beforeLeave } }, [t.localActive || !t.lazy ? n(t.tag, { directives: [{ name: \"show\", rawName: \"v-show\", value: t.localActive || t.lazy, expression: \"localActive || lazy\" }], ref: \"panel\", tag: \"component\", class: [\"tab-pane\", { show: t.show, fade: t.fade, disabled: t.disabled, active: t.localActive }], attrs: { id: t.id || null, role: \"tabpanel\", \"aria-hidden\": t.localActive ? \"false\" : \"true\", \"aria-expanded\": t.localActive ? \"true\" : \"false\", \"aria-lablelledby\": t.controlledBy || null } }, [t._t(\"default\")], 2) : t._e()], 1);\n  }, staticRenderFns: [], methods: { enter: function enter() {\n      this.show = !0;\n    }, beforeLeave: function beforeLeave() {\n      this.show = !1;\n    } }, data: function data() {\n    return { fade: !1, localActive: !1, lazy: !0, show: !1 };\n  }, computed: { controlledBy: function controlledBy() {\n      return this.buttonId || (this.id ? this.id + \"__BV_tab_button__\" : null);\n    } }, props: { id: { type: String, default: \"\" }, tag: { type: String, default: \"div\" }, buttonId: { type: String, default: \"\" }, title: { type: String, default: \"\" }, headHtml: { type: String, default: null }, disabled: { type: Boolean, default: !1 }, active: { type: Boolean, default: !1 }, href: { type: String, default: \"#\" } } },\n    tooltip = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"d-inline-block\" }, [n(\"span\", { ref: \"trigger\", staticClass: \"d-inline-block\" }, [t._t(\"default\")], 2), n(\"div\", { ref: \"popover\", class: [\"tooltip\", \"tooltip-\" + this.placement], style: { opacity: t.showState ? 1 : 0 }, attrs: { tabindex: \"-1\" }, on: { focus: function focus(e) {\n          t.$emit(\"focus\");\n        }, blur: function blur(e) {\n          t.$emit(\"blur\");\n        } } }, [n(\"div\", { staticClass: \"tooltip-inner\" }, [t._t(\"content\", [n(\"span\", { domProps: { innerHTML: t._s(t.content) } })])], 2)])]);\n  }, staticRenderFns: [], mixins: [popover$1], props: { content: { type: String, default: \"\" }, triggers: { type: [Boolean, String, Array], default: \"hover\" } } },\n    components = Object.freeze({ bAlert: alert, bBreadcrumb: breadcrumb, bButton: bBtn, bBtn: bBtn, bButtonToolbar: buttonToolbar, bBtnToolbar: buttonToolbar, bButtonGroup: buttonGroup, bBtnGroup: buttonGroup, bButtonGroupDropdown: buttonGroupDropdown, bBtnGroupDropdown: buttonGroupDropdown, bInputGroup: inputGroup, bInputGroupAddon: inputGroupAddon, bInputGroupButton: inputGroupButton, bInputGroupBtn: inputGroupButton, bCard: card, bCardGroup: cardGroup, bDropdown: dropdown$1, bDropdownItem: dropdownItem, bDropdownItemButton: dropdownItemButton, bDropdownItemBtn: dropdownItemButton, bDropdownDivider: dropdownDivider, bDropdownHeader: dropdownHeader, bDropdownSelect: dropdownSelect, bForm: bForm, bFormCheckbox: formCheckbox, bFormFieldset: formFieldset, bFormFile: formFile, bFormRadio: formRadio, bFormInput: formInput, bFormInputStatic: bFormInputStatic, bFormSelect: formSelect, bJumbotron: jumbotron, bBadge: badge, bMedia: media, bModal: modal, bNavbar: navbar, bNavText: navText, bNavForm: navForm, bPagination: pagination, bPopover: popover, bProgress: progress, bTable: table, bTooltip: tooltip, bTab: tab, bTabs: tabs, bNav: nav, bNavItem: navItem, bNavItemDropdown: navItemDropdown, bNavToggle: navToggle, bListGroupItem: listGroupItem, bListGroup: listGroup, bCarouselSlide: carouselSlide, bCarousel: carousel, bCollapse: collapse, bLink: bLink }),\n    all_listen_types = { hover: !0, click: !0, focus: !0 },\n    inBrowser = \"undefined\" != typeof window,\n    listen_types = { click: !0 },\n    toggle = { bind: function bind(t, e) {\n    var n = targets(t, e, listen_types, function (t) {\n      var e = t.targets,\n          n = t.vm;e.forEach(function (t) {\n        n.$root.$emit(\"collapse::toggle\", t);\n      });\n    });inBrowser && t.__vue__ && n.length > 0 && (t.setAttribute(\"aria-controls\", n.join(\" \")), t.setAttribute(\"aria-expanded\", \"false\"), t.__vue__.$root.$on(\"collapse::toggle::state\", function (e, i) {\n      -1 !== n.indexOf(e) && t.setAttribute(\"aria-expanded\", i ? \"true\" : \"false\");\n    }));\n  } },\n    listen_types$1 = { click: !0 },\n    modal$1 = { bind: function bind(t, e) {\n    targets(t, e, listen_types$1, function (e) {\n      var n = e.targets,\n          i = e.vm;n.forEach(function (e) {\n        i.$root.$emit(\"show::modal\", e, t);\n      });\n    });\n  } },\n    inBrowser$1 = \"undefined\" != typeof window,\n    isServer = !inBrowser$1;inBrowser$1 && window.Element && !Element.prototype.closest && (Element.prototype.closest = function (t) {\n  var e,\n      n = (this.document || this.ownerDocument).querySelectorAll(t),\n      i = this;do {\n    for (e = n.length; --e >= 0 && n.item(e) !== i;) {}\n  } while (e < 0 && (i = i.parentElement));return i;\n});var NAME = \"v-b-scrollspy\",\n    EVENT = \"scrollspy::activate\",\n    BVSS = \"__BV_ScrollSpy__\",\n    Default = { element: \"body\", offset: 10, method: \"auto\", throttle: 200 },\n    DefaultType = { element: \"(string|element)\", offset: \"number\", method: \"string\", throttle: \"number\" },\n    ClassName = { DROPDOWN_ITEM: \"dropdown-item\", DROPDOWN_MENU: \"dropdown-menu\", DROPDOWN_TOGGLE: \"dropdown-toggle\", NAV_LINK: \"nav-link\", LIST_ITEM: \"list-group-item\", ACTIVE: \"active\" },\n    Selector = { ACTIVE: \".active\", NAV_LIST_GROUP: \".nav, .list-group\", NAV: \".nav\", LIST_GROUP: \".list-group\", NAV_LINKS: \".nav-link\", LIST_ITEMS: \".list-group-item\", DROPDOWN: \".dropdown\", DROPDOWN_ITEMS: \".dropdown-item\", DROPDOWN_TOGGLE: \".dropdown-toggle\" },\n    OffsetMethod = { OFFSET: \"offset\", POSITION: \"position\" };ScrollSpy.prototype.updateConfig = function (t) {\n  var e = this;t.arg && (this._config.element = \"#\" + t.arg), Object.keys(t.modifiers).forEach(function (t) {\n    /^\\d+$/.test(t) ? e._config.offset = parseInt(t, 10) : /^(auto|position|offset)$/.test(t) && (e._config.method = t);\n  }), \"string\" == typeof t.value ? this._config.element = t.value : \"number\" == typeof t.value ? this._config.offset = Math.round(t.value) : \"object\" == _typeof(t.value) && Object.keys(t.value).filter(function (t) {\n    return Boolean(DefaultType[t]);\n  }).forEach(function (n) {\n    e._config[n] = t.value[n];\n  }), typeCheckConfig(NAME, this._config, DefaultType);var n = getVm(this._$el);return n && n.$root && (this._$root = n.$root), this;\n}, ScrollSpy.prototype.listen = function () {\n  var t = this._getScroller();return t && (\"BODY\" !== t.tagName && t.addEventListener(\"scroll\", this, !1), window.addEventListener(\"scroll\", this, !1), window.addEventListener(\"orientationchange\", this, !1), window.addEventListener(\"resize\", this, !1)), this;\n}, ScrollSpy.prototype.unListen = function () {\n  var t = this._getScroller();return t && (\"BODY\" !== t.tagName && t.removeEventListener(\"scroll\", this, !1), window.removeEventListener(\"scroll\", this, !1), window.removeEventListener(\"orientationchange\", this, !1), window.removeEventListener(\"resize\", this, !1)), this;\n}, ScrollSpy.prototype.refresh = function () {\n  var t = this,\n      e = this._getScroller();if (!e) return this;var n = \"BODY\" === e.tagName ? OffsetMethod.OFFSET : OffsetMethod.POSITION,\n      i = \"auto\" === this._config.method ? n : this._config.method,\n      o = i === OffsetMethod.OFFSET ? 0 : this._getScrollTop();return this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), $QSA(this._selector, this._$el).map(function (t) {\n    var n = t.getAttribute(\"href\");if (n && \"#\" === n.charAt(0) && \"#\" !== n && -1 === n.indexOf(\"#/\")) {\n      var r = $QS(n, e);if (!r) return null;var s = r.getBoundingClientRect();if (s.width || s.height) return { offset: (i === OffsetMethod.OFFSET ? s.top : r.offsetTop) + o, href: n };\n    }return null;\n  }).filter(function (t) {\n    return t;\n  }).sort(function (t, e) {\n    return t.offset - e.offset;\n  }).forEach(function (e) {\n    t._offsets.push(e.offset), t._targets.push(e.href);\n  }), this;\n}, ScrollSpy.prototype.process = function () {\n  var t = this;if (!this._getScroller) return this;var e = this._getScrollTop() + this._config.offset,\n      n = this._getScrollHeight(),\n      i = this._config.offset + n - this._getOffsetHeight();if (this._scrollHeight !== n && this.refresh(), e >= i) {\n    var o = this._targets[this._targets.length - 1];return this._activeTarget !== o && this._activate(o), this;\n  }if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, this._clear(), this;for (var r = this._offsets.length; r--;) {\n    t._activeTarget !== t._targets[r] && e >= t._offsets[r] && (void 0 === t._offsets[r + 1] || e < t._offsets[r + 1]) && t._activate(t._targets[r]);\n  }return this;\n}, ScrollSpy.prototype.dispose = function () {\n  this.unListen(), clearTimeout(this._resizeTimeout), this._resizeTimeout = null, this._$el = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null, this._$root = null;\n}, ScrollSpy.prototype.handleEvent = function (t) {\n  var e = this;\"scroll\" === t.type ? this.process() : \"orientationchange\" === t.type ? this.refresh().process() : \"resize\" === t.type && function () {\n    clearTimeout(this._resizeTimeout), this._resizeTimeout = setTimeout(function () {\n      e.refresh().process();\n    }, e._config.throttle || Default.throttle);\n  }();\n}, ScrollSpy.prototype._getScroller = function () {\n  if (isServer) return null;var t = this._config.element;return t ? t && isElement(t) ? t : \"string\" == typeof t ? \"body\" === t ? document.body : $QS(t) : null : null;\n}, ScrollSpy.prototype._getScrollTop = function () {\n  var t = this._getScroller();return t ? \"BODY\" === t.tagName ? window.pageYOffset : t.scrollTop : 0;\n}, ScrollSpy.prototype._getScrollHeight = function () {\n  var t = this._getScroller();return t ? \"BODY\" === t.tagName ? Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) : t.scrollHeight : 0;\n}, ScrollSpy.prototype._getOffsetHeight = function () {\n  var t = this._getScroller();return t ? \"BODY\" === t.tagName ? window.innerHeight : t.getBoundingClientRect().height : 0;\n}, ScrollSpy.prototype._activate = function (t) {\n  var e = this;this._activeTarget = t, this._clear();var n = this._selector.split(\",\"),\n      i = $QSA((n = n.map(function (e) {\n    return e + '[href=\"' + t + '\"]';\n  })).join(\",\"), this._$el);i.forEach(function (t) {\n    if (t.classList.contains(ClassName.DROPDOWN_ITEM)) {\n      var n = closest(t, Selector.DROPDOWN);if (n) {\n        var i = $QS(Selector.DROPDOWN_TOGGLE, n);i && e._setActiveState(i, !0);\n      }e._setActiveState(t, !0);\n    } else e._setActiveState(t, !0), e._setParentsSiblingActiveState(t, Selector.NAV_LIST_GROUP, [ClassName.NAV_LINK, ClassName.LIST_ITEM], !0);\n  }), i && i.length > 0 && this._$root && this._$root.$emit && this._$root.$emit(EVENT, t);\n}, ScrollSpy.prototype._clear = function () {\n  var t = this;$QSA(this._selector, this._$el).filter(function (t) {\n    if (t.classList.contains(ClassName.ACTIVE)) {\n      var e = t.getAttribute(\"href\");return \"#\" === e.charAt(0) && 0 !== e.indexOf(\"#/\");\n    }return !1;\n  }).forEach(function (e) {\n    t._setActiveState(e, !1);\n  });\n}, ScrollSpy.prototype._setActiveState = function (t, e) {\n  if (t) {\n    t.classList.contains(ClassName.NAV_LINK) && !t.classList.contains(ClassName.DROPDOWN_TOGGLE) && (t = t.parentElement);var n = getVm(t);n && Object.prototype.hasOwnProperty.call(n.$props, \"active\") ? n.$props.active = e : t.classList[e ? \"add\" : \"remove\"](ClassName.ACTIVE);\n  }\n}, ScrollSpy.prototype._setParentsSiblingActiveState = function (t, e, n, i) {\n  var o = this;if (n) {\n    Array.isArray(n) || (n = [n]);for (var r = t; r;) {\n      if ((r = closest(r, e)) && r.previousElementSibling) for (var s = 0; s < n.length - 1; s++) {\n        r.previousElementSibling.classList.contains(n[s]) && o._setActiveState(r, i);\n      }\n    }\n  }\n};var scrollspy = { bind: function bind(t, e) {\n    isServer || t[BVSS] || (t[BVSS] = new ScrollSpy(t, e));\n  }, inserted: function inserted(t, e) {\n    !isServer && t[BVSS] && t[BVSS].updateConfig(e).listen().refresh().process();\n  }, update: function update(t, e) {\n    !isServer && t[BVSS] && t[BVSS].updateConfig(e).refresh().process();\n  }, componentUpdated: function componentUpdated(t, e) {\n    !isServer && t[BVSS] && t[BVSS].updateConfig(e).refresh().process();\n  }, unbind: function unbind(t) {\n    !isServer && t[BVSS] && (t[BVSS].unListen().dispose(), t[BVSS] = null);\n  } },\n    directives = Object.freeze({ bToggle: toggle, bModal: modal$1, bScrollspy: scrollspy }),\n    VuePlugin = { install: function install(t) {\n    if (!t._bootstrap_vue_installed) {\n      t._bootstrap_vue_installed = !0;for (var e in components) {\n        t.component(e, components[e]);\n      }for (var n in directives) {\n        t.directive(n, directives[n]);\n      }\n    }\n  } };\"undefined\" != typeof window && window.Vue && window.Vue.use(VuePlugin);/* harmony default export */ __webpack_exports__[\"default\"] = (VuePlugin);\n//# sourceMappingURL=bootstrap-vue.esm.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19ib290c3RyYXAtdnVlQDAuMTcuMUBib290c3RyYXAtdnVlL2Rpc3QvYm9vdHN0cmFwLXZ1ZS5lc20uanM/OTNmNiJdLCJuYW1lcyI6WyJvbWl0TGlua1Byb3BzIiwidCIsImUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwicHJvcHMiLCJyZWR1Y2UiLCJuIiwiaW5jbHVkZXMiLCJpc1Zpc2libGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImZpbmRGaXJzdFZpc2libGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJpIiwiZmluZCIsIm8iLCJpc1Zpc2libGUkMSIsIm1ha2VQYWdlQXJyYXkiLCJhcHBseSIsIm1hcCIsIm51bWJlciIsImNsYXNzTmFtZSIsIm9ic2VydmVET00iLCJ3aW5kb3ciLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwib2JzZXJ2ZSIsImFzc2lnbiIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJ0YXJnZXRzIiwiX192dWVfXyIsImNvbnNvbGUiLCJ3YXJuIiwiciIsIm1vZGlmaWVycyIsImZpbHRlciIsImFsbF9saXN0ZW5fdHlwZXMiLCJ2YWx1ZSIsInB1c2giLCJzIiwidm0iLCJmb3JFYWNoIiwiaXNFbGVtZW50Iiwibm9kZVR5cGUiLCJjbG9zZXN0IiwiJFFTQSIsImRvY3VtZW50IiwiJFFTIiwicXVlcnlTZWxlY3RvciIsImdldFZtIiwidG9UeXBlIiwidG9TdHJpbmciLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwidHlwZUNoZWNrQ29uZmlnIiwiaGFzT3duUHJvcGVydHkiLCJSZWdFeHAiLCJ0ZXN0IiwiZXJyb3IiLCJTY3JvbGxTcHkiLCJfJGVsIiwiX3NlbGVjdG9yIiwiU2VsZWN0b3IiLCJOQVZfTElOS1MiLCJMSVNUX0lURU1TIiwiRFJPUERPV05fSVRFTVMiLCJqb2luIiwiX2NvbmZpZyIsIkRlZmF1bHQiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfJHJvb3QiLCJfcmVzaXplVGltZW91dCIsInVwZGF0ZUNvbmZpZyIsImFsZXJ0IiwicmVuZGVyIiwiJGNyZWF0ZUVsZW1lbnQiLCJfc2VsZiIsIl9jIiwibG9jYWxTaG93IiwiY2xhc3MiLCJjbGFzc09iamVjdCIsImF0dHJzIiwicm9sZSIsImRpc21pc3NpYmxlIiwic3RhdGljQ2xhc3MiLCJ0eXBlIiwib24iLCJjbGljayIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZGlzbWlzcyIsIl92IiwiX2UiLCJfdCIsInN0YXRpY1JlbmRlckZucyIsImRhdGEiLCJjb3VudERvd25UaW1lcklkIiwiZGlzbWlzc2VkIiwiY3JlYXRlZCIsInN0YXRlIiwiY29tcHV0ZWQiLCJhbGVydFZhcmlhbnQiLCJ2YXJpYW50Iiwic2hvdyIsIlN0cmluZyIsImRlZmF1bHQiLCJCb29sZWFuIiwiZGlzbWlzc0xhYmVsIiwiTnVtYmVyIiwid2F0Y2giLCJzaG93Q2hhbmdlZCIsIm1vdW50ZWQiLCJtZXRob2RzIiwiJGVtaXQiLCJjbGVhckNvdW50ZXIiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJhY3RpdmUiLCJhY3RpdmVDbGFzcyIsImFwcGVuZCIsImRpc2FibGVkIiwiZXZlbnQiLCJleGFjdCIsImV4YWN0QWN0aXZlQ2xhc3MiLCJocmVmIiwicmVsIiwicmVwbGFjZSIsInJvdXRlclRhZyIsInRhZyIsInRhcmdldCIsInRvIiwibGlua1Byb3BzIiwiaXNSb3V0ZXJMaW5rIiwiJHJvdXRlciIsIl9ocmVmIiwiY29tcHV0ZWRSZWwiLCJjb21wb25lbnRUYWciLCJsaW5rQ2xhc3NPYmplY3QiLCJsaW5rQ2xpY2siLCIkcm9vdCIsImxpbmtNaXhpbiIsImJMaW5rIiwibmF0aXZlT24iLCJtaXhpbnMiLCJiTGlua1Byb3BLZXlzIiwiYnJlYWRjcnVtYiIsIl9sIiwibm9ybWFsaXplZEl0ZW1zIiwib25DbGljayIsIl9vcmlnaW5hbEl0ZW0iLCJhcmlhQ3VycmVudCIsImRvbVByb3BzIiwiaW5uZXJIVE1MIiwiX3MiLCJ0ZXh0IiwiX2IiLCJfbGlua1Byb3BzIiwiY29tcG9uZW50cyIsIml0ZW1zIiwibGluayIsInJlcXVpcmVkIiwiYkJ0biIsImNvbXBvbmVudFR5cGUiLCJjbGFzc0xpc3QiLCJidG5UeXBlIiwiY29uZGl0aW9uYWxMaW5rUHJvcHMiLCJidG5WYXJpYW50IiwiYnRuU2l6ZSIsImJ0bkJsb2NrIiwiYnRuRGlzYWJsZWQiLCJibG9jayIsInNpemUiLCJJVEVNX1NFTEVDVE9SIiwiYnV0dG9uVG9vbGJhciIsInRhYmluZGV4Iiwia2V5TmF2IiwiZm9jdXNpbiIsImN1cnJlbnRUYXJnZXQiLCJmb2N1c0ZpcnN0Iiwia2V5ZG93biIsIl9rIiwia2V5Q29kZSIsImJ1dHRvbiIsImZvY3VzTmV4dCIsInNoaWZ0S2V5IiwiZm9jdXNMYXN0IiwianVzdGlmeSIsInZlcnRpY2FsIiwiS2V5TmF2Iiwic2V0SXRlbUZvY3VzIiwiJG5leHRUaWNrIiwiZm9jdXMiLCJnZXRJdGVtcyIsImluZGV4T2YiLCIkZWwiLCJ0YWJJbmRleCIsImJ1dHRvbkdyb3VwIiwiY2xpY2tPdXQiLCJkb2N1bWVudEVsZW1lbnQiLCJfY2xpY2tPdXRMaXN0ZW5lciIsImRlc3Ryb3llZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb250YWlucyIsImNsaWNrT3V0TGlzdGVuZXIiLCJJVEVNX1NFTEVDVE9SJDEiLCJIRUFERVJfU0VMRUNUT1IiLCJBTExfU0VMRUNUT1IiLCJkcm9wZG93biIsInNwbGl0IiwiZHJvcHVwIiwicmlnaHQiLCJ2aXNpYmxlIiwiJG9uIiwiYm9keSIsImNoaWxkcmVuIiwibm9vcCIsInRvZ2dsZSIsImdldEZpcnN0SXRlbSIsImZvY3VzSXRlbSIsIm9uVGFiIiwib25Fc2MiLCIkcmVmcyIsImZvY3VzSG92ZXJlZCIsImFkZCIsInJlbW92ZSIsIm1lbnUiLCJidXR0b25Hcm91cERyb3Bkb3duIiwiaWQiLCJyZWYiLCJrZWRvd24iLCJrZXl1cCIsIm1vdXNlb3ZlciIsImRyb3Bkb3duVG9nZ2xlIiwiY2FyZXQiLCJpbnB1dEdyb3VwIiwibGVmdCIsImlucHV0R3JvdXBBZGRvbiIsImlucHV0R3JvdXBCdXR0b24iLCJjYXJkIiwiY2FyZFZhcmlhbnQiLCJjYXJkQWxpZ24iLCJjYXJkSW52ZXJzZSIsImltZyIsInNyYyIsImFsdCIsImltZ0FsdCIsImhlYWRlciIsIiRzbG90cyIsImhlYWRlclRhZyIsImhlYWRlclZhcmlhbnQiLCJoZWFkZXJDbGFzcyIsIm5vQmxvY2siLCJibG9ja0NsYXNzIiwidGl0bGUiLCJzdWJUaXRsZSIsImZvb3RlciIsImZvb3RlclRhZyIsImZvb3RlclZhcmlhbnQiLCJmb290ZXJDbGFzcyIsIm92ZXJsYXkiLCJpbnZlcnNlIiwiYWxpZ24iLCJjYXJkR3JvdXAiLCJkZWNrIiwiY29sdW1ucyIsIkRJUkVDVElPTiIsIm5leHQiLCJjdXJyZW50IiwicHJldiIsImNhcm91c2VsIiwic3R5bGUiLCJiYWNrZ3JvdW5kIiwiaGVpZ2h0IiwiaXNTbGlkaW5nIiwibW91c2VlbnRlciIsInBhdXNlIiwibW91c2VsZWF2ZSIsInN0YXJ0IiwiZm9jdXNvdXQiLCJyZXN0YXJ0IiwiY29udHJvbHMiLCJsYWJlbFByZXYiLCJsYWJlbE5leHQiLCJkaXJlY3RpdmVzIiwibmFtZSIsInJhd05hbWUiLCJpbmRpY2F0b3JzIiwiZXhwcmVzc2lvbiIsImxhYmVsSW5kaWNhdG9ycyIsInNsaWRlcyIsImluZGV4IiwibGFiZWxHb3RvU2xpZGUiLCJpbnRlcnZhbCIsInZpc2liaWxpdHlTdGF0ZSIsImhpZGRlbiIsIl9pbnRlcnZhbElkIiwicmVsYXRlZFRhcmdldCIsInNldEF0dHJpYnV0ZSIsIl9jYXJvdXNlbEFuaW1hdGlvbiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjYXJvdXNlbFNsaWRlIiwiY29udGVudENsYXNzZXMiLCJjYXB0aW9uIiwiY29udGVudFZpc2libGVVcCIsImNvbGxhcHNlIiwiZW50ZXIiLCJjbGVhckhlaWdodCIsImxlYXZlIiwiX3Njb3BlSWQiLCJpc05hdiIsIm1vZGVsIiwicHJvcCIsImVtaXRTdGF0ZSIsImFjY29yZGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJkcm9wZG93biQxIiwidG9nZ2xlVGV4dCIsImJCdXR0b24iLCJkcm9wZG93bkl0ZW0iLCJkcm9wZG93bkl0ZW1CdXR0b24iLCJkcm9wZG93bkRpdmlkZXIiLCJkcm9wZG93bkhlYWRlciIsImRyb3Bkb3duU2VsZWN0Iiwib3BlbiIsImRpc3BsYXlJdGVtIiwicG9zaXRpb24iLCJsaXN0Iiwic2VsZWN0Iiwic2VsZWN0ZWQiLCJyZXR1cm5PYmplY3QiLCJmb3JjZURlZmF1bHQiLCJkZWZhdWx0VGV4dCIsImJGb3JtIiwiaW5saW5lIiwiZm9ybUZpZWxkc2V0IiwiaW5wdXRTdGF0ZSIsImRlc2NyaWJlZEJ5IiwibGFiZWwiLCJsYWJlbFNyT25seSIsImxhYmVsTGF5b3V0IiwibGFiZWxBbGlnbkNsYXNzIiwiZm9yIiwibGFiZWxJZCIsImlucHV0TGF5b3V0IiwiZmVlZGJhY2siLCJmZWVkYmFja0lkIiwiZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbklkIiwiaG9yaXpvbnRhbCIsImxhYmVsU2l6ZSIsImxhYmVsVGV4dEFsaWduIiwidXBkYXRlVGFyZ2V0IiwiY29udGVudCIsImlucHV0U2VsZWN0b3IiLCJ1cGRhdGVkIiwiZm9ybU1peGluIiwiaW5wdXRDbGFzcyIsImN1c3RvbSIsInBsYWluIiwiZm9ybUNoZWNrQm94TWl4aW4iLCJjaGVja2JveENsYXNzIiwiZm9ybUNoZWNrYm94IiwiY2hlY2tlZCIsImlzQ2hlY2tlZCIsImNoYW5nZSIsImhhbmRsZUNoYW5nZSIsInVuY2hlY2tlZFZhbHVlIiwiaXNBcnJheSIsImNvbmNhdCIsImZvcm1PcHRpb25zIiwib3B0aW9ucyIsInZhbHVlRmllbGQiLCJ0ZXh0RmllbGQiLCJzZWxlY3RlZFZhbHVlIiwibG9jYWxWYWx1ZSIsImZvcm1SYWRpbyIsInN0YWNrZWQiLCJyZWZJbkZvciIsIl9xIiwiX19jIiwiYkZvcm1JbnB1dFN0YXRpYyIsInN0YXRpY1ZhbHVlIiwiZm9ybWF0dGVyIiwiRnVuY3Rpb24iLCJmb3JtSW5wdXQiLCJzdGF0aWMiLCJ0ZXh0YXJlYSIsInJlYWRvbmx5Iiwicm93cyIsInJvd3NDb3VudCIsInBsYWNlaG9sZGVyIiwiaW5wdXQiLCJvbklucHV0Iiwib25DaGFuZ2UiLCJvbktleVVwIiwiYmx1ciIsImZvcm1hdCIsImxhenlGb3JtYXR0ZXIiLCJmb3JtRmlsZSIsImRyYWdvdmVyIiwiZHJhZ2dpbmciLCJkcm9wTGFiZWwiLCJkcm9wIiwiZHJhZ2xlYXZlIiwiYWNjZXB0IiwibXVsdGlwbGUiLCJ3ZWJraXRkaXJlY3RvcnkiLCJkaXJlY3RvcnkiLCJvbkZpbGVDaGFuZ2UiLCJjb21wdXRlZENob29zZUxhYmVsIiwic2VsZWN0ZWRMYWJlbCIsInNlbGVjdGVkRmlsZSIsInNlbGVjdGVkRm9ybWF0IiwiY2hvb3NlTGFiZWwiLCJyZXNldCIsImRhdGFUcmFuc2ZlciIsIm5vVHJhdmVyc2UiLCJzZXRGaWxlcyIsImZpbGVzIiwid2Via2l0R2V0QXNFbnRyeSIsInRyYXZlcnNlRmlsZVRyZWUiLCJhbGwiLCJ0aGVuIiwibm9Ecm9wIiwiZHJvcEVmZmVjdCIsIlByb21pc2UiLCJpc0ZpbGUiLCJmaWxlIiwiJHBhdGgiLCJpc0RpcmVjdG9yeSIsImNyZWF0ZVJlYWRlciIsInJlYWRFbnRyaWVzIiwiZm9ybVNlbGVjdCIsIl92YWx1ZSIsImp1bWJvdHJvbiIsImZsdWlkIiwiY29udGFpbmVyRmx1aWQiLCJsZWFkIiwiYmFkZ2UiLCJiYWRnZVZhcmlhbnQiLCJiYWRnZVBpbGwiLCJwaWxsIiwibGlzdEdyb3VwIiwiZmx1c2giLCJsaW5rUHJvcHMkMSIsImFjdGlvblRhZ3MiLCJsaXN0R3JvdXBJdGVtIiwibXlUYWciLCJsaXN0U3RhdGUiLCJpc0FjdGlvbiIsImFjdGlvbiIsIm1lZGlhIiwicmlnaHRBbGlnbiIsInZlcnRpY2FsQWxpZ25DbGFzcyIsInZlcnRpY2FsQWxpZ24iLCJGT0NVU19TRUxFQ1RPUiIsIm1vZGFsIiwiaXNfdmlzaWJsZSIsImtleSIsImZhZGUiLCJub0ZhZGUiLCJvbkNsaWNrT3V0IiwiaGlkZUhlYWRlciIsImhpZGVIZWFkZXJDbG9zZSIsImhlYWRlckNsb3NlTGFiZWwiLCJoaWRlIiwiaGlkZUZvb3RlciIsIm9rT25seSIsImJ1dHRvblNpemUiLCJjbG9zZVRpdGxlIiwib2tEaXNhYmxlZCIsIm9rVGl0bGUiLCJyZXR1cm5fZm9jdXMiLCJyZXR1cm5Gb2N1cyIsIm5vQ2xvc2VPbkJhY2tkcm9wIiwibm9DbG9zZU9uRXNjIiwibm9BdXRvRm9jdXMiLCJlbmZvcmNlRm9jdXMiLCJpc09LIiwiY2FuY2VsIiwicmV0dXJuRm9jdXNUbyIsImFjdGl2ZUVsZW1lbnQiLCJuYXYiLCJpc05hdkJhciIsInRhYnMiLCJwaWxscyIsImZpbGwiLCJqdXN0aWZpZWQiLCJuYXZJdGVtIiwibmF2SXRlbURyb3Bkb3duIiwibmF2VG9nZ2xlIiwidG9nZ2xlU3RhdGUiLCJvbmNsaWNrIiwibmF2YmFyIiwiZml4ZWQiLCJzdGlja3kiLCJ0b2dnbGVhYmxlIiwidG9nZ2xlYWJsZUNsYXNzIiwidG9nZ2xlQnJlYWtwb2ludCIsIm5hdlRleHQiLCJuYXZGb3JtIiwiRUxMSVBTSVNfVEhSRVNIT0xEIiwicGFnaW5hdGlvbiIsImFyaWFMYWJlbCIsImZvY3VzQ3VycmVudCIsImZvY3VzUHJldiIsImhpZGVHb3RvRW5kQnV0dG9ucyIsImlzQWN0aXZlIiwiZmlyc3RUZXh0IiwiYnV0dG9uUm9sZSIsImxhYmVsRmlyc3RQYWdlIiwic2V0UGFnZSIsInByZXZUZXh0IiwibGFiZWxQcmV2UGFnZSIsImN1cnJlbnRQYWdlIiwic2hvd0ZpcnN0RG90cyIsImVsbGlwc2lzVGV4dCIsInBhZ2VMaXN0IiwicGFnZUl0ZW1DbGFzc2VzIiwicGFnZUxpbmtDbGFzc2VzIiwibGFiZWxQYWdlIiwibnVtYmVyT2ZQYWdlcyIsInNob3dMYXN0RG90cyIsIm5leHRUZXh0IiwibGFiZWxOZXh0UGFnZSIsImxhc3RUZXh0IiwibGFiZWxMYXN0UGFnZSIsIk1hdGgiLCJjZWlsIiwidG90YWxSb3dzIiwicGVyUGFnZSIsImxpbWl0IiwiaGlkZUVsbGlwc2lzIiwiZmxvb3IiLCJhIiwiY3VycmVudHBhZ2UiLCJnZXRCdXR0b25zIiwic2V0QnRuRm9jdXMiLCJyZXZlcnNlIiwicGFyc2VJbnQiLCJnZXRBdHRyaWJ1dGUiLCJUUklHR0VSX0xJU1RFTkVSUyIsImhvdmVyIiwiUExBQ0VNRU5UX1BBUkFNUyIsInRvcCIsImJvdHRvbSIsIlRFVEhFUl9DTEFTU19QUkVGSVgiLCJURVRIRVJfQ0xBU1NFUyIsImVsZW1lbnQiLCJlbmFibGVkIiwiVFJBTlNJVElPTl9EVVJBVElPTiIsInBvcG92ZXIkMSIsImNvbnN0cmFpbnRzIiwiZGVib3VuY2UiLCJ2YWxpZGF0b3IiLCJkZWxheSIsIm9mZnNldCIsInBsYWNlbWVudCIsInBvcG92ZXJTdHlsZSIsInRhcmdldE9mZnNldCIsInRyaWdnZXJzIiwidHJpZ2dlclN0YXRlIiwiY2xhc3NTdGF0ZSIsImxhc3RFdmVudCIsIm5vcm1hbGl6ZWRUcmlnZ2VycyIsInBvcG92ZXJBbGlnbm1lbnQiLCJzaG93U3RhdGUiLCJzZXRPcHRpb25zIiwidXBkYXRlTGlzdGVuZXJzIiwiZ2V0RGVsYXkiLCIkZGF0YSIsIl90aW1lb3V0IiwidG9nZ2xlUG9wb3ZlciIsImFkZExpc3RlbmVyIiwiX3RyaWdnZXIiLCJldmVudEhhbmRsZXIiLCJkZXN0cm95VGV0aGVyIiwiX3RldGhlciIsImRlc3Ryb3kiLCJ0aW1lU3RhbXAiLCJnZXRUZXRoZXJPcHRpb25zIiwiYXR0YWNobWVudCIsIl9wb3BvdmVyIiwiY2xhc3NlcyIsImNsYXNzUHJlZml4IiwiaGlkZVBvcG92ZXIiLCJkaXNwbGF5IiwicmVmcmVzaFBvc2l0aW9uIiwicmVtb3ZlTGlzdGVuZXIiLCJzaG93UG9wb3ZlciIsInRyaWdnZXIiLCJwb3BvdmVyIiwiYmVmb3JlRGVzdHJveSIsInBhcmVudEVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsInByb2dyZXNzIiwic3R5bGVPYmplY3QiLCJtYXgiLCJzaG93UHJvZ3Jlc3MiLCJzaG93VmFsdWUiLCJwcm9ncmVzc1ZhcmlhbnQiLCJzdHJpcGVkIiwiYW5pbWF0ZWQiLCJ3aWR0aCIsInBvdyIsInByZWNpc2lvbiIsInJvdW5kIiwicmVjVG9TdHJpbmciLCJfcm93VmFyaWFudCIsImRlZmF1bHRTb3J0Q29tcGFyZSIsImxvY2FsZUNvbXBhcmUiLCJudW1lcmljIiwidGFibGUiLCJ0YWJsZUNsYXNzIiwiYnVzeSIsImhlYWRDbGFzcyIsImZpZWxkcyIsImZpZWxkQ2xhc3MiLCJ0aFN0eWxlIiwic29ydGFibGUiLCJzb3J0RGVzYyIsInNvcnRCeSIsImxhYmVsU29ydEFzYyIsImxhYmVsU29ydERlc2MiLCJoZWFkQ2xpY2tlZCIsImNvbHVtbiIsImZpZWxkIiwiZm9vdENsb25lIiwiZm9vdENsYXNzIiwiJHNjb3BlZFNsb3RzIiwiX2l0ZW1zIiwicm93Q2xhc3MiLCJyb3dDbGlja2VkIiwicm93SG92ZXJlZCIsInRkQ2xhc3MiLCJpdGVtIiwic2hvd0VtcHR5IiwiY29sc3BhbiIsImVtcHR5RmlsdGVyZWRUZXh0IiwiZW1wdHlUZXh0IiwibG9jYWxJdGVtcyIsIml0ZW1zUHJvdmlkZXIiLCJib3JkZXJlZCIsInNtYWxsIiwicmVzcG9uc2l2ZSIsImhlYWRWYXJpYW50IiwiZm9vdFZhcmlhbnQiLCJzb3J0Q29tcGFyZSIsIm5vUHJvdmlkZXJQYWdpbmciLCJub1Byb3ZpZGVyU29ydGluZyIsIm5vUHJvdmlkZXJGaWx0ZXJpbmciLCJfcHJvdmlkZXJVcGRhdGUiLCJoYXNQcm92aWRlciIsInByb3ZpZGVyRmlsdGVyaW5nIiwicHJvdmlkZXJTb3J0aW5nIiwicHJvdmlkZXJQYWdpbmciLCJjb250ZXh0IiwibGFzdEluZGV4Iiwic29ydCIsInRoQ2xhc3MiLCJfY2VsbFZhcmlhbnRzIiwicmVmcmVzaCIsIl9wcm92aWRlclNldExvY2FsIiwibmF2U3R5bGUiLCJjdXJyZW50VGFiIiwicHJldmlvdXNUYWIiLCJuZXh0VGFiIiwic2V0VGFiIiwiaGVhZEh0bWwiLCJsb2NhbEFjdGl2ZSIsImNvbnRyb2xsZWRCeSIsImxhenkiLCIkc2V0Iiwic2lnbiIsInVwZGF0ZVRhYnMiLCJjb21wb25lbnRJbnN0YW5jZSIsInRhYnNDb250YWluZXIiLCJiaW5kIiwidGFiIiwibW9kZSIsImJlZm9yZUxlYXZlIiwiYnV0dG9uSWQiLCJ0b29sdGlwIiwib3BhY2l0eSIsImZyZWV6ZSIsImJBbGVydCIsImJCcmVhZGNydW1iIiwiYkJ1dHRvblRvb2xiYXIiLCJiQnRuVG9vbGJhciIsImJCdXR0b25Hcm91cCIsImJCdG5Hcm91cCIsImJCdXR0b25Hcm91cERyb3Bkb3duIiwiYkJ0bkdyb3VwRHJvcGRvd24iLCJiSW5wdXRHcm91cCIsImJJbnB1dEdyb3VwQWRkb24iLCJiSW5wdXRHcm91cEJ1dHRvbiIsImJJbnB1dEdyb3VwQnRuIiwiYkNhcmQiLCJiQ2FyZEdyb3VwIiwiYkRyb3Bkb3duIiwiYkRyb3Bkb3duSXRlbSIsImJEcm9wZG93bkl0ZW1CdXR0b24iLCJiRHJvcGRvd25JdGVtQnRuIiwiYkRyb3Bkb3duRGl2aWRlciIsImJEcm9wZG93bkhlYWRlciIsImJEcm9wZG93blNlbGVjdCIsImJGb3JtQ2hlY2tib3giLCJiRm9ybUZpZWxkc2V0IiwiYkZvcm1GaWxlIiwiYkZvcm1SYWRpbyIsImJGb3JtSW5wdXQiLCJiRm9ybVNlbGVjdCIsImJKdW1ib3Ryb24iLCJiQmFkZ2UiLCJiTWVkaWEiLCJiTW9kYWwiLCJiTmF2YmFyIiwiYk5hdlRleHQiLCJiTmF2Rm9ybSIsImJQYWdpbmF0aW9uIiwiYlBvcG92ZXIiLCJiUHJvZ3Jlc3MiLCJiVGFibGUiLCJiVG9vbHRpcCIsImJUYWIiLCJiVGFicyIsImJOYXYiLCJiTmF2SXRlbSIsImJOYXZJdGVtRHJvcGRvd24iLCJiTmF2VG9nZ2xlIiwiYkxpc3RHcm91cEl0ZW0iLCJiTGlzdEdyb3VwIiwiYkNhcm91c2VsU2xpZGUiLCJiQ2Fyb3VzZWwiLCJiQ29sbGFwc2UiLCJpbkJyb3dzZXIiLCJsaXN0ZW5fdHlwZXMiLCJsaXN0ZW5fdHlwZXMkMSIsIm1vZGFsJDEiLCJpbkJyb3dzZXIkMSIsImlzU2VydmVyIiwiRWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJOQU1FIiwiRVZFTlQiLCJCVlNTIiwibWV0aG9kIiwidGhyb3R0bGUiLCJEZWZhdWx0VHlwZSIsIkNsYXNzTmFtZSIsIkRST1BET1dOX0lURU0iLCJEUk9QRE9XTl9NRU5VIiwiRFJPUERPV05fVE9HR0xFIiwiTkFWX0xJTksiLCJMSVNUX0lURU0iLCJBQ1RJVkUiLCJOQVZfTElTVF9HUk9VUCIsIk5BViIsIkxJU1RfR1JPVVAiLCJEUk9QRE9XTiIsIk9mZnNldE1ldGhvZCIsIk9GRlNFVCIsIlBPU0lUSU9OIiwiYXJnIiwibGlzdGVuIiwiX2dldFNjcm9sbGVyIiwidGFnTmFtZSIsInVuTGlzdGVuIiwiX2dldFNjcm9sbFRvcCIsIl9nZXRTY3JvbGxIZWlnaHQiLCJjaGFyQXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvZmZzZXRUb3AiLCJwcm9jZXNzIiwiX2dldE9mZnNldEhlaWdodCIsIl9hY3RpdmF0ZSIsIl9jbGVhciIsImRpc3Bvc2UiLCJoYW5kbGVFdmVudCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJfc2V0QWN0aXZlU3RhdGUiLCJfc2V0UGFyZW50c1NpYmxpbmdBY3RpdmVTdGF0ZSIsIiRwcm9wcyIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJzY3JvbGxzcHkiLCJpbnNlcnRlZCIsInVwZGF0ZSIsImNvbXBvbmVudFVwZGF0ZWQiLCJ1bmJpbmQiLCJiVG9nZ2xlIiwiYlNjcm9sbHNweSIsIlZ1ZVBsdWdpbiIsImluc3RhbGwiLCJfYm9vdHN0cmFwX3Z1ZV9pbnN0YWxsZWQiLCJjb21wb25lbnQi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SUFBYXlLLFVBQWI7QUFBd0IxSyxVQUFFMnlCLFNBQUYsQ0FBWTF5QixDQUFaLEVBQWN5SyxXQUFXekssQ0FBWCxDQUFkO0FBQXhCLE9BQXFELEtBQUksSUFBSU8sQ0FBUixJQUFhZ1MsVUFBYjtBQUF3QnhTLFVBQUU0eUIsU0FBRixDQUFZcHlCLENBQVosRUFBY2dTLFdBQVdoUyxDQUFYLENBQWQ7QUFBeEI7QUFBcUQ7QUFBQyxHQUE5TCxFQUF4aEIsQ0FBd3RCLGVBQWEsT0FBT3FCLE1BQXBCLElBQTRCQSxPQUFPZ3hCLEdBQW5DLElBQXdDaHhCLE9BQU9neEIsR0FBUCxDQUFXQyxHQUFYLENBQWVOLFNBQWYsQ0FBeEMsQ0FBa0UsK0RBQWVBLFNBQWY7QUFDcjQvRiIsImZpbGUiOiI4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG9taXRMaW5rUHJvcHMoKXtmb3IodmFyIHQ9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspdFtlXT1hcmd1bWVudHNbZV07cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5pbmNsdWRlcyhuKXx8KGVbbl09cHJvcHNbbl0pLGV9LHt9KX1mdW5jdGlvbiBpc1Zpc2libGUodCl7cmV0dXJuIHQmJih0Lm9mZnNldFdpZHRoPjB8fHQub2Zmc2V0SGVpZ2h0PjApfWZ1bmN0aW9uIGZpbmRGaXJzdFZpc2libGUodCxlKXtpZighdHx8IXQucXVlcnlTZWxlY3RvckFsbHx8IWUpcmV0dXJuIG51bGw7Zm9yKHZhciBuPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQucXVlcnlTZWxlY3RvckFsbChlKSksaT1uLmZpbmQ/bi5maW5kKGZ1bmN0aW9uKHQpe3JldHVybiBpc1Zpc2libGUodCl9KTpudWxsLG89MDshaSYmbzxuLmxlbmd0aDtvKyspaXNWaXNpYmxlKG5bb10pJiYoaT1uW29dKTtyZXR1cm4gaX1mdW5jdGlvbiBpc1Zpc2libGUkMSh0KXtyZXR1cm4gdCYmKHQub2Zmc2V0V2lkdGg+MHx8dC5vZmZzZXRIZWlnaHQ+MCl9ZnVuY3Rpb24gbWFrZVBhZ2VBcnJheSh0LGUpe3JldHVybiBBcnJheS5hcHBseShudWxsLHtsZW5ndGg6ZX0pLm1hcChmdW5jdGlvbihlLG4pe3JldHVybntudW1iZXI6bit0LGNsYXNzTmFtZTpudWxsfX0pfWZ1bmN0aW9uIG9ic2VydmVET00odCxlLG4pe3ZhciBpPXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyfHx3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixvPXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO2k/bmV3IGkoZnVuY3Rpb24odCl7KHRbMF0uYWRkZWROb2Rlcy5sZW5ndGg+MHx8dFswXS5yZW1vdmVkTm9kZXMubGVuZ3RoPjApJiZlKCl9KS5vYnNlcnZlKHQsT2JqZWN0LmFzc2lnbih7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9LG4pKTpvJiYodC5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsZSwhMSksdC5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIixlLCExKSl9ZnVuY3Rpb24gdGFyZ2V0cyh0LGUsbixpKXt2YXIgbz10Ll9fdnVlX187aWYoIW8pcmV0dXJuIGNvbnNvbGUud2FybihcIl9fdnVlX18gaXMgbm90IGF2YWlsYWJsZSBvbiBlbGVtZW50XCIsdCksW107dmFyIHI9T2JqZWN0LmtleXMoZS5tb2RpZmllcnN8fHt9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIWFsbF9saXN0ZW5fdHlwZXNbdF19KTtlLnZhbHVlJiZyLnB1c2goZS52YWx1ZSk7dmFyIHM9ZnVuY3Rpb24oKXtpKHt0YXJnZXRzOnIsdm06b30pfTtyZXR1cm4gT2JqZWN0LmtleXMoYWxsX2xpc3Rlbl90eXBlcykuZm9yRWFjaChmdW5jdGlvbihpKXsobltpXXx8ZS5tb2RpZmllcnNbaV0pJiZ0LmFkZEV2ZW50TGlzdGVuZXIoaSxzKX0pLHJ9ZnVuY3Rpb24gaXNFbGVtZW50KHQpe3JldHVybiB0Lm5vZGVUeXBlfWZ1bmN0aW9uIGNsb3Nlc3QodCxlKXt2YXIgbj10LmNsb3Nlc3QoZSk7cmV0dXJuIG49PT10P251bGw6bn1mdW5jdGlvbiAkUVNBKHQsZSl7cmV0dXJuIGV8fChlPWRvY3VtZW50KSxpc0VsZW1lbnQoZSk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5xdWVyeVNlbGVjdG9yQWxsKHQpKTpbXX1mdW5jdGlvbiAkUVModCxlKXtyZXR1cm4gZXx8KGU9ZG9jdW1lbnQpLGlzRWxlbWVudChlKT9lLnF1ZXJ5U2VsZWN0b3IodCl8fG51bGw6bnVsbH1mdW5jdGlvbiBnZXRWbSh0KXtyZXR1cm4gdD90Ll9fdnVlX186bnVsbH1mdW5jdGlvbiB0b1R5cGUodCl7cmV0dXJue30udG9TdHJpbmcuY2FsbCh0KS5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHR5cGVDaGVja0NvbmZpZyh0LGUsbil7Zm9yKHZhciBpIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4saSkpe3ZhciBvPW5baV0scj1lW2ldLHM9ciYmaXNFbGVtZW50KHIpP1wiZWxlbWVudFwiOnRvVHlwZShyKTtuZXcgUmVnRXhwKG8pLnRlc3Qocyl8fGNvbnNvbGUuZXJyb3IodCsnOiBPcHRpb24gXCInK2krJ1wiIHByb3ZpZGVkIHR5cGUgXCInK3MrJ1wiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJytvKydcIicpfX1mdW5jdGlvbiBTY3JvbGxTcHkodCxlKXt0aGlzLl8kZWw9dCx0aGlzLl9zZWxlY3Rvcj1bU2VsZWN0b3IuTkFWX0xJTktTLFNlbGVjdG9yLkxJU1RfSVRFTVMsU2VsZWN0b3IuRFJPUERPV05fSVRFTVNdLmpvaW4oXCIsXCIpLHRoaXMuX2NvbmZpZz1PYmplY3QuYXNzaWduKHt9LERlZmF1bHQpLHRoaXMuX29mZnNldHM9W10sdGhpcy5fdGFyZ2V0cz1bXSx0aGlzLl9hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLl9zY3JvbGxIZWlnaHQ9MCx0aGlzLl8kcm9vdD1udWxsLHRoaXMuX3Jlc2l6ZVRpbWVvdXQ9bnVsbCx0aGlzLnVwZGF0ZUNvbmZpZyhlKX1pbXBvcnQgVGV0aGVyIGZyb21cInRldGhlclwiO3ZhciB3YXJuPWZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIltCb290c3RyYXAtVnVlIHdhcm5dOiBcIit0KX0sYWxlcnQ9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gdC5sb2NhbFNob3c/bihcImRpdlwiLHtjbGFzczp0LmNsYXNzT2JqZWN0LGF0dHJzOntyb2xlOlwiYWxlcnRcIixcImFyaWEtbGl2ZVwiOlwicG9saXRlXCIsXCJhcmlhLWF0b21pY1wiOlwidHJ1ZVwifX0sW3QuZGlzbWlzc2libGU/bihcImJ1dHRvblwiLHtzdGF0aWNDbGFzczpcImNsb3NlXCIsYXR0cnM6e3R5cGU6XCJidXR0b25cIixcImRhdGEtZGlzbWlzc1wiOlwiYWxlcnRcIixcImFyaWEtbGFiZWxcIjpcImRpc21pc3NMYWJlbFwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5kaXNtaXNzKGUpfX19LFtuKFwic3BhblwiLHthdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0sW3QuX3YoXCLDl1wiKV0pXSk6dC5fZSgpLHQuX3QoXCJkZWZhdWx0XCIpXSwyKTp0Ll9lKCl9LHN0YXRpY1JlbmRlckZuczpbXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2NvdW50RG93blRpbWVySWQ6bnVsbCxkaXNtaXNzZWQ6ITF9fSxjcmVhdGVkOmZ1bmN0aW9uKCl7dGhpcy5zdGF0ZSYmd2FybignPGItYWxlcnQ+IFwic3RhdGVcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFwidmFyaWFudFwiIHByb3BlcnR5IGluc3RlYWQuJyl9LGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybltcImFsZXJ0XCIsdGhpcy5hbGVydFZhcmlhbnQsdGhpcy5kaXNtaXNzaWJsZT9cImFsZXJ0LWRpc21pc3NpYmxlXCI6XCJcIl19LGFsZXJ0VmFyaWFudDpmdW5jdGlvbigpe3JldHVyblwiYWxlcnQtXCIrKHRoaXMuc3RhdGV8fHRoaXMudmFyaWFudHx8XCJpbmZvXCIpfSxsb2NhbFNob3c6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5kaXNtaXNzZWQmJih0aGlzLmNvdW50RG93blRpbWVySWR8fHRoaXMuc2hvdyl9fSxwcm9wczp7dmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImluZm9cIn0sc3RhdGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sZGlzbWlzc2libGU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxkaXNtaXNzTGFiZWw6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJDbG9zZVwifSxzaG93Ont0eXBlOltCb29sZWFuLE51bWJlcl0sZGVmYXVsdDohMX19LHdhdGNoOntzaG93OmZ1bmN0aW9uKCl7dGhpcy5zaG93Q2hhbmdlZCgpfX0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMuc2hvd0NoYW5nZWQoKX0sbWV0aG9kczp7ZGlzbWlzczpmdW5jdGlvbigpe3RoaXMuZGlzbWlzc2VkPSEwLHRoaXMuJGVtaXQoXCJkaXNtaXNzZWRcIiksdGhpcy5jbGVhckNvdW50ZXIoKX0sY2xlYXJDb3VudGVyOmZ1bmN0aW9uKCl7dGhpcy5jb3VudERvd25UaW1lcklkJiZjbGVhckludGVydmFsKHRoaXMuY291bnREb3duVGltZXJJZCl9LHNob3dDaGFuZ2VkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZih0aGlzLmRpc21pc3NlZD0hMSwhMCE9PXRoaXMuc2hvdyYmITEhPT10aGlzLnNob3cmJm51bGwhPT10aGlzLnNob3cmJjAhPT10aGlzLnNob3cpe3ZhciBlPXRoaXMuc2hvdzt0aGlzLiRlbWl0KFwiZGlzbWlzcy1jb3VudC1kb3duXCIsZSksdGhpcy5jbGVhckNvdW50ZXIoKSx0aGlzLmNvdW50RG93blRpbWVySWQ9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtpZihlPDIpcmV0dXJuIHQuZGlzbWlzcygpO2UtLSx0LiRlbWl0KFwiZGlzbWlzcy1jb3VudC1kb3duXCIsZSl9LDFlMyl9fX19LHByb3BzPXthY3RpdmU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxhY3RpdmVDbGFzczp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImFjdGl2ZVwifSxhcHBlbmQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGV2ZW50Ont0eXBlOltTdHJpbmcsQXJyYXldLGRlZmF1bHQ6XCJjbGlja1wifSxleGFjdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGV4YWN0QWN0aXZlQ2xhc3M6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJhY3RpdmVcIn0saHJlZjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiNcIn0scmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHJlcGxhY2U6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyb3V0ZXJUYWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJhXCJ9LHRhZzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSx0YXJnZXQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJfc2VsZlwifSx0bzp7dHlwZTpbU3RyaW5nLE9iamVjdF0sZGVmYXVsdDpudWxsfX0sY29tcHV0ZWQ9e2xpbmtQcm9wczpmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVtuXT10W25dLGV9LHt9KX0saXNSb3V0ZXJMaW5rOmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy4kcm91dGVyJiZ0aGlzLnRvJiYhdGhpcy5kaXNhYmxlZCl9LF9ocmVmOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzYWJsZWQ/XCIjXCI6dGhpcy5ocmVmP3RoaXMuaHJlZjp0aGlzLnRvJiZcInN0cmluZ1wiPT10eXBlb2YgdGhpcy50bz90aGlzLnRvOnZvaWQgMH0sY29tcHV0ZWRSZWw6ZnVuY3Rpb24oKXtyZXR1cm5cIl9ibGFua1wiPT09dGhpcy50YXJnZXQmJm51bGw9PT10aGlzLnJlbD9cIm5vb3BlbmVyXCI6dGhpcy5yZWx8fG51bGx9LGNvbXBvbmVudFRhZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRhZz8od2FybignPGItbGluaz4gXCJ0YWdcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFwicm91dGVyVGFnXCIgcHJvcGVydHkgaW5zdGVhZC4nKSx0aGlzLnRhZyk6dGhpcy5yb3V0ZXJUYWd9LGxpbmtDbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVyblt0aGlzLmFjdGl2ZT90aGlzLmV4YWN0P3RoaXMuZXhhY3RBY3RpdmVDbGFzczp0aGlzLmFjdGl2ZUNsYXNzOm51bGwsdGhpcy5kaXNhYmxlZD9cImRpc2FibGVkXCI6bnVsbF19fSxtZXRob2RzPXtsaW5rQ2xpY2s6ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZD90LnN0b3BQcm9wYWdhdGlvbigpOih0aGlzLiRyb290LiRlbWl0KFwiY2xpY2tlZDo6bGlua1wiLHRoaXMpLHRoaXMuJGVtaXQoXCJjbGlja1wiLHQpKSx0aGlzLmlzUm91dGVyTGlua3x8XCIjXCIhPT10aGlzLl9ocmVmfHx0LnByZXZlbnREZWZhdWx0KCl9fSxsaW5rTWl4aW49e3Byb3BzOnByb3BzLGNvbXB1dGVkOmNvbXB1dGVkLG1ldGhvZHM6bWV0aG9kc30sYkxpbms9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gdC5pc1JvdXRlckxpbms/bihcInJvdXRlci1saW5rXCIse3RhZzpcImFcIixjbGFzczp0LmxpbmtDbGFzc09iamVjdCxhdHRyczp7XCJhY3RpdmUtY2xhc3NcIjp0LmFjdGl2ZUNsYXNzLFwiZXhhY3QtYWN0aXZlLWNsYXNzXCI6dC5leGFjdEFjdGl2ZUNsYXNzLGRpc2FibGVkOnQuZGlzYWJsZWQsXCJhcmlhLWRpc2FibGVkXCI6dC5kaXNhYmxlZD9cInRydWVcIjpcImZhbHNlXCIsdG86dC50byxleGFjdDp0LmV4YWN0LGFwcGVuZDp0LmFwcGVuZCxyZXBsYWNlOnQucmVwbGFjZSxldmVudDp0LmV2ZW50LHRhZzp0LmNvbXBvbmVudFRhZ30sbmF0aXZlT246e2NsaWNrOmZ1bmN0aW9uKGUpe3QubGlua0NsaWNrKGUpfX19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMik6bihcImFcIix7Y2xhc3M6dC5saW5rQ2xhc3NPYmplY3QsYXR0cnM6e2Rpc2FibGVkOnQuZGlzYWJsZWQsXCJhcmlhLWRpc2FibGVkXCI6dC5kaXNhYmxlZD9cInRydWVcIjpcImZhbHNlXCIsaHJlZjp0Ll9ocmVmLHRhcmdldDp0LnRhcmdldHx8bnVsbCxyZWw6dC5jb21wdXRlZFJlbH0sb246e2NsaWNrOnQubGlua0NsaWNrfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbbGlua01peGluXX0sYkxpbmtQcm9wS2V5cz1PYmplY3Qua2V5cyhwcm9wcyksYnJlYWRjcnVtYj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwib2xcIix7c3RhdGljQ2xhc3M6XCJicmVhZGNydW1iXCJ9LFt0Ll9sKHQubm9ybWFsaXplZEl0ZW1zLGZ1bmN0aW9uKGUpe3JldHVybiBuKFwibGlcIix7Y2xhc3M6W1wiYnJlYWRjcnVtYi1pdGVtXCIsZS5hY3RpdmU/XCJhY3RpdmVcIjpudWxsXSxhdHRyczp7cm9sZTpcInByZXNlbnRhdGlvblwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24obil7dC5vbkNsaWNrKGUuX29yaWdpbmFsSXRlbSl9fX0sW2UuYWN0aXZlP24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtY3VycmVudFwiOnQuYXJpYUN1cnJlbnR9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyhlLnRleHQpfX0pOm4oXCJiLWxpbmtcIix0Ll9iKHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS50ZXh0KX19LFwiYi1saW5rXCIsZS5fbGlua1Byb3BzKSldLDEpfSksdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcG9uZW50czp7Ykxpbms6Ykxpbmt9LGNvbXB1dGVkOntub3JtYWxpemVkSXRlbXM6ZnVuY3Rpb24oKXt2YXIgdD0hMSxlPXRoaXMuaXRlbXMubGVuZ3RoO3JldHVybiB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbihuLGkpe3ZhciBvPXtfb3JpZ2luYWxJdGVtOm59LHI9aT09PWUtMTtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygbj9PYmplY3QuYXNzaWduKG8se3RleHQ6bixsaW5rOlwiI1wiLGFjdGl2ZTpyfSk6T2JqZWN0LmFzc2lnbihvLG4pLCEwPT09by5hY3RpdmV8fCExPT09by5hY3RpdmV8fHQ/by5hY3RpdmUmJih0PSEwKTpvLmFjdGl2ZT1yLG8ubGluayYmKG8uaHJlZj1vLmxpbmspLG8uX2xpbmtQcm9wcz1PYmplY3Qua2V5cyhvKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gYkxpbmtQcm9wS2V5cy5pbmNsdWRlcyhlKSYmKHRbZV09b1tlXSksdH0se30pLG99KX19LHByb3BzOntpdGVtczp7dHlwZTpBcnJheSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuW119LHJlcXVpcmVkOiEwfSxhcmlhQ3VycmVudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImxvY2F0aW9uXCJ9fSxtZXRob2RzOntvbkNsaWNrOmZ1bmN0aW9uKHQpe3RoaXMuJGVtaXQoXCJjbGlja1wiLHQpfX19LGxpbmtQcm9wcz1PYmplY3QuYXNzaWduKG9taXRMaW5rUHJvcHMoXCJocmVmXCIsXCJ0b1wiKSx7aHJlZjp7dHlwZTpwcm9wcy5ocmVmLnR5cGV9LHRvOnt0eXBlOnByb3BzLnRvLnR5cGV9fSksYkJ0bj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKHQuY29tcG9uZW50VHlwZSx0Ll9iKHt0YWc6XCJidXR0b25cIixjbGFzczp0LmNsYXNzTGlzdCxhdHRyczp7dHlwZTp0LmJ0blR5cGUsZGlzYWJsZWQ6dC5kaXNhYmxlZH0sb246e2NsaWNrOnQub25DbGlja319LFwiYnV0dG9uXCIsdC5jb25kaXRpb25hbExpbmtQcm9wcyksW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXBvbmVudHM6e2JMaW5rOmJMaW5rfSxjb21wdXRlZDp7bGlua1Byb3BzOmNvbXB1dGVkLmxpbmtQcm9wcyxjbGFzc0xpc3Q6ZnVuY3Rpb24oKXtyZXR1cm5bXCJidG5cIix0aGlzLmJ0blZhcmlhbnQsdGhpcy5idG5TaXplLHRoaXMuYnRuQmxvY2ssdGhpcy5idG5EaXNhYmxlZF19LGNvbXBvbmVudFR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ocmVmfHx0aGlzLnRvP1wiYi1saW5rXCI6XCJidXR0b25cIn0sYnRuQmxvY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ibG9jaz9cImJ0bi1ibG9ja1wiOlwiXCJ9LGJ0blZhcmlhbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YXJpYW50P1wiYnRuLVwiK3RoaXMudmFyaWFudDpcImJ0bi1zZWNvbmRhcnlcIn0sYnRuU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemU/XCJidG4tXCIrdGhpcy5zaXplOlwiXCJ9LGJ0bkRpc2FibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzYWJsZWQ/XCJkaXNhYmxlZFwiOlwiXCJ9LGJ0blR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ocmVmfHx0aGlzLnRvP251bGw6dGhpcy50eXBlfSxjb25kaXRpb25hbExpbmtQcm9wczpmdW5jdGlvbigpe3JldHVyblwiYnV0dG9uXCI9PT10aGlzLmNvbXBvbmVudFR5cGU/e306dGhpcy5saW5rUHJvcHN9fSxwcm9wczpPYmplY3QuYXNzaWduKGxpbmtQcm9wcyx7YmxvY2s6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHNpemU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sdmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSx0eXBlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiYnV0dG9uXCJ9fSksbWV0aG9kczp7b25DbGljazpmdW5jdGlvbih0KXt0aGlzLmRpc2FibGVkPyh0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSk6dGhpcy4kZW1pdChcImNsaWNrXCIsdCl9fX0sSVRFTV9TRUxFQ1RPUj1bJy5idG46bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTogbm9uZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0pJywnLmZvcm0tY29udHJvbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6bm9uZVwiXSknLCdzZWxlY3Q6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTogbm9uZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0pJywnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6IG5vbmVcIl0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTpub25lXCJdKScsJ2lucHV0W3R5cGU9XCJyYWRpb1wiXTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6bm9uZVwiXSknXS5qb2luKFwiLFwiKSxidXR0b25Ub29sYmFyPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7Y2xhc3M6dC5jbGFzc09iamVjdCxhdHRyczp7cm9sZTpcInRvb2xiYXJcIix0YWJpbmRleDp0LmtleU5hdj9cIjBcIjpudWxsfSxvbjp7Zm9jdXNpbjpmdW5jdGlvbihlKXtpZihlLnRhcmdldCE9PWUuY3VycmVudFRhcmdldClyZXR1cm4gbnVsbDt0LmZvY3VzRmlyc3QoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpP1wiYnV0dG9uXCJpbiBlJiYwIT09ZS5idXR0b24/bnVsbDp2b2lkIHQuZm9jdXNOZXh0KGUsITApOm51bGx9LGZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcInVwXCIsMzgpKXJldHVybiBudWxsO3QuZm9jdXNOZXh0KGUsITApfSxmdW5jdGlvbihlKXtyZXR1cm5cImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwicmlnaHRcIiwzOSk/XCJidXR0b25cImluIGUmJjIhPT1lLmJ1dHRvbj9udWxsOnZvaWQgdC5mb2N1c05leHQoZSwhMSk6bnVsbH0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpKSYmZS5zaGlmdEtleT9cImJ1dHRvblwiaW4gZSYmMCE9PWUuYnV0dG9uP251bGw6dm9pZCB0LmZvY3VzRmlyc3QoZSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSkmJmUuc2hpZnRLZXk/dm9pZCB0LmZvY3VzRmlyc3QoZSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJyaWdodFwiLDM5KSkmJmUuc2hpZnRLZXk/XCJidXR0b25cImluIGUmJjIhPT1lLmJ1dHRvbj9udWxsOnZvaWQgdC5mb2N1c0xhc3QoZSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJkb3duXCIsNDApKSYmZS5zaGlmdEtleT92b2lkIHQuZm9jdXNMYXN0KGUpOm51bGx9XX19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm5bXCJidG4tdG9vbGJhclwiLHRoaXMuanVzdGlmeSYmIXRoaXMudmVydGljYWw/XCJqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiOlwiXCJdfX0scHJvcHM6e2p1c3RpZnk6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxLZXlOYXY6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX0sbWV0aG9kczp7c2V0SXRlbUZvY3VzOmZ1bmN0aW9uKHQpe3RoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7dC5mb2N1cygpfSl9LGZvY3VzTmV4dDpmdW5jdGlvbih0LGUpe2lmKHRoaXMua2V5TmF2KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKTt2YXIgbj10aGlzLmdldEl0ZW1zKCk7aWYoIShuLmxlbmd0aDwxKSl7dmFyIGk9bi5pbmRleE9mKHQudGFyZ2V0KTtlJiZpPjA/aS0tOiFlJiZpPG4ubGVuZ3RoLTEmJmkrKyxpPDAmJihpPTApLHRoaXMuc2V0SXRlbUZvY3VzKG5baV0pfX19LGZvY3VzRmlyc3Q6ZnVuY3Rpb24odCl7aWYodGhpcy5rZXlOYXYpe3QucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpO3ZhciBlPXRoaXMuZ2V0SXRlbXMoKTtlLmxlbmd0aD4wJiZ0aGlzLnNldEl0ZW1Gb2N1cyhlWzBdKX19LGZvY3VzTGFzdDpmdW5jdGlvbih0KXtpZih0aGlzLmtleU5hdil7dC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIGU9dGhpcy5nZXRJdGVtcygpO2UubGVuZ3RoPjAmJnRoaXMuc2V0SXRlbUZvY3VzKFtlLmxlbmd0aC0xXSl9fSxnZXRJdGVtczpmdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoSVRFTV9TRUxFQ1RPUikpO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7dC50YWJJbmRleD0tMX0pLHR9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5rZXlOYXYmJnRoaXMuZ2V0SXRlbXMoKX19LGJ1dHRvbkdyb3VwPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7Y2xhc3M6dC5jbGFzc09iamVjdH0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybltcImJ0bi1ncm91cFwiLHRoaXMudmVydGljYWw/XCJidG4tZ3JvdXAtdmVydGljYWxcIjpcIlwiLHRoaXMuanVzdGlmeSYmIXRoaXMudmVydGljYWw/XCJqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiOlwiXCIsdGhpcy5zaXplP1wiYnRuLWdyb3VwLVwiK3RoaXMuc2l6ZTpcIlwiXX19LHByb3BzOnt2ZXJ0aWNhbDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGp1c3RpZnk6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9fX0sY2xpY2tPdXQ9e21vdW50ZWQ6ZnVuY3Rpb24oKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9jbGlja091dExpc3RlbmVyKX0sZGVzdHJveWVkOmZ1bmN0aW9uKCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9jbGlja091dExpc3RlbmVyKX0sbWV0aG9kczp7X2NsaWNrT3V0TGlzdGVuZXI6ZnVuY3Rpb24odCl7dGhpcy4kZWwuY29udGFpbnModC50YXJnZXQpfHx0aGlzLmNsaWNrT3V0TGlzdGVuZXImJnRoaXMuY2xpY2tPdXRMaXN0ZW5lcigpfX19LElURU1fU0VMRUNUT1IkMT0nLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTogbm9uZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0pJyxIRUFERVJfU0VMRUNUT1I9Jy5kcm9wZG93bi1oZWFkZXI6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6bm9uZVwiXSknLEFMTF9TRUxFQ1RPUj1bSVRFTV9TRUxFQ1RPUiQxLEhFQURFUl9TRUxFQ1RPUl0uam9pbihcIixcIiksZHJvcGRvd249e3Byb3BzOntzcGxpdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHRleHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJcIn0sZHJvcHVwOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGlzYWJsZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyaWdodDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxjcmVhdGVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKGUpe2UhPT10JiYodC52aXNpYmxlPSExKX07dGhpcy4kcm9vdC4kb24oXCJzaG93bjo6ZHJvcGRvd25cIixlKSx0aGlzLiRyb290LiRvbihcImNsaWNrZWQ6OmxpbmtcIixlKX0sd2F0Y2g6e3Zpc2libGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3QhPT1lJiYodD8odGhpcy4kcm9vdC4kZW1pdChcInNob3duOjpkcm9wZG93blwiLHRoaXMpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbih0KXt0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIixuLm5vb3ApfSkpOih0aGlzLiRyb290LiRlbWl0KFwiaGlkZGVuOjpkcm9wZG93blwiLHRoaXMpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbih0KXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIixuLm5vb3ApfSkpKX19LG1ldGhvZHM6e25vb3A6ZnVuY3Rpb24oKXt9LHRvZ2dsZTpmdW5jdGlvbigpe3RoaXMuZGlzYWJsZWQ/dGhpcy52aXNpYmxlPSExOih0aGlzLnZpc2libGU9IXRoaXMudmlzaWJsZSx0aGlzLnZpc2libGUmJnRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRGaXJzdEl0ZW0oKTt0JiZ0aGlzLmZvY3VzSXRlbSgwLFt0XSl9KSl9LG9uVGFiOmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlJiYodGhpcy52aXNpYmxlPSExKX0sb25Fc2M6ZnVuY3Rpb24odCl7dGhpcy52aXNpYmxlJiYodGhpcy52aXNpYmxlPSExLHQucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpLHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7dmFyIHQ7KHQ9dGhpcy5zcGxpdCYmdGhpcy4kcmVmcy50b2dnbGU/dGhpcy4kcmVmcy50b2dnbGUuJGVsfHx0aGlzLiRyZWZzLnRvZ2dsZTp0aGlzLiRyZWZzLmJ1dHRvbi4kZWx8fHRoaXMuJHJlZnMuYnV0dG9uKSYmdC5mb2N1cyYmdC5mb2N1cygpfSkpfSxmb2N1c05leHQ6ZnVuY3Rpb24odCxlKXtpZih0aGlzLnZpc2libGUpe3QucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpO3ZhciBuPXRoaXMuZ2V0SXRlbXMoKTtpZighKG4ubGVuZ3RoPDEpKXt2YXIgaT1uLmluZGV4T2YodC50YXJnZXQpO2UmJmk+MD9pLS06IWUmJmk8bi5sZW5ndGgtMSYmaSsrLGk8MCYmKGk9MCksdGhpcy5mb2N1c0l0ZW0oaSxuKX19fSxmb2N1c0hvdmVyZWQ6ZnVuY3Rpb24odCl7aWYodGhpcy52aXNpYmxlKXt2YXIgZT10aGlzLmdldEl0ZW1zKCk7aWYoIShlLmxlbmd0aDwxKSl7dmFyIG49ZS5pbmRleE9mKHQudGFyZ2V0KTtuPi0xJiYodC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCksdGhpcy5mb2N1c0l0ZW0obixlKSl9fX0sZm9jdXNJdGVtOmZ1bmN0aW9uKHQsZSl7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7bj09PXQ/KGUuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKSxlLmZvY3VzKCkpOmUuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKX0pfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLiRyZWZzLm1lbnUucXVlcnlTZWxlY3RvckFsbChBTExfU0VMRUNUT1IpKX0sZ2V0Rmlyc3RJdGVtOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kcmVmcy5tZW51LnF1ZXJ5U2VsZWN0b3IoSVRFTV9TRUxFQ1RPUiQxKTtyZXR1cm4gdHx8KHQ9dGhpcy4kcmVmcy5tZW51LnF1ZXJ5U2VsZWN0b3IoSEVBREVSX1NFTEVDVE9SKSksdHx8bnVsbH19fSxidXR0b25Hcm91cERyb3Bkb3duPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIix7Y2xhc3M6W1wiYnRuLWdyb3VwXCIsXCJkcm9wZG93blwiLHtkcm9wdXA6dC5kcm9wdXAsc2hvdzp0LnZpc2libGV9XSxhdHRyczp7aWQ6dC5pZHx8bnVsbH19LFtuKFwiYi1idXR0b25cIix7cmVmOlwiYnV0dG9uXCIsY2xhc3M6e1wiZHJvcGRvd24tdG9nZ2xlXCI6IXQuc3BsaXQsXCJidG4tbGlua1wiOnQubGlua30sYXR0cnM6e2lkOnQuaWQ/dC5pZCtcIl9fQlZfYnV0dG9uX1wiOm51bGwsXCJhcmlhLWV4cGFuZGVkXCI6dC52aXNpYmxlP1widHJ1ZVwiOlwiZmFsc2VcIix2YXJpYW50OnQudmFyaWFudCxzaXplOnQuc2l6ZSxkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5jbGljayhlKX0sa2Vkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LmNsaWNrKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LmNsaWNrKGUpfV19fSxbdC5fdChcInRleHRcIixbdC5fdih0Ll9zKHQudGV4dCkpXSldLDIpLG4oXCJkaXZcIix7cmVmOlwibWVudVwiLGNsYXNzOltcImRyb3Bkb3duLW1lbnVcIix7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6dC5yaWdodH1dLGF0dHJzOntyb2xlOlwibWVudVwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6dC5pZD90LmlkK1wiX19CVl9idXR0b25fXCI6bnVsbH0sb246e2tleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ0YWJcIiw5KSlyZXR1cm4gbnVsbDt0Lm9uVGFiKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCEwKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX1dLG1vdXNlb3ZlcjpmdW5jdGlvbihlKXt0LmZvY3VzSG92ZXJlZChlKX19fSxbdC5fdChcImRlZmF1bHRcIildLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbY2xpY2tPdXQsZHJvcGRvd25dLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dmlzaWJsZTohMX19LGNvbXB1dGVkOntkcm9wZG93blRvZ2dsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhcmV0P1wiZHJvcGRvd24tdG9nZ2xlXCI6XCJcIn19LHByb3BzOntpZDp7dHlwZTpTdHJpbmd9LGNhcmV0Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMH19LG1ldGhvZHM6e2NsaWNrT3V0TGlzdGVuZXI6ZnVuY3Rpb24oKXt0aGlzLnZpc2libGU9ITF9fX0saW5wdXRHcm91cD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse2NsYXNzOnQuY2xhc3NPYmplY3QsYXR0cnM6e3JvbGU6XCJncm91cFwifX0sW3QuX3QoXCJsZWZ0XCIsW3QubGVmdD9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiaW5wdXQtZ3JvdXAtYWRkb25cIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5sZWZ0KX19KTp0Ll9lKCldKSx0Ll90KFwiZGVmYXVsdFwiKSx0Ll90KFwicmlnaHRcIixbdC5yaWdodD9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiaW5wdXQtZ3JvdXAtYWRkb25cIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5yaWdodCl9fSk6dC5fZSgpXSldLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcHV0ZWQ6e2NsYXNzT2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuW1wiaW5wdXQtZ3JvdXBcIix0aGlzLnNpemU/XCJpbnB1dC1ncm91cC1cIit0aGlzLnNpemU6XCJcIix0aGlzLnN0YXRlP1wiaGFzLVwiK3RoaXMuc3RhdGU6XCJcIl19fSxwcm9wczp7c2l6ZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxzdGF0ZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxsZWZ0Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHJpZ2h0Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9fX0saW5wdXRHcm91cEFkZG9uPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJpbnB1dC1ncm91cC1hZGRvblwiLGF0dHJzOntpZDp0LmlkfHxudWxsfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLHByb3BzOntpZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfX19LGlucHV0R3JvdXBCdXR0b249e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKShcImRpdlwiLHtzdGF0aWNDbGFzczpcImlucHV0LWdyb3VwLWJ0blwifSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10scHJvcHM6e319LGNhcmQ9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbih0LnRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wiY2FyZFwiLHQuY2FyZFZhcmlhbnQsdC5jYXJkQWxpZ24sdC5jYXJkSW52ZXJzZV19LFt0Ll90KFwiaW1nXCIsW3QuaW1nP24oXCJpbWdcIix7c3RhdGljQ2xhc3M6XCJjYXJkLWltZ1wiLGF0dHJzOntzcmM6dC5pbWcsYWx0OnQuaW1nQWx0fX0pOnQuX2UoKV0pLHQuaGVhZGVyfHx0LiRzbG90cy5oZWFkZXI/bih0LmhlYWRlclRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wiY2FyZC1oZWFkZXJcIix0LmhlYWRlclZhcmlhbnQ/XCJiZy1cIit0LmhlYWRlclZhcmlhbnQ6XCJcIix0LmhlYWRlckNsYXNzXX0sW3QuX3QoXCJoZWFkZXJcIixbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5oZWFkZXIpfX0pXSldLDIpOnQuX2UoKSx0Lm5vQmxvY2s/W3QuX3QoXCJkZWZhdWx0XCIpXTpuKFwiZGl2XCIse2NsYXNzOnQuYmxvY2tDbGFzc30sW3QudGl0bGU/bihcImg0XCIse3N0YXRpY0NsYXNzOlwiY2FyZC10aXRsZVwiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnRpdGxlKX19KTp0Ll9lKCksdC5zdWJUaXRsZT9uKFwiaDZcIix7c3RhdGljQ2xhc3M6XCJjYXJkLXN1YnRpdGxlIG1iLTIgdGV4dC1tdXRlZFwiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnN1YlRpdGxlKX19KTp0Ll9lKCksdC5fdChcImRlZmF1bHRcIildLDIpLHQuZm9vdGVyfHx0LiRzbG90cy5mb290ZXI/bih0LmZvb3RlclRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wiY2FyZC1mb290ZXJcIix0LmZvb3RlclZhcmlhbnQ/XCJiZy1cIit0LmZvb3RlclZhcmlhbnQ6XCJcIix0LmZvb3RlckNsYXNzXX0sW3QuX3QoXCJmb290ZXJcIixbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5mb290ZXIpfX0pXSldLDIpOnQuX2UoKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7YmxvY2tDbGFzczpmdW5jdGlvbigpe3JldHVybltcImNhcmQtYmxvY2tcIix0aGlzLm92ZXJsYXk/XCJjYXJkLWltZy1vdmVybGF5XCI6bnVsbF19LGNhcmRWYXJpYW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFyaWFudD9cImNhcmQtXCIrdGhpcy52YXJpYW50Om51bGx9LGNhcmRJbnZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3ZlcmxheXx8dGhpcy5pbnZlcnNlP1wiY2FyZC1pbnZlcnNlXCI6bnVsbD09PXRoaXMuaW52ZXJzZSYmdGhpcy52YXJpYW50JiZ0aGlzLnZhcmlhbnQubGVuZ3RoPjAmJi0xPT09dGhpcy52YXJpYW50LmluZGV4T2YoXCJvdXRsaW5lXCIpP1wiY2FyZC1pbnZlcnNlXCI6dm9pZCAwfSxjYXJkQWxpZ246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGlnbj9cInRleHQtXCIrdGhpcy5hbGlnbjpudWxsfX0scHJvcHM6e2FsaWduOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGludmVyc2U6e3R5cGU6Qm9vbGVhbixkZWZhdWx0Om51bGx9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sdGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LGhlYWRlcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxoZWFkZXJWYXJpYW50Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGhlYWRlckNsYXNzOnt0eXBlOltTdHJpbmcsQXJyYXldLGRlZmF1bHQ6XCJcIn0saGVhZGVyVGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LGZvb3Rlcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxmb290ZXJWYXJpYW50Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGZvb3RlckNsYXNzOnt0eXBlOltTdHJpbmcsQXJyYXldLGRlZmF1bHQ6XCJcIn0sZm9vdGVyVGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LHRpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHN1YlRpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LG5vQmxvY2s6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxpbWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0saW1nQWx0Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LG92ZXJsYXk6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LGNhcmRHcm91cD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKHQudGFnLHt0YWc6XCJjb21wb25lbnRcIixjbGFzczpbXCJjYXJkLVwiK3QudHlwZV19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7dHlwZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlY2s/XCJkZWNrXCI6dGhpcy5jb2x1bW5zP1wiY29sdW1uc1wiOlwiZ3JvdXBcIn19LHByb3BzOnt0YWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJkaXZcIn0sZGVjazp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGNvbHVtbnM6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LERJUkVDVElPTj17bmV4dDp7Y3VycmVudDpcImNhcm91c2VsLWl0ZW0tbGVmdFwiLG5leHQ6XCJjYXJvdXNlbC1pdGVtLXJpZ2h0XCIsb3ZlcmxheTpcImNhcm91c2VsLWl0ZW0tbmV4dFwifSxwcmV2OntjdXJyZW50OlwiY2Fyb3VzZWwtaXRlbS1yaWdodFwiLG5leHQ6XCJjYXJvdXNlbC1pdGVtLWxlZnRcIixvdmVybGF5OlwiY2Fyb3VzZWwtaXRlbS1wcmV2XCJ9fSxjYXJvdXNlbD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiY2Fyb3VzZWwgc2xpZGVcIixzdHlsZTp7YmFja2dyb3VuZDp0LmJhY2tncm91bmQsaGVpZ2h0OnQuaGVpZ2h0fSxhdHRyczp7cm9sZTpcInJlZ2lvblwiLGlkOnQuaWR8fG51bGwsXCJhcmlhLWJ1c3lcIjp0LmlzU2xpZGluZz9cInRydWVcIjpcImZhbHNlXCJ9LG9uOnttb3VzZWVudGVyOnQucGF1c2UsbW91c2VsZWF2ZTp0LnN0YXJ0LGZvY3VzaW46dC5wYXVzZSxmb2N1c291dDpmdW5jdGlvbihlKXt0LnJlc3RhcnQoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpP1wiYnV0dG9uXCJpbiBlJiYwIT09ZS5idXR0b24/bnVsbDooZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdm9pZCB0LnByZXYoZSkpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJyaWdodFwiLDM5KT9cImJ1dHRvblwiaW4gZSYmMiE9PWUuYnV0dG9uP251bGw6KGUuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5uZXh0KGUpKTpudWxsfV19fSxbbihcImRpdlwiLHtzdGF0aWNDbGFzczpcImNhcm91c2VsLWlubmVyXCIsYXR0cnM6e3JvbGU6XCJsaXN0XCIsaWQ6dC5pZD90LmlkK1wiX19CVl9pbm5lcl9cIjpudWxsfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKSx0LmNvbnRyb2xzP1tuKFwiYVwiLHtzdGF0aWNDbGFzczpcImNhcm91c2VsLWNvbnRyb2wtcHJldlwiLGF0dHJzOntocmVmOlwiI1wiLHJvbGU6XCJidXR0b25cIixcImFyaWEtY29udHJvbHNcIjp0LmlkP3QuaWQrXCJfX0JWX2lubmVyX1wiOm51bGx9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LnByZXYoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQucHJldihlKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5wcmV2KGUpfV19fSxbbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJjYXJvdXNlbC1jb250cm9sLXByZXYtaWNvblwiLGF0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9fSksdC5fdihcIiBcIiksbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJzci1vbmx5XCJ9LFt0Ll92KHQuX3ModC5sYWJlbFByZXYpKV0pXSksbihcImFcIix7c3RhdGljQ2xhc3M6XCJjYXJvdXNlbC1jb250cm9sLW5leHRcIixhdHRyczp7aHJlZjpcIiNcIixyb2xlOlwiYnV0dG9uXCIsXCJhcmlhLWNvbnRyb2xzXCI6dC5pZD90LmlkK1wiX19CVl9pbm5lcl9cIjpudWxsfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5uZXh0KGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0Lm5leHQoZSl9LGZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcInNwYWNlXCIsMzIpKXJldHVybiBudWxsO2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQubmV4dChlKX1dfX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiY2Fyb3VzZWwtY29udHJvbC1uZXh0LWljb25cIixhdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0pLHQuX3YoXCIgXCIpLG4oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwic3Itb25seVwifSxbdC5fdih0Ll9zKHQubGFiZWxOZXh0KSldKV0pXTp0Ll9lKCksbihcIm9sXCIse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTp0LmluZGljYXRvcnMsZXhwcmVzc2lvbjpcImluZGljYXRvcnNcIn1dLHN0YXRpY0NsYXNzOlwiY2Fyb3VzZWwtaW5kaWNhdG9yc1wiLGF0dHJzOntyb2xlOlwiZ3JvdXBcIixpZDp0LmlkP3QuaWQrXCJfX0JWX2luZGljYXRvcnNfXCI6bnVsbCxcImFyaWEtaGlkZGVuXCI6dC5pbmRpY2F0b3JzP1wiZmFsc2VcIjpcInRydWVcIixcImFyaWEtbGFiZWxcIjp0LmluZGljYXRvcnMmJnQubGFiZWxJbmRpY2F0b3JzP3QubGFiZWxJbmRpY2F0b3JzOm51bGwsXCJhcmlhLW93bnNcIjp0LmluZGljYXRvcnMmJnQuaWQ/dC5pZCtcIl9fQlZfaW5uZXJfXCI6bnVsbH19LHQuX2wodC5zbGlkZXMubGVuZ3RoLGZ1bmN0aW9uKGUpe3JldHVybiBuKFwibGlcIix7Y2xhc3M6e2FjdGl2ZTplLTE9PT10LmluZGV4fSxhdHRyczp7cm9sZTpcImJ1dHRvblwiLGlkOnQuaWQ/dC5pZCtcIl9fQlZfaW5kaWNhdG9yX1wiK2UrXCJfXCI6bnVsbCx0YWJpbmRleDp0LmluZGljYXRvcnM/XCIwXCI6XCItMVwiLFwiYXJpYS1jdXJyZW50XCI6ZS0xPT09dC5pbmRleD9cInRydWVcIjpcImZhbHNlXCIsXCJhcmlhLXBvc2luc2V0XCI6ZSxcImFyaWEtc2V0c2l6ZVwiOnQuc2xpZGVzLmxlbmd0aCxcImFyaWEtbGFiZWxcIjp0LmxhYmVsR290b1NsaWRlK1wiIFwiK2UsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6dC5zbGlkZXNbZS0xXS5pZHx8bnVsbCxcImFyaWEtY29udHJvbHNcIjp0LmlkP3QuaWQrXCJfX0JWX2lubmVyX1wiOm51bGx9LG9uOntjbGljazpmdW5jdGlvbihuKXt0LmluZGV4PWUtMX0sa2V5ZG93bjpbZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwiZW50ZXJcIiwxMykpcmV0dXJuIG51bGw7bi5zdG9wUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCksdC5pbmRleD1lLTF9LGZ1bmN0aW9uKG4pe2lmKCEoXCJidXR0b25cImluIG4pJiZ0Ll9rKG4ua2V5Q29kZSxcInNwYWNlXCIsMzIpKXJldHVybiBudWxsO24uc3RvcFByb3BhZ2F0aW9uKCksbi5wcmV2ZW50RGVmYXVsdCgpLHQuaW5kZXg9ZS0xfV19fSl9KSldLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sZGF0YTpmdW5jdGlvbigpe3JldHVybntpbmRleDowLGlzU2xpZGluZzohMSxzbGlkZXM6W119fSxwcm9wczp7aWQ6e3R5cGU6U3RyaW5nfSxsYWJlbFByZXY6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJQcmV2aW91cyBTbGlkZVwifSxsYWJlbE5leHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJOZXh0IFNsaWRlXCJ9LGxhYmVsR290b1NsaWRlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiR290byBTbGlkZVwifSxsYWJlbEluZGljYXRvcnM6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJTZWxlY3QgYSBzbGlkZSB0byBkaXNwbGF5XCJ9LGludGVydmFsOnt0eXBlOk51bWJlcixkZWZhdWx0OjVlM30saW5kaWNhdG9yczp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGNvbnRyb2xzOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0saGVpZ2h0Ont0eXBlOlN0cmluZ30sYmFja2dyb3VuZDp7dHlwZTpTdHJpbmd9fSxtZXRob2RzOntwcmV2OmZ1bmN0aW9uKCl7dGhpcy5pbmRleDw9MD90aGlzLmluZGV4PXRoaXMuc2xpZGVzLmxlbmd0aC0xOnRoaXMuaW5kZXgtLX0sbmV4dDpmdW5jdGlvbigpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlJiZkb2N1bWVudC5oaWRkZW58fCh0aGlzLmluZGV4Pj10aGlzLnNsaWRlcy5sZW5ndGgtMT90aGlzLmluZGV4PTA6dGhpcy5pbmRleCsrKX0scGF1c2U6ZnVuY3Rpb24oKXswIT09dGhpcy5pbnRlcnZhbCYmdm9pZCAwIT09dGhpcy5pbnRlcnZhbCYmKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCksdGhpcy5faW50ZXJ2YWxJZD1udWxsLHRoaXMuc2xpZGVzW3RoaXMuaW5kZXhdLnRhYkluZGV4PTApfSxzdGFydDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7MCE9PXRoaXMuaW50ZXJ2YWwmJnZvaWQgMCE9PXRoaXMuaW50ZXJ2YWwmJih0aGlzLnNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QudGFiSW5kZXg9LTF9KSx0aGlzLl9pbnRlcnZhbElkPXNldEludGVydmFsKGZ1bmN0aW9uKCl7dC5uZXh0KCl9LHRoaXMuaW50ZXJ2YWwpKX0scmVzdGFydDpmdW5jdGlvbih0KXt0LnJlbGF0ZWRUYXJnZXQmJnRoaXMuJGVsLmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCl8fHRoaXMuc3RhcnQoKX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnNsaWRlcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNhcm91c2VsLWl0ZW1cIikpLHRoaXMuc2xpZGVzWzBdLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7dmFyIHQ9dGhpczt0aGlzLnNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7dmFyIGk9bisxO2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsMD09PW4/XCJ0cnVlXCI6XCJmYWxzZVwiKSxlLnNldEF0dHJpYnV0ZShcImFyaWEtcG9zaW5zZXRcIixTdHJpbmcoaSkpLGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZXRzaXplXCIsU3RyaW5nKHQuc2xpZGVzLmxlbmd0aCkpLGUudGFiSW5kZXg9LTEsdC5pZCYmZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xsZWRieVwiLHQuaWQrXCJfX0JWX2luZGljYXRvcl9cIitpK1wiX1wiKX0pLHRoaXMuX2ludGVydmFsSWQ9bnVsbCx0aGlzLnN0YXJ0KCl9LHdhdGNoOntpbmRleDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7aWYodCE9PWUpaWYodGhpcy5pc1NsaWRpbmcpdGhpcy5pbmRleD1lO2Vsc2V7dmFyIGk9dD5lP0RJUkVDVElPTi5uZXh0OkRJUkVDVElPTi5wcmV2OzA9PT1lJiZ0PT09dGhpcy5zbGlkZXMubGVuZ3RoLTE/aT1ESVJFQ1RJT04ucHJldjplPT09dGhpcy5zbGlkZXMubGVuZ3RoLTEmJjA9PT10JiYoaT1ESVJFQ1RJT04ubmV4dCk7dmFyIG89dGhpcy5zbGlkZXNbZV0scj10aGlzLnNsaWRlc1t0XTtvJiZyJiYodGhpcy5pc1NsaWRpbmc9ITAsci5jbGFzc0xpc3QuYWRkKGkubmV4dCxpLm92ZXJsYXkpLG8uY2xhc3NMaXN0LmFkZChpLmN1cnJlbnQpLHRoaXMuX2Nhcm91c2VsQW5pbWF0aW9uPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtuLiRlbWl0KFwic2xpZGVcIix0KSxvLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIiksby5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIixcImZhbHNlXCIpLG8uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIiksby50YWJJbmRleD0tMSxvLmNsYXNzTGlzdC5yZW1vdmUoaS5jdXJyZW50KSxyLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIiksci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIixcInRydWVcIiksci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIiksci50YWJJbmRleD0tMSxyLmNsYXNzTGlzdC5yZW1vdmUoaS5uZXh0LGkub3ZlcmxheSksbi5faW50ZXJ2YWxJZHx8KG8udGFiSW5kZXg9MCxuLiRuZXh0VGljayhmdW5jdGlvbigpe28uZm9jdXMoKX0pKSxuLmlzU2xpZGluZz0hMX0sNTAwKSl9fX0sZGVzdHJveWVkOmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX2Nhcm91c2VsQW5pbWF0aW9uKSxjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpfX0sY2Fyb3VzZWxTbGlkZT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiY2Fyb3VzZWwtaXRlbVwiLHN0eWxlOntiYWNrZ3JvdW5kOnQuYmFja2dyb3VuZCxoZWlnaHQ6dC5oZWlnaHR9LGF0dHJzOntyb2xlOlwibGlzdGl0ZW1cIixpZDp0LmlkfHxudWxsfX0sW3QuaW1nP24oXCJpbWdcIix7c3RhdGljQ2xhc3M6XCJkLWJsb2NrIGltZy1mbHVpZFwiLGF0dHJzOntzcmM6dC5pbWcsYWx0OnQuaW1nQWx0fX0pOnQuX2UoKSxuKFwiZGl2XCIse2NsYXNzOnQuY29udGVudENsYXNzZXN9LFt0LmNhcHRpb24/bihcImgzXCIse2RvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmNhcHRpb24pfX0pOnQuX2UoKSx0LnRleHQ/bihcInBcIix7ZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQudGV4dCl9fSk6dC5fZSgpLHQuX3QoXCJkZWZhdWx0XCIpXSwyKV0pfSxzdGF0aWNSZW5kZXJGbnM6W10scHJvcHM6e2lkOnt0eXBlOlN0cmluZ30saW1nOnt0eXBlOlN0cmluZ30saW1nQWx0Ont0eXBlOlN0cmluZ30sY29udGVudFZpc2libGVVcDp7dHlwZTpTdHJpbmd9LGNhcHRpb246e3R5cGU6U3RyaW5nfSx0ZXh0Ont0eXBlOlN0cmluZ30sYmFja2dyb3VuZDp7dHlwZTpTdHJpbmd9LGhlaWdodDp7dHlwZTpTdHJpbmd9fSxjb21wdXRlZDp7Y29udGVudENsYXNzZXM6ZnVuY3Rpb24oKXt2YXIgdD17XCJjYXJvdXNlbC1jYXB0aW9uXCI6Qm9vbGVhbih0aGlzLmNhcHRpb24pfTtyZXR1cm4gdGhpcy5jb250ZW50VmlzaWJsZVVwJiYodFtcImQtbm9uZVwiXT0hMCx0W1wiZC1cIit0aGlzLmNvbnRlbnRWaXNpYmxlVXArXCItYmxvY2tcIl09ITApLHR9fX0sY29sbGFwc2U9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcInRyYW5zaXRpb25cIix7YXR0cnM6e25hbWU6XCJjb2xsYXBzZVwifSxvbjp7ZW50ZXI6dC5lbnRlcixcImFmdGVyLWVudGVyXCI6dC5jbGVhckhlaWdodCxsZWF2ZTp0LmxlYXZlLFwiYWZ0ZXItbGVhdmVcIjp0LmNsZWFySGVpZ2h0fX0sW24oXCJkaXZcIix7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOnQuc2hvdyxleHByZXNzaW9uOlwic2hvd1wifV0sY2xhc3M6dC5jbGFzc09iamVjdCxhdHRyczp7aWQ6dC5pZHx8bnVsbH19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMildKX0sc3RhdGljUmVuZGVyRm5zOltdLF9zY29wZUlkOlwiZGF0YS12LTY3YjBhMmRlXCIsZGF0YTpmdW5jdGlvbigpe3JldHVybntzaG93OnRoaXMudmlzaWJsZX19LGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybntcIm5hdmJhci1jb2xsYXBzZVwiOnRoaXMuaXNOYXYsc2hvdzp0aGlzLnNob3d9fX0sbW9kZWw6e3Byb3A6XCJ2aXNpYmxlXCIsZXZlbnQ6XCJpbnB1dFwifSx3YXRjaDp7dmlzaWJsZTpmdW5jdGlvbih0KXt0IT09dGhpcy5zaG93JiYodGhpcy5zaG93PXQsdGhpcy5lbWl0U3RhdGUoKSl9fSxwcm9wczp7aXNOYXY6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxpZDp7dHlwZTpTdHJpbmcscmVxdWlyZWQ6ITB9LGFjY29yZGlvbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSx2aXNpYmxlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LG1ldGhvZHM6e3RvZ2dsZTpmdW5jdGlvbigpe3RoaXMuc2hvdz0hdGhpcy5zaG93LHRoaXMuZW1pdFN0YXRlKCl9LGVudGVyOmZ1bmN0aW9uKHQpe3Quc3R5bGUuaGVpZ2h0PVwiYXV0b1wiO3ZhciBlPWdldENvbXB1dGVkU3R5bGUodCkuaGVpZ2h0O3Quc3R5bGUuaGVpZ2h0PVwiMHB4XCIsdC5vZmZzZXRIZWlnaHQsdC5zdHlsZS5oZWlnaHQ9ZX0sbGVhdmU6ZnVuY3Rpb24odCl7dC5zdHlsZS5oZWlnaHQ9XCJhdXRvXCI7dmFyIGU9Z2V0Q29tcHV0ZWRTdHlsZSh0KS5oZWlnaHQ7dC5zdHlsZS5oZWlnaHQ9ZSx0Lm9mZnNldEhlaWdodCx0LnN0eWxlLmhlaWdodD1cIjBweFwifSxjbGVhckhlaWdodDpmdW5jdGlvbih0KXt0LnN0eWxlLmhlaWdodD1udWxsfSxlbWl0U3RhdGU6ZnVuY3Rpb24oKXt0aGlzLiRlbWl0KFwiaW5wdXRcIix0aGlzLnNob3cpLHRoaXMuJHJvb3QuJGVtaXQoXCJjb2xsYXBzZTo6dG9nZ2xlOjpzdGF0ZVwiLHRoaXMuaWQsdGhpcy5zaG93KSx0aGlzLmFjY29yZGlvbiYmdGhpcy5zaG93JiZ0aGlzLiRyb290LiRlbWl0KFwiYWNjb3JkaW9uOjp0b2dnbGVcIix0aGlzLmlkLHRoaXMuYWNjb3JkaW9uKX19LGNyZWF0ZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuJHJvb3QuJG9uKFwiY29sbGFwc2U6OnRvZ2dsZVwiLGZ1bmN0aW9uKGUpe2U9PT10LmlkJiZ0LnRvZ2dsZSgpfSksdGhpcy4kcm9vdC4kb24oXCJhY2NvcmRpb246OnRvZ2dsZVwiLGZ1bmN0aW9uKGUsbil7dC5hY2NvcmRpb24mJm49PT10LmFjY29yZGlvbiYmKGU9PT10LmlkP3Quc2hvd3x8dC50b2dnbGUoKTp0LnNob3cmJnQudG9nZ2xlKCkpfSl9LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLmVtaXRTdGF0ZSgpfX0sZHJvcGRvd24kMT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse2NsYXNzOltcImRyb3Bkb3duXCIsXCJidG4tZ3JvdXBcIix7ZHJvcHVwOnQuZHJvcHVwLHNob3c6dC52aXNpYmxlfV0sYXR0cnM6e2lkOnQuaWR8fG51bGx9fSxbbihcImItYnV0dG9uXCIse3JlZjpcImJ1dHRvblwiLGNsYXNzOntcImRyb3Bkb3duLXRvZ2dsZVwiOiF0LnNwbGl0LFwiYnRuLWxpbmtcIjp0Lmxpbmt9LGF0dHJzOntpZDp0LmlkP3QuaWQrXCJfX0JWX2J1dHRvbl9cIjpudWxsLFwiYXJpYS1oYXNwb3B1cFwiOnQuc3BsaXQ/bnVsbDpcInRydWVcIixcImFyaWEtZXhwYW5kZWRcIjp0LnNwbGl0P251bGw6dC52aXNpYmxlP1widHJ1ZVwiOlwiZmFsc2VcIix2YXJpYW50OnQudmFyaWFudCxzaXplOnQuc2l6ZSxkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5jbGljayhlKX19fSxbdC5fdChcInRleHRcIixbdC5fdih0Ll9zKHQudGV4dCkpXSldLDIpLHQuc3BsaXQ/bihcImItYnV0dG9uXCIse3JlZjpcInRvZ2dsZVwiLGNsYXNzOltcImRyb3Bkb3duLXRvZ2dsZVwiLFwiZHJvcGRvd24tdG9nZ2xlLXNwbGl0XCIse1wiYnRuLWxpbmtcIjp0Lmxpbmt9XSxhdHRyczp7aWQ6dC5pZD90LmlkK1wiX19CVl90b2dnbGVfXCI6bnVsbCxcImFyaWEtaGFzcG9wdXBcIjp0LnNwbGl0P1widHJ1ZVwiOm51bGwsXCJhcmlhLWV4cGFuZGVkXCI6dC5zcGxpdD90LnZpc2libGU/XCJ0cnVlXCI6XCJmYWxzZVwiOm51bGwsdmFyaWFudDp0LnZhcmlhbnQsc2l6ZTp0LnNpemUsZGlzYWJsZWQ6dC5kaXNhYmxlZH0sb246e2NsaWNrOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQudG9nZ2xlKGUpfX19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInNyLW9ubHlcIn0sW3QuX3YodC5fcyh0LnRvZ2dsZVRleHQpKV0pXSk6dC5fZSgpLG4oXCJkaXZcIix7cmVmOlwibWVudVwiLGNsYXNzOltcImRyb3Bkb3duLW1lbnVcIix7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6dC5yaWdodH1dLGF0dHJzOntyb2xlOlwibWVudVwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6dC5pZD90LmlkKyh0LnNwbGl0P1wiX19CVl90b2dnbGVfXCI6XCJfX0JWX2J1dHRvbl9cIik6bnVsbH0sb246e2tleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ0YWJcIiw5KSlyZXR1cm4gbnVsbDt0Lm9uVGFiKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCEwKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX1dLG1vdXNlb3ZlcjpmdW5jdGlvbihlKXt0LmZvY3VzSG92ZXJlZChlKX19fSxbdC5fdChcImRlZmF1bHRcIildLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbY2xpY2tPdXQsZHJvcGRvd25dLGNvbXBvbmVudHM6e2JCdXR0b246YkJ0bn0sZGF0YTpmdW5jdGlvbigpe3JldHVybnt2aXNpYmxlOiExfX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZ30sdG9nZ2xlVGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlRvZ2dsZSBEcm9wZG93blwifSxzaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sbGluazp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxtZXRob2RzOntjbGlja091dExpc3RlbmVyOmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlPSExfSxjbGljazpmdW5jdGlvbih0KXt0aGlzLmRpc2FibGVkP3RoaXMudmlzaWJsZT0hMTp0aGlzLnNwbGl0Pyh0aGlzLiRlbWl0KFwiY2xpY2tcIix0KSx0aGlzLiRyb290LiRlbWl0KFwic2hvd246OmRyb3Bkb3duXCIsdGhpcykpOnRoaXMudG9nZ2xlKCl9fX0sZHJvcGRvd25JdGVtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJiLWxpbmtcIix0Ll9iKHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLWl0ZW1cIixhdHRyczp7cm9sZTpcIm1lbnVpdGVtXCJ9LG9uOntjbGljazpmdW5jdGlvbihlKXt0LiRlbWl0KFwiY2xpY2tcIixlKX19fSxcImItbGlua1wiLHQubGlua1Byb3BzKSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcG9uZW50czp7Ykxpbms6Ykxpbmt9LHByb3BzOnByb3BzLGNvbXB1dGVkOntsaW5rUHJvcHM6Y29tcHV0ZWQubGlua1Byb3BzfX0sZHJvcGRvd25JdGVtQnV0dG9uPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJidXR0b25cIix7c3RhdGljQ2xhc3M6XCJkcm9wZG93bi1pdGVtXCIsYXR0cnM6e3R5cGU6XCJidXR0b25cIixyb2xlOlwibWVudWl0ZW1cIixkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6dC5vbkNsaWNrfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLHByb3BzOntkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxtZXRob2RzOntvbkNsaWNrOmZ1bmN0aW9uKHQpe3RoaXMuJHJvb3QuJGVtaXQoXCJjbGlja2VkOjpsaW5rXCIsdGhpcyksdGhpcy4kZW1pdChcImNsaWNrXCIsdCl9fX0sZHJvcGRvd25EaXZpZGVyPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJkcm9wZG93bi1kaXZpZGVyXCIsYXR0cnM6e3JvbGU6XCJzZXBhcmF0b3JcIn19KX0sc3RhdGljUmVuZGVyRm5zOltdLHByb3BzOnt9fSxkcm9wZG93bkhlYWRlcj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKHQudGFnLHt0YWc6XCJjb21wb25lbnRcIixzdGF0aWNDbGFzczpcImRyb3Bkb3duLWhlYWRlclwiLGF0dHJzOnt0YWJpbmRleDpcIi0xXCJ9fSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10scHJvcHM6e3RhZzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImg2XCJ9fX0sZHJvcGRvd25TZWxlY3Q9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLXNlbGVjdFwiLGNsYXNzOntvcGVuOnQuc2hvdyxkcm9wZG93bjohdC5kcm9wdXAsZHJvcHVwOnQuZHJvcHVwfX0sW24oXCJidXR0b25cIix7Y2xhc3M6W1wiYnRuXCIsXCJkcm9wZG93blwiLHQuZHJvcGRvd25Ub2dnbGUsdC5idG5WYXJpYW50LHQuYnRuU2l6ZV0sYXR0cnM6e2lkOnQuaWQscm9sZTpcImJ1dHRvblwiLFwiYXJpYS1oYXNwb3B1cFwiOlwidHJ1ZVwiLFwiYXJpYS1leHBhbmRlZFwiOlwic2hvd1wiLGRpc2FibGVkOnQuZGlzYWJsZWR9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksdC50b2dnbGUoZSl9fX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiY2hlY2tlZC1pdGVtc1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmRpc3BsYXlJdGVtKX19KV0pLG4oXCJ1bFwiLHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLW1lbnVcIixjbGFzczp7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6XCJyaWdodFwiPT10LnBvc2l0aW9ufSxhdHRyczp7XCJhcmlhLWxhYmVsbGVkYnlcIjpcImRMYWJlbFwifX0sdC5fbCh0Lmxpc3QsZnVuY3Rpb24oZSl7cmV0dXJuIG4oXCJsaVwiLFtuKFwiYnV0dG9uXCIse3N0YXRpY0NsYXNzOlwiZHJvcGRvd24taXRlbVwiLGF0dHJzOntjbGljazp0LnNlbGVjdChlKX19LFt0Ll92KHQuX3MoZS50ZXh0KSldKV0pfSkpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3Nob3c6ITEsc2VsZWN0ZWQ6ITF9fSxjb21wdXRlZDp7YnRuVmFyaWFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhcmlhbnQmJlwiZGVmYXVsdFwiIT09dGhpcy52YXJpYW50P1wiYnRuLVwiK3RoaXMudmFyaWFudDpcImJ0bi1zZWNvbmRhcnlcIn0sYnRuU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemUmJlwiZGVmYXVsdFwiIT09dGhpcy5zaXplP1wiYnRuLVwiK3RoaXMuc2l6ZTpcIlwifSxkcm9wZG93blRvZ2dsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhcmV0P1wiZHJvcGRvd24tdG9nZ2xlXCI6XCJcIn0sZGlzcGxheUl0ZW06ZnVuY3Rpb24oKXtpZih0aGlzLnJldHVybk9iamVjdCYmdGhpcy5tb2RlbCYmIXRoaXMubW9kZWwudGV4dHx8IXRoaXMucmV0dXJuT2JqZWN0JiZ0aGlzLm1vZGVsJiYwPT09dGhpcy5tb2RlbC5sZW5ndGh8fHRoaXMuZm9yY2VEZWZhdWx0KXJldHVybiB0aGlzLmRlZmF1bHRUZXh0O2lmKHRoaXMucmV0dXJuT2JqZWN0JiZ0aGlzLm1vZGVsJiZ0aGlzLm1vZGVsLnRleHQpcmV0dXJuIHRoaXMubW9kZWwudGV4dDtpZighdGhpcy5yZXR1cm5PYmplY3QmJnRoaXMubW9kZWwpe3ZhciB0PXRoaXMubW9kZWx8fFwiXCI7cmV0dXJuIHRoaXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UudmFsdWU9PT10aGlzLm1vZGVsJiYodD1lLnRleHQpfSksdH1yZXR1cm5cIlwifX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZ30sbW9kZWw6e3JlcXVpcmVkOiExfSxsaXN0Ont0eXBlOkFycmF5LGRlZmF1bHQ6W10scmVxdWlyZWQ6ITB9LGNhcmV0Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMH0scG9zaXRpb246e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJsZWZ0XCJ9LHNpemU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJcIn0sdmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImRlZmF1bHRcIn0sZGVmYXVsdFRleHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJQbGFzZSBzZWxlY3Qgb25lXCJ9LGZvcmNlRGVmYXVsdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHJldHVybk9iamVjdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGRyb3B1cDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGRpc2FibGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LG1ldGhvZHM6e3RvZ2dsZTpmdW5jdGlvbih0KXt0aGlzLnNob3c9IXRoaXMuc2hvdyx0aGlzLnNob3c/KHRoaXMuJHJvb3QuJGVtaXQoXCJzaG93bjpkcm9wZG93blwiLHRoaXMuaWQpLHQuc3RvcFByb3BhZ2F0aW9uKCkpOnRoaXMuJHJvb3QuJGVtaXQoXCJoaWRkZW46OmRyb3Bkb3duXCIsdGhpcy5pZCl9LHNlbGVjdDpmdW5jdGlvbih0KXt0aGlzLnJldHVybk9iamVjdD90aGlzLm1vZGVsPXQ6dGhpcy5tb2RlbD10LnZhbHVlLHRoaXMuc2hvdz0hMSx0aGlzLiRyb290LiRlbWl0KFwic2VsZWN0ZWQ6OmRyb3Bkb3duXCIsdGhpcy5pZCx0aGlzLm1vZGVsKX19LGNyZWF0ZWQ6ZnVuY3Rpb24oKXt0aGlzLiRyb290LiRvbihcImhpZGU6OmRyb3Bkb3duXCIsZnVuY3Rpb24oKXt0aGlzLnNob3c9ITF9KX19LGJGb3JtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJmb3JtXCIse2NsYXNzOnQuY2xhc3NPYmplY3R9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5pbmxpbmU/XCJmb3JtLWlubGluZVwiOlwiXCJdfX0scHJvcHM6e2lubGluZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sZm9ybUZpZWxkc2V0PXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIix7Y2xhc3M6W1wiZm9ybS1ncm91cFwiLFwicm93XCIsdC5pbnB1dFN0YXRlXSxhdHRyczp7aWQ6dC5pZHx8bnVsbCxyb2xlOlwiZ3JvdXBcIixcImFyaWEtZGVzY3JpYmVkYnlcIjp0LmRlc2NyaWJlZEJ5fX0sW3QubGFiZWw/bihcImxhYmVsXCIse2NsYXNzOlt0LmxhYmVsU3JPbmx5P1wic3Itb25seVwiOlwiY29sLWZvcm0tbGFiZWxcIix0LmxhYmVsTGF5b3V0LHQubGFiZWxBbGlnbkNsYXNzXSxhdHRyczp7Zm9yOnQudGFyZ2V0LGlkOnQubGFiZWxJZH0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQubGFiZWwpfX0pOnQuX2UoKSxuKFwiZGl2XCIse3JlZjpcImNvbnRlbnRcIixjbGFzczp0LmlucHV0TGF5b3V0fSxbdC5fdChcImRlZmF1bHRcIiksdC5mZWVkYmFjaz9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZm9ybS10ZXh0IGZvcm0tY29udHJvbC1mZWVkYmFja1wiLGF0dHJzOntpZDp0LmZlZWRiYWNrSWQscm9sZTpcImFsZXJ0XCIsXCJhcmlhLWxpdmVcIjpcImFzc2VydGl2ZVwiLFwiYXJpYS1hdG9taWNcIjpcInRydWVcIn0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZmVlZGJhY2spfX0pOnQuX2UoKSx0LmRlc2NyaXB0aW9uP24oXCJzbWFsbFwiLHtzdGF0aWNDbGFzczpcImZvcm0tdGV4dCB0ZXh0LW11dGVkXCIsYXR0cnM6e2lkOnQuZGVzY3JpcHRpb25JZH0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZGVzY3JpcHRpb24pfX0pOnQuX2UoKV0sMildKX0sc3RhdGljUmVuZGVyRm5zOltdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dGFyZ2V0Om51bGx9fSxjb21wdXRlZDp7bGFiZWxJZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkJiZ0aGlzLmxhYmVsP3RoaXMuaWQrXCJfX0JWX2xhYmVsX1wiOm51bGx9LGRlc2NyaXB0aW9uSWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZCYmdGhpcy5kZXNjcmlwdGlvbj90aGlzLmlkK1wiX19CVl9kZXNjcmlwdGlvbl9cIjpudWxsfSxmZWVkYmFja0lkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWQmJnRoaXMuZmVlZGJhY2s/dGhpcy5pZCtcIl9fQlZfZmVlZGJhY2tfXCI6bnVsbH0sZGVzY3JpYmVkQnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZCYmKHRoaXMubGFiZWx8fHRoaXMuZmVlZGJhY2t8fHRoaXMuZGVzY3JpcHRpb24pP1t0aGlzLmxhYmVsSWQsdGhpcy5kZXNjcmlwdGlvbklkLHRoaXMuZmVlZGJhY2tJZF0uZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkuam9pbihcIiBcIik6bnVsbH0saW5wdXRTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlP1wiaGFzLVwiK3RoaXMuc3RhdGU6XCJcIn0sbGFiZWxMYXlvdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbFNyT25seT9udWxsOnRoaXMuaG9yaXpvbnRhbD9cImNvbC1zbS1cIit0aGlzLmxhYmVsU2l6ZTpcImNvbC0xMlwifSxsYWJlbEFsaWduQ2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbFNyT25seT9udWxsOnRoaXMubGFiZWxUZXh0QWxpZ24/XCJ0ZXh0LVwiK3RoaXMubGFiZWxUZXh0QWxpZ246bnVsbH0saW5wdXRMYXlvdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3Jpem9udGFsP1wiY29sLXNtLVwiKygxMi10aGlzLmxhYmVsU2l6ZSk6XCJjb2wtMTJcIn19LG1ldGhvZHM6e3VwZGF0ZVRhcmdldDpmdW5jdGlvbigpe2lmKHRoaXMuZm9yJiZ0aGlzLiRlbCYmdGhpcy4kZWwucXVlcnlTZWxlY3RvcihcIiNcIit0aGlzLmZvcikpcmV0dXJuIHRoaXMuZm9yO3ZhciB0PXRoaXMuJHJlZnMuY29udGVudDtpZighdClyZXR1cm4gbnVsbDt2YXIgZT10LnF1ZXJ5U2VsZWN0b3IodGhpcy5pbnB1dFNlbGVjdG9yKTt0aGlzLnRhcmdldD1lJiZlLmlkP2UuaWQ6bnVsbH19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZVRhcmdldCgpfSx1cGRhdGVkOmZ1bmN0aW9uKCl7dGhpcy51cGRhdGVUYXJnZXQoKX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGZvcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxzdGF0ZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxob3Jpem9udGFsOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbGFiZWxTaXplOnt0eXBlOk51bWJlcixkZWZhdWx0OjN9LGxhYmVsVGV4dEFsaWduOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGxhYmVsU3JPbmx5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGVzY3JpcHRpb246e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sZmVlZGJhY2s6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0saW5wdXRTZWxlY3Rvcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDonW3JvbGU9XCJyYWRpb2dyb3VwXCJdLGlucHV0LHNlbGVjdCx0ZXh0YXJlYSwuZm9ybS1jb250cm9sLC5mb3JtLWNvbnRyb2wtc3RhdGljLC5kcm9wZG93biwuZHJvcHVwJ319fSxmb3JtTWl4aW49e2NvbXB1dGVkOntpbnB1dENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuW3RoaXMuc2l6ZT9cImZvcm0tY29udHJvbC1cIit0aGlzLnNpemU6bnVsbCx0aGlzLnN0YXRlP1wiZm9ybS1jb250cm9sLVwiK3RoaXMuc3RhdGU6bnVsbF19LGN1c3RvbTpmdW5jdGlvbigpe3JldHVybiF0aGlzLnBsYWlufX0scHJvcHM6e25hbWU6e3R5cGU6U3RyaW5nfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFufSxwbGFpbjp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHN0YXRlOnt0eXBlOlN0cmluZ30sc2l6ZTp7dHlwZTpTdHJpbmd9LGlkOnt0eXBlOlN0cmluZ319fSxmb3JtQ2hlY2tCb3hNaXhpbj17Y29tcHV0ZWQ6e2NoZWNrYm94Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm57XCJjdXN0b20tY29udHJvbFwiOnRoaXMuY3VzdG9tLFwiZm9ybS1jaGVjay1pbmxpbmVcIjp0aGlzLmlubGluZX19fX0sZm9ybUNoZWNrYm94PXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJsYWJlbFwiLHtjbGFzczpbdC5pbnB1dENsYXNzLHQuY2hlY2tib3hDbGFzcyx0LmN1c3RvbT9cImN1c3RvbS1jaGVja2JveFwiOm51bGxdfSxbbihcImlucHV0XCIse2NsYXNzOlt0LmN1c3RvbT9cImN1c3RvbS1jb250cm9sLWlucHV0XCI6bnVsbF0sYXR0cnM6e3R5cGU6XCJjaGVja2JveFwiLGlkOnQuaWR8fG51bGwsbmFtZTp0Lm5hbWUsZGlzYWJsZWQ6dC5kaXNhYmxlZH0sZG9tUHJvcHM6e3ZhbHVlOnQudmFsdWUsY2hlY2tlZDp0LmlzQ2hlY2tlZH0sb246e2NoYW5nZTp0LmhhbmRsZUNoYW5nZX19KSx0Ll92KFwiIFwiKSx0LmN1c3RvbT9uKFwic3BhblwiLHtzdGF0aWNDbGFzczpcImN1c3RvbS1jb250cm9sLWluZGljYXRvclwiLGF0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9fSk6dC5fZSgpLHQuX3YoXCIgXCIpLG4oXCJzcGFuXCIse2NsYXNzOlt0LmN1c3RvbT9cImN1c3RvbS1jb250cm9sLWRlc2NyaXB0aW9uXCI6bnVsbF19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMildKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbZm9ybU1peGluLGZvcm1DaGVja0JveE1peGluXSxtb2RlbDp7cHJvcDpcImNoZWNrZWRcIixldmVudDpcImNoYW5nZVwifSxwcm9wczp7dmFsdWU6e2RlZmF1bHQ6ITB9LHVuY2hlY2tlZFZhbHVlOntkZWZhdWx0OiExfSxjaGVja2VkOntkZWZhdWx0OiEwfX0sY29tcHV0ZWQ6e2lzQ2hlY2tlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoZWNrZWQuaW5jbHVkZXModGhpcy52YWx1ZSl9fSxtZXRob2RzOntoYW5kbGVDaGFuZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXQudGFyZ2V0LmNoZWNrZWQ7QXJyYXkuaXNBcnJheSh0aGlzLmNoZWNrZWQpP3RoaXMuaXNDaGVja2VkP3RoaXMuJGVtaXQoXCJjaGFuZ2VcIix0aGlzLmNoZWNrZWQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0IT09ZS52YWx1ZX0pKTp0aGlzLiRlbWl0KFwiY2hhbmdlXCIsdGhpcy5jaGVja2VkLmNvbmNhdChbdGhpcy52YWx1ZV0pKTp0aGlzLiRlbWl0KFwiY2hhbmdlXCIsbj90aGlzLnZhbHVlOnRoaXMudW5jaGVja2VkVmFsdWUpfX19LGZvcm1PcHRpb25zPXtjb21wdXRlZDp7Zm9ybU9wdGlvbnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5vcHRpb25zfHx7fTtyZXR1cm4gZT1BcnJheS5pc0FycmF5KGUpP2UubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlP3t2YWx1ZTplW3QudmFsdWVGaWVsZF0sdGV4dDplW3QudGV4dEZpZWxkXSxkaXNhYmxlZDplLmRpc2FibGVkfHwhMX06e3RleHQ6U3RyaW5nKGUpLHZhbHVlOmV8fHt9fX0pOk9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbihuKXt2YXIgaT1lW25dfHx7fTtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgaSYmKGk9e3RleHQ6U3RyaW5nKGkpfSksaS52YWx1ZT1pW3QudmFsdWVGaWVsZF18fG4saX0pfSxzZWxlY3RlZFZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMsZT10aGlzLmZvcm1PcHRpb25zLG49MDtuPGUubGVuZ3RoO24rKylpZihlW25dLnZhbHVlPT09dC5sb2NhbFZhbHVlKXJldHVybiB0LnJldHVybk9iamVjdD9lW25dOmVbbl0udmFsdWV9fSxwcm9wczp7dmFsdWVGaWVsZDp7dHlwZTpbU3RyaW5nXSxkZWZhdWx0OlwidmFsdWVcIn0sdGV4dEZpZWxkOnt0eXBlOltTdHJpbmddLGRlZmF1bHQ6XCJ0ZXh0XCJ9fSx3YXRjaDp7bG9jYWxWYWx1ZTpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0aGlzLiRlbWl0KFwiaW5wdXRcIix0aGlzLnNlbGVjdGVkVmFsdWUpfSx2YWx1ZTpmdW5jdGlvbih0LGUpe3QhPT1lJiYodGhpcy5sb2NhbFZhbHVlPXQpfX19LGZvcm1SYWRpbz17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse2NsYXNzOlt0LmlucHV0Q2xhc3MsdC5pbnB1dFN0YXRlLHRoaXMuc3RhY2tlZD9cImN1c3RvbS1jb250cm9scy1zdGFja2VkXCI6XCJcIl0sYXR0cnM6e2lkOnQuaWR8fG51bGwscm9sZTpcInJhZGlvZ3JvdXBcIn19LHQuX2wodC5mb3JtT3B0aW9ucyxmdW5jdGlvbihlKXtyZXR1cm4gbihcImxhYmVsXCIse2NsYXNzOlt0LmNoZWNrYm94Q2xhc3MsdC5jdXN0b20/XCJjdXN0b20tcmFkaW9cIjpudWxsXX0sW24oXCJpbnB1dFwiLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTp0LmxvY2FsVmFsdWUsZXhwcmVzc2lvbjpcImxvY2FsVmFsdWVcIn1dLHJlZjpcImlucHV0c1wiLHJlZkluRm9yOiEwLGNsYXNzOnQuY3VzdG9tP1wiY3VzdG9tLWNvbnRyb2wtaW5wdXRcIjpudWxsLGF0dHJzOntpZDplLmlkfHxudWxsLHR5cGU6XCJyYWRpb1wiLG5hbWU6ZS5uYW1lLGRpc2FibGVkOmUuZGlzYWJsZWR9LGRvbVByb3BzOnt2YWx1ZTplLnZhbHVlLGNoZWNrZWQ6dC5fcSh0LmxvY2FsVmFsdWUsZS52YWx1ZSl9LG9uOntjaGFuZ2U6ZnVuY3Rpb24obil7dC4kZW1pdChcImNoYW5nZVwiLHQucmV0dXJuT2JqZWN0P2U6ZS52YWx1ZSl9LF9fYzpmdW5jdGlvbihuKXt0LmxvY2FsVmFsdWU9ZS52YWx1ZX19fSksdC5fdihcIiBcIiksdC5jdXN0b20/bihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJjdXN0b20tY29udHJvbC1pbmRpY2F0b3JcIixhdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0pOnQuX2UoKSx0Ll92KFwiIFwiKSxuKFwic3BhblwiLHtjbGFzczp0LmN1c3RvbT9cImN1c3RvbS1jb250cm9sLWRlc2NyaXB0aW9uXCI6bnVsbCxkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS50ZXh0KX19KV0pfSkpfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltmb3JtTWl4aW4sZm9ybUNoZWNrQm94TWl4aW4sZm9ybU9wdGlvbnNdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57bG9jYWxWYWx1ZTp0aGlzLnZhbHVlfX0sY29tcHV0ZWQ6e2lucHV0U3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZT9cImhhcy1cIit0aGlzLnN0YXRlOlwiXCJ9fSxwcm9wczp7dmFsdWU6e30sb3B0aW9uczp7dHlwZTpbQXJyYXksT2JqZWN0XSxkZWZhdWx0Om51bGwscmVxdWlyZWQ6ITB9LHN0YWNrZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyZXR1cm5PYmplY3Q6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LGJGb3JtSW5wdXRTdGF0aWM9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKShcInBcIix7Y2xhc3M6W1wiZm9ybS1jb250cm9sLXN0YXRpY1wiLHQuaW5wdXRDbGFzc10sYXR0cnM6e2lkOnQuaWR8fG51bGx9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnN0YXRpY1ZhbHVlKX19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxtaXhpbnM6W2Zvcm1NaXhpbl0sY29tcHV0ZWQ6e3N0YXRpY1ZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9ybWF0dGVyP3RoaXMuZm9ybWF0dGVyKHRoaXMudmFsdWUpOnRoaXMudmFsdWV9fSxwcm9wczp7dmFsdWU6e2RlZmF1bHQ6bnVsbH0sZm9ybWF0dGVyOnt0eXBlOkZ1bmN0aW9ufX19LGZvcm1JbnB1dD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiB0LnN0YXRpYz9uKFwiYi1mb3JtLWlucHV0LXN0YXRpY1wiLHthdHRyczp7aWQ6dC5pZHx8bnVsbCx2YWx1ZTp0LnZhbHVlLGZvcm1hdHRlcjp0LmZvcm1hdHRlcn19KTpuKHQudGV4dGFyZWE/XCJ0ZXh0YXJlYVwiOlwiaW5wdXRcIix7cmVmOlwiaW5wdXRcIix0YWc6XCJpbnB1dFwiLGNsYXNzOltcImZvcm0tY29udHJvbFwiLHQuaW5wdXRDbGFzc10sYXR0cnM6e3R5cGU6dC50eXBlLG5hbWU6dC5uYW1lLGlkOnQuaWR8fG51bGwsZGlzYWJsZWQ6dC5kaXNhYmxlZCxyZWFkb25seTp0LnJlYWRvbmx5LHJvd3M6dC5yb3dzfHx0LnJvd3NDb3VudCxwbGFjZWhvbGRlcjp0LnBsYWNlaG9sZGVyfSxkb21Qcm9wczp7dmFsdWU6dC52YWx1ZX0sb246e2lucHV0OmZ1bmN0aW9uKGUpe3Qub25JbnB1dChlLnRhcmdldC52YWx1ZSl9LGNoYW5nZTpmdW5jdGlvbihlKXt0Lm9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKX0sa2V5dXA6ZnVuY3Rpb24oZSl7dC5vbktleVVwKGUpfSxmb2N1czpmdW5jdGlvbihlKXt0LiRlbWl0KFwiZm9jdXNcIil9LGJsdXI6ZnVuY3Rpb24oZSl7dC4kZW1pdChcImJsdXJcIil9fX0pfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltmb3JtTWl4aW5dLGNvbXBvbmVudHM6e2JGb3JtSW5wdXRTdGF0aWM6YkZvcm1JbnB1dFN0YXRpY30sY29tcHV0ZWQ6e3Jvd3NDb3VudDpmdW5jdGlvbigpe3JldHVybih0aGlzLnZhbHVlfHxcIlwiKS50b1N0cmluZygpLnNwbGl0KFwiXFxuXCIpLmxlbmd0aH19LG1ldGhvZHM6e2Zvcm1hdDpmdW5jdGlvbih0KXtpZih0aGlzLmZvcm1hdHRlcil7dmFyIGU9dGhpcy5mb3JtYXR0ZXIodCk7ZSE9PXQmJih0PWUsdGhpcy4kcmVmcy5pbnB1dC52YWx1ZT1lKX1yZXR1cm4gdH0sb25JbnB1dDpmdW5jdGlvbih0KXt0aGlzLmxhenlGb3JtYXR0ZXJ8fCh0PXRoaXMuZm9ybWF0KHQpKSx0aGlzLiRlbWl0KFwiaW5wdXRcIix0KX0sb25DaGFuZ2U6ZnVuY3Rpb24odCl7dD10aGlzLmZvcm1hdCh0KSx0aGlzLiRlbWl0KFwiaW5wdXRcIix0KSx0aGlzLiRlbWl0KFwiY2hhbmdlXCIsdCl9LG9uS2V5VXA6ZnVuY3Rpb24odCl7dGhpcy4kZW1pdChcImtleXVwXCIsdCl9LGZvY3VzOmZ1bmN0aW9uKCl7dGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpfX0scHJvcHM6e3ZhbHVlOntkZWZhdWx0Om51bGx9LHR5cGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJ0ZXh0XCJ9LHJlYWRvbmx5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sc3RhdGljOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0scGxhY2Vob2xkZXI6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0scm93czp7dHlwZTpOdW1iZXIsZGVmYXVsdDpudWxsfSx0ZXh0YXJlYTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGZvcm1hdHRlcjp7dHlwZTpGdW5jdGlvbn0sbGF6eUZvcm1hdHRlcjp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sZm9ybUZpbGU9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtjbGFzczpbXCJmb3JtLWNvbnRyb2xcIix0LmN1c3RvbT9cImN1c3RvbS1maWxlXCI6bnVsbCx0LmlucHV0Q2xhc3NdLGF0dHJzOntpZDp0LmlkP3QuaWQrXCJfX0JWX2ZpbGVfb3V0ZXJfXCI6bnVsbH0sb246e2RyYWdvdmVyOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQuZHJhZ292ZXIoZSl9fX0sW3QuZHJhZ2dpbmcmJnQuY3VzdG9tP24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiZHJvcC1oZXJlXCIsYXR0cnM6e1wiZGF0YS1kcm9wXCI6dC5kcm9wTGFiZWx9LG9uOntkcmFnb3ZlcjpmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LmRyYWdvdmVyKGUpfSxkcm9wOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQuZHJvcChlKX0sZHJhZ2xlYXZlOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQuZHJhZ2dpbmc9ITF9fX0pOnQuX2UoKSxuKFwiaW5wdXRcIix7cmVmOlwiaW5wdXRcIixjbGFzczp0LmN1c3RvbT9cImN1c3RvbS1maWxlLWlucHV0XCI6XCJcIixhdHRyczp7dHlwZTpcImZpbGVcIixuYW1lOnQubmFtZSxpZDp0LmlkfHxudWxsLGRpc2FibGVkOnQuZGlzYWJsZWQsYWNjZXB0OnQuYWNjZXB0fHxudWxsLG11bHRpcGxlOnQubXVsdGlwbGUsd2Via2l0ZGlyZWN0b3J5OnQuZGlyZWN0b3J5LFwiYXJpYS1kZXNjcmliZWRieVwiOnQuY3VzdG9tJiZ0LmlkP3QuaWQrXCJfX0JWX2ZpbGVfY29udHJvbF9cIjpudWxsfSxvbjp7Y2hhbmdlOnQub25GaWxlQ2hhbmdlfX0pLHQuX3YoXCIgXCIpLHQuY3VzdG9tP24oXCJzcGFuXCIse2NsYXNzOltcImN1c3RvbS1maWxlLWNvbnRyb2xcIix0LmRyYWdnaW5nP1wiZHJhZ2dpbmdcIjpudWxsLHQuaW5wdXRDbGFzc10sYXR0cnM6e2lkOnQuaWQ/dC5pZCtcIl9fQlZfZmlsZV9jb250cm9sX1wiOm51bGwsXCJkYXRhLWNob29zZVwiOnQuY29tcHV0ZWRDaG9vc2VMYWJlbCxcImRhdGEtc2VsZWN0ZWRcIjp0LnNlbGVjdGVkTGFiZWx9fSk6dC5fZSgpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxfc2NvcGVJZDpcImRhdGEtdi1jNjhiZDVmOFwiLG1peGluczpbZm9ybU1peGluXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3NlbGVjdGVkRmlsZTpudWxsLGRyYWdnaW5nOiExfX0sY29tcHV0ZWQ6e3NlbGVjdGVkTGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3RlZEZpbGUmJjAhPT10aGlzLnNlbGVjdGVkRmlsZS5sZW5ndGg/dGhpcy5tdWx0aXBsZT8xPT09dGhpcy5zZWxlY3RlZEZpbGUubGVuZ3RoP3RoaXMuc2VsZWN0ZWRGaWxlWzBdLm5hbWU6dGhpcy5zZWxlY3RlZEZvcm1hdC5yZXBsYWNlKFwiOm5hbWVzXCIsdGhpcy5zZWxlY3RlZEZpbGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KS5qb2luKFwiLFwiKSkucmVwbGFjZShcIjpjb3VudFwiLHRoaXMuc2VsZWN0ZWRGaWxlLmxlbmd0aCk6dGhpcy5zZWxlY3RlZEZpbGUubmFtZTp0aGlzLnBsYWNlaG9sZGVyfHxcIk5vIGZpbGUgY2hvc2VuXCJ9LGNvbXB1dGVkQ2hvb3NlTGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaG9vc2VMYWJlbHx8KHRoaXMubXVsdGlwbGU/XCJDaG9vc2UgRmlsZXNcIjpcIkNob29zZSBGaWxlXCIpfX0sd2F0Y2g6e3NlbGVjdGVkRmlsZTpmdW5jdGlvbih0LGUpe3QhPT1lJiYoIXQmJnRoaXMubXVsdGlwbGU/dGhpcy4kZW1pdChcImlucHV0XCIsW10pOnRoaXMuJGVtaXQoXCJpbnB1dFwiLHQpKX19LG1ldGhvZHM6e3Jlc2V0OmZ1bmN0aW9uKCl7dHJ5e3RoaXMuJHJlZnMuaW5wdXQudmFsdWU9XCJcIn1jYXRjaCh0KXt9dGhpcy4kcmVmcy5pbnB1dC50eXBlPVwiXCIsdGhpcy4kcmVmcy5pbnB1dC50eXBlPVwiZmlsZVwiLHRoaXMuc2VsZWN0ZWRGaWxlPXRoaXMubXVsdGlwbGU/W106bnVsbH0sb25GaWxlQ2hhbmdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy4kZW1pdChcImNoYW5nZVwiLHQpO3ZhciBuPXQuZGF0YVRyYW5zZmVyJiZ0LmRhdGFUcmFuc2Zlci5pdGVtcztpZighbnx8dGhpcy5ub1RyYXZlcnNlKXRoaXMuc2V0RmlsZXModC50YXJnZXQuZmlsZXN8fHQuZGF0YVRyYW5zZmVyLmZpbGVzKTtlbHNle2Zvcih2YXIgaT1bXSxvPTA7bzxuLmxlbmd0aDtvKyspe3ZhciByPW5bb10ud2Via2l0R2V0QXNFbnRyeSgpO3ImJmkucHVzaChlLnRyYXZlcnNlRmlsZVRyZWUocikpfVByb21pc2UuYWxsKGkpLnRoZW4oZnVuY3Rpb24odCl7ZS5zZXRGaWxlcyhBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLHQpKX0pfX0sc2V0RmlsZXM6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0KWlmKHRoaXMubXVsdGlwbGUpe2Zvcih2YXIgbj1bXSxpPTA7aTx0Lmxlbmd0aDtpKyspdFtpXS50eXBlLm1hdGNoKGUuYWNjZXB0KSYmbi5wdXNoKHRbaV0pO3RoaXMuc2VsZWN0ZWRGaWxlPW59ZWxzZSB0aGlzLnNlbGVjdGVkRmlsZT10WzBdO2Vsc2UgdGhpcy5zZWxlY3RlZEZpbGU9bnVsbH0sZHJhZ292ZXI6ZnVuY3Rpb24odCl7IXRoaXMubm9Ecm9wJiZ0aGlzLmN1c3RvbSYmKHRoaXMuZHJhZ2dpbmc9ITAsdC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdD1cImNvcHlcIil9LGRyb3A6ZnVuY3Rpb24odCl7dGhpcy5ub0Ryb3B8fCh0aGlzLmRyYWdnaW5nPSExLHQuZGF0YVRyYW5zZmVyLmZpbGVzJiZ0LmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGg+MCYmdGhpcy5vbkZpbGVDaGFuZ2UodCkpfSx0cmF2ZXJzZUZpbGVUcmVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaSl7ZT1lfHxcIlwiLHQuaXNGaWxlP3QuZmlsZShmdW5jdGlvbih0KXt0LiRwYXRoPWUsaSh0KX0pOnQuaXNEaXJlY3RvcnkmJnQuY3JlYXRlUmVhZGVyKCkucmVhZEVudHJpZXMoZnVuY3Rpb24obyl7Zm9yKHZhciByPVtdLHM9MDtzPG8ubGVuZ3RoO3MrKylyLnB1c2gobi50cmF2ZXJzZUZpbGVUcmVlKG9bc10sZSt0Lm5hbWUrXCIvXCIpKTtQcm9taXNlLmFsbChyKS50aGVuKGZ1bmN0aW9uKHQpe2koQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSx0KSl9KX0pfSl9fSxwcm9wczp7YWNjZXB0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHBsYWNlaG9sZGVyOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGNob29zZUxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LG11bHRpcGxlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGlyZWN0b3J5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbm9UcmF2ZXJzZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHNlbGVjdGVkRm9ybWF0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiOmNvdW50IEZpbGVzXCJ9LG5vRHJvcDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGRyb3BMYWJlbDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkRyb3AgZmlsZXMgaGVyZVwifX19LGZvcm1TZWxlY3Q9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcInNlbGVjdFwiLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTp0LmxvY2FsVmFsdWUsZXhwcmVzc2lvbjpcImxvY2FsVmFsdWVcIn1dLHJlZjpcImlucHV0XCIsY2xhc3M6W1wiZm9ybS1jb250cm9sXCIsdC5pbnB1dENsYXNzLHQuY3VzdG9tP1wiY3VzdG9tLXNlbGVjdFwiOm51bGxdLGF0dHJzOntuYW1lOnQubmFtZSxpZDp0LmlkfHxudWxsLGRpc2FibGVkOnQuZGlzYWJsZWR9LG9uOntjaGFuZ2U6ZnVuY3Rpb24oZSl7dmFyIG49QXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGUudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24odCl7cmV0dXJuIHQuc2VsZWN0ZWR9KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJfdmFsdWVcImluIHQ/dC5fdmFsdWU6dC52YWx1ZX0pO3QubG9jYWxWYWx1ZT1lLnRhcmdldC5tdWx0aXBsZT9uOm5bMF19fX0sdC5fbCh0LmZvcm1PcHRpb25zLGZ1bmN0aW9uKGUpe3JldHVybiBuKFwib3B0aW9uXCIse2F0dHJzOntkaXNhYmxlZDplLmRpc2FibGVkfSxkb21Qcm9wczp7dmFsdWU6ZS52YWx1ZSxpbm5lckhUTUw6dC5fcyhlLnRleHQpfX0pfSkpfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltmb3JtTWl4aW4sZm9ybU9wdGlvbnNdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57bG9jYWxWYWx1ZTp0aGlzLnZhbHVlfX0scHJvcHM6e3ZhbHVlOnt9LG9wdGlvbnM6e3R5cGU6W0FycmF5LE9iamVjdF0scmVxdWlyZWQ6ITB9LHJldHVybk9iamVjdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sanVtYm90cm9uPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIix7Y2xhc3M6W1wianVtYm90cm9uXCIsdC5mbHVpZD9cImp1bWJvdHJvbi1mbHVpZFwiOm51bGxdfSxbbihcImRpdlwiLHtjbGFzczp0LmNvbnRhaW5lckZsdWlkP1wiY29udGFpbmVyLWZsdWlkXCI6XCJjb250YWluZXJcIn0sW3QuaGVhZGVyP24oXCJoMVwiLHtzdGF0aWNDbGFzczpcImRpc3BsYXktM1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmhlYWRlcil9fSk6dC5fZSgpLHQubGVhZD9uKFwicFwiLHtzdGF0aWNDbGFzczpcImxlYWRcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5sZWFkKX19KTp0Ll9lKCksdC5fdChcImRlZmF1bHRcIildLDIpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7fSxwcm9wczp7Zmx1aWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxjb250YWluZXJGbHVpZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhlYWRlcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxsZWFkOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9fX0sYmFkZ2U9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKShcInNwYW5cIix7Y2xhc3M6W1wiYmFkZ2VcIix0LmJhZGdlVmFyaWFudCx0LmJhZGdlUGlsbF19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7YmFkZ2VWYXJpYW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFyaWFudCYmXCJkZWZhdWx0XCIhPT10aGlzLnZhcmlhbnQ/XCJiYWRnZS1cIit0aGlzLnZhcmlhbnQ6XCJiYWRnZS1kZWZhdWx0XCJ9LGJhZGdlUGlsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBpbGw/XCJiYWRnZS1waWxsXCI6XCJcIn19LHByb3BzOnt2YXJpYW50Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGVmYXVsdFwifSxwaWxsOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19fSxsaXN0R3JvdXA9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKSh0LnRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wibGlzdC1ncm91cFwiLHQuZmx1c2g/XCJsaXN0LWdyb3VwLWZsdXNoXCI6bnVsbF19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxwcm9wczp7dGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LGZsdXNoOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19fSxsaW5rUHJvcHMkMT1PYmplY3QuYXNzaWduKG9taXRMaW5rUHJvcHMoXCJocmVmXCIsXCJ0b1wiKSx7aHJlZjp7dHlwZTpwcm9wcy5ocmVmLnR5cGV9LHRvOnt0eXBlOnByb3BzLnRvLnR5cGV9LHRhZzp7dHlwZTpwcm9wcy50YWcudHlwZX19KSxhY3Rpb25UYWdzPVtcImFcIixcInJvdXRlci1saW5rXCIsXCJidXR0b25cIixcImItbGlua1wiXSxsaXN0R3JvdXBJdGVtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkodC5teVRhZyx0Ll9iKHtyZWY6XCJpdGVtXCIsdGFnOlwiY29tcG9uZW50XCIsY2xhc3M6dC5jbGFzc09iamVjdH0sXCJjb21wb25lbnRcIix0LmNvbmRpdGlvbmFsTGlua1Byb3BzKSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcG9uZW50czp7Ykxpbms6Ykxpbmt9LGNvbXB1dGVkOntsaW5rUHJvcHM6Y29tcHV0ZWQubGlua1Byb3BzLGNsYXNzT2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuW1wibGlzdC1ncm91cC1pdGVtXCIsdGhpcy5saXN0U3RhdGUsdGhpcy5hY3RpdmU/XCJhY3RpdmVcIjpudWxsLHRoaXMuZGlzYWJsZWQ/XCJkaXNhYmxlZFwiOm51bGwsdGhpcy5pc0FjdGlvbj9cImxpc3QtZ3JvdXAtaXRlbS1hY3Rpb25cIjpudWxsXX0saXNBY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4hMSE9PXRoaXMuYWN0aW9uJiYhISh0aGlzLmFjdGlvbnx8dGhpcy50b3x8dGhpcy5ocmVmfHxhY3Rpb25UYWdzLmluY2x1ZGVzKHRoaXMudGFnKSl9LGxpc3RTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhcmlhbnQ/XCJsaXN0LWdyb3VwLWl0ZW0tXCIrdGhpcy52YXJpYW50Om51bGx9LG15VGFnOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGFnP3RoaXMudGFnOnRoaXMudG98fHRoaXMuaHJlZj9cImItbGlua1wiOlwiZGl2XCJ9LGNvbmRpdGlvbmFsTGlua1Byb3BzOmZ1bmN0aW9uKCl7cmV0dXJuXCJiLWxpbmtcIiE9PXRoaXMubXlUYWc/e306dGhpcy5saW5rUHJvcHN9fSxwcm9wczpPYmplY3QuYXNzaWduKGxpbmtQcm9wcyQxLHthY3Rpb246e3R5cGU6Qm9vbGVhbixkZWZhdWx0Om51bGx9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH19KX0sbWVkaWE9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtzdGF0aWNDbGFzczpcIm1lZGlhXCJ9LFt0LnJpZ2h0QWxpZ24/dC5fZSgpOm4oXCJkaXZcIix7Y2xhc3M6W1wiZC1mbGV4XCIsXCJtci0zXCIsdC52ZXJ0aWNhbEFsaWduQ2xhc3NdfSxbdC5fdChcImFzaWRlXCIpXSwyKSxuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwibWVkaWEtYm9keVwifSxbdC5fdChcImRlZmF1bHRcIildLDIpLHQucmlnaHRBbGlnbj9uKFwiZGl2XCIse2NsYXNzOltcImQtZmxleFwiLFwibWwtM1wiLHQudmVydGljYWxBbGlnbkNsYXNzXX0sW3QuX3QoXCJhc2lkZVwiKV0sMik6dC5fZSgpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7dmVydGljYWxBbGlnbkNsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuXCJhbGlnbi1zZWxmLVwiK3RoaXMudmVydGljYWxBbGlnbn19LHByb3BzOntyaWdodEFsaWduOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdmVydGljYWxBbGlnbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInRvcFwifX19LEZPQ1VTX1NFTEVDVE9SPVtcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIixcImlucHV0Om5vdChbZGlzYWJsZWRdKVwiLFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCIsXCJhOm5vdChbZGlzYWJsZWRdKTpub3QoLmRpc2FibGVkKVwiLFwiW3RhYmluZGV4XTpub3QoW2Rpc2FibGVkXSk6bm90KC5kaXNhYmxlZClcIl0uam9pbihcIixcIiksbW9kYWw9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLFtuKFwidHJhbnNpdGlvbi1ncm91cFwiLHthdHRyczp7XCJlbnRlci1jbGFzc1wiOlwiaGlkZGVuXCIsXCJlbnRlci10by1jbGFzc1wiOlwiXCIsXCJlbnRlci1hY3RpdmUtY2xhc3NcIjpcIlwiLFwibGVhdmUtY2xhc3NcIjpcInNob3dcIixcImxlYXZlLWFjdGl2ZS1jbGFzc1wiOlwiXCIsXCJsZWF2ZS10by1jbGFzc1wiOlwiaGlkZGVuXCJ9LG9uOntcImFmdGVyLWVudGVyXCI6dC5mb2N1c0ZpcnN0fX0sW24oXCJkaXZcIix7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOnQuaXNfdmlzaWJsZSxleHByZXNzaW9uOlwiaXNfdmlzaWJsZVwifV0sa2V5OlwibW9kYWxcIixyZWY6XCJtb2RhbFwiLGNsYXNzOltcIm1vZGFsXCIse2ZhZGU6IXQubm9GYWRlLHNob3c6dC5pc192aXNpYmxlfV0sYXR0cnM6e2lkOnQuaWR8fG51bGwscm9sZTpcImRpYWxvZ1wifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7dC5vbkNsaWNrT3V0KCl9LGtleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKCl9fX0sW24oXCJkaXZcIix7Y2xhc3M6W1wibW9kYWwtZGlhbG9nXCIsXCJtb2RhbC1cIit0LnNpemVdfSxbbihcImRpdlwiLHtyZWY6XCJjb250ZW50XCIsc3RhdGljQ2xhc3M6XCJtb2RhbC1jb250ZW50XCIsYXR0cnM6e3RhYmluZGV4OlwiLTFcIixyb2xlOlwiZG9jdW1lbnRcIixcImFyaWEtbGFiZWxsZWRieVwiOnQuaGlkZUhlYWRlcnx8IXQuaWQ/bnVsbDp0LmlkK1wiX19CVl90aXRsZV9cIixcImFyaWEtZGVzY3JpYmVkYnlcIjp0LmlkP3QuaWQrXCJfX0JWX2JvZHlfXCI6bnVsbH0sb246e2NsaWNrOmZ1bmN0aW9uKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCl9fX0sW3QuaGlkZUhlYWRlcj90Ll9lKCk6bihcImhlYWRlclwiLHtyZWY6XCJoZWFkZXJcIixzdGF0aWNDbGFzczpcIm1vZGFsLWhlYWRlclwifSxbdC5fdChcIm1vZGFsLWhlYWRlclwiLFtuKFwiaDVcIix7c3RhdGljQ2xhc3M6XCJtb2RhbC10aXRsZVwiLGF0dHJzOntpZDp0LmlkP3QuaWQrXCJfX0JWX3RpdGxlX1wiOm51bGx9fSxbdC5fdChcIm1vZGFsLXRpdGxlXCIsW3QuX3YodC5fcyh0LnRpdGxlKSldKV0sMiksdC5oaWRlSGVhZGVyQ2xvc2U/dC5fZSgpOm4oXCJidXR0b25cIix7c3RhdGljQ2xhc3M6XCJjbG9zZVwiLGF0dHJzOnt0eXBlOlwiYnV0dG9uXCIsXCJhcmlhLWxhYmVsXCI6dC5oZWFkZXJDbG9zZUxhYmVsfSxvbjp7Y2xpY2s6dC5oaWRlfX0sW24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9fSxbdC5fdihcIsOXXCIpXSldKV0pXSwyKSxuKFwiZGl2XCIse3JlZjpcImJvZHlcIixzdGF0aWNDbGFzczpcIm1vZGFsLWJvZHlcIixhdHRyczp7aWQ6dC5pZD90LmlkK1wiX19CVl9ib2R5X1wiOm51bGx9fSxbdC5fdChcImRlZmF1bHRcIildLDIpLHQuaGlkZUZvb3Rlcj90Ll9lKCk6bihcImZvb3RlclwiLHtyZWY6XCJmb290ZXJcIixzdGF0aWNDbGFzczpcIm1vZGFsLWZvb3RlclwifSxbdC5fdChcIm1vZGFsLWZvb3RlclwiLFt0Lm9rT25seT90Ll9lKCk6bihcImItYnRuXCIse2F0dHJzOnt2YXJpYW50Olwic2Vjb25kYXJ5XCIsc2l6ZTp0LmJ1dHRvblNpemV9LG9uOntjbGljazpmdW5jdGlvbihlKXt0LmhpZGUoITEpfX19LFt0Ll90KFwibW9kYWwtY2FuY2VsXCIsW3QuX3YodC5fcyh0LmNsb3NlVGl0bGUpKV0pXSwyKSxuKFwiYi1idG5cIix7YXR0cnM6e3ZhcmlhbnQ6XCJwcmltYXJ5XCIsc2l6ZTp0LmJ1dHRvblNpemUsZGlzYWJsZWQ6dC5va0Rpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7dC5oaWRlKCEwKX19fSxbdC5fdChcIm1vZGFsLW9rXCIsW3QuX3YodC5fcyh0Lm9rVGl0bGUpKV0pXSwyKV0pXSwyKV0pXSldKSx0LmlzX3Zpc2libGU/bihcImRpdlwiLHtrZXk6XCJtb2RhbC1iYWNrZHJvcFwiLGNsYXNzOltcIm1vZGFsLWJhY2tkcm9wXCIse2ZhZGU6IXQubm9GYWRlLHNob3c6dC5pc192aXNpYmxlfV19KTp0Ll9lKCldKV0sMSl9LHN0YXRpY1JlbmRlckZuczpbXSxfc2NvcGVJZDpcImRhdGEtdi0xYjRjYmI2OFwiLGNvbXBvbmVudHM6e2JCdG46YkJ0bn0sZGF0YTpmdW5jdGlvbigpe3JldHVybntpc192aXNpYmxlOiExLHJldHVybl9mb2N1czp0aGlzLnJldHVybkZvY3VzfHxudWxsfX0sbW9kZWw6e3Byb3A6XCJ2aXNpYmxlXCIsZXZlbnQ6XCJjaGFuZ2VcIn0sY29tcHV0ZWQ6e2JvZHk6ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQpcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJib2R5XCIpfX0sd2F0Y2g6e3Zpc2libGU6ZnVuY3Rpb24odCxlKXt0IT09ZSYmKHQ/dGhpcy5zaG93KCk6dGhpcy5oaWRlKCkpfX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHRpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHNpemU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJtZFwifSxidXR0b25TaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwibWRcIn0sbm9GYWRlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbm9DbG9zZU9uQmFja2Ryb3A6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxub0Nsb3NlT25Fc2M6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxub0F1dG9Gb2N1czp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhpZGVIZWFkZXI6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxoaWRlRm9vdGVyOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sb2tPbmx5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sb2tEaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhpZGVIZWFkZXJDbG9zZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHZpc2libGU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyZXR1cm5Gb2N1czp7ZGVmYXVsdDpudWxsfSxoZWFkZXJDbG9zZUxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiQ2xvc2VcIn0sY2xvc2VUaXRsZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkNsb3NlXCJ9LG9rVGl0bGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJPS1wifX0sbWV0aG9kczp7c2hvdzpmdW5jdGlvbigpe3RoaXMuaXNfdmlzaWJsZXx8KHRoaXMuJGVtaXQoXCJzaG93XCIpLHRoaXMuaXNfdmlzaWJsZT0hMCx0aGlzLiRyb290LiRlbWl0KFwic2hvd246Om1vZGFsXCIsdGhpcy5pZCksdGhpcy5ib2R5LmNsYXNzTGlzdC5hZGQoXCJtb2RhbC1vcGVuXCIpLHRoaXMuJGVtaXQoXCJzaG93blwiKSx0aGlzLiRlbWl0KFwiY2hhbmdlXCIsITApLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsdGhpcy5lbmZvcmNlRm9jdXMsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsdGhpcy5lbmZvcmNlRm9jdXMsITEpKSl9LGhpZGU6ZnVuY3Rpb24odCl7aWYodGhpcy5pc192aXNpYmxlKXt2YXIgZT0hMSxuPXtpc09LOnQsY2FuY2VsOmZ1bmN0aW9uKCl7ZT0hMH19O3RoaXMuJGVtaXQoXCJjaGFuZ2VcIiwhMSksdGhpcy4kZW1pdChcImhpZGVcIixuKSwhMD09PXQ/dGhpcy4kZW1pdChcIm9rXCIsbik6ITE9PT10JiZ0aGlzLiRlbWl0KFwiY2FuY2VsXCIsbiksZXx8KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsdGhpcy5lbmZvcmNlRm9jdXMsITEpLHRoaXMucmV0dXJuRm9jdXNUbygpKSx0aGlzLmlzX3Zpc2libGU9ITEsdGhpcy4kcm9vdC4kZW1pdChcImhpZGRlbjo6bW9kYWxcIix0aGlzLmlkKSx0aGlzLiRlbWl0KFwiaGlkZGVuXCIsbiksdGhpcy5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2RhbC1vcGVuXCIpKX19LG9uQ2xpY2tPdXQ6ZnVuY3Rpb24oKXt0aGlzLmlzX3Zpc2libGUmJiF0aGlzLm5vQ2xvc2VPbkJhY2tkcm9wJiZ0aGlzLmhpZGUoKX0sb25Fc2M6ZnVuY3Rpb24oKXt0aGlzLmlzX3Zpc2libGUmJiF0aGlzLm5vQ2xvc2VPbkVzYyYmdGhpcy5oaWRlKCl9LGZvY3VzRmlyc3Q6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKXtpZighZG9jdW1lbnQuYWN0aXZlRWxlbWVudHx8IXQuJHJlZnMuY29udGVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSl7dmFyIGU7dC5ub0F1dG9Gb2N1c3x8KHQuJHJlZnMuYm9keSYmKGU9ZmluZEZpcnN0VmlzaWJsZSh0LiRyZWZzLmJvZHksRk9DVVNfU0VMRUNUT1IpKSwhZSYmdC4kcmVmcy5mb290ZXImJihlPWZpbmRGaXJzdFZpc2libGUodC4kcmVmcy5mb290ZXIsRk9DVVNfU0VMRUNUT1IpKSwhZSYmdC4kcmVmcy5oZWFkZXImJihlPWZpbmRGaXJzdFZpc2libGUodC4kcmVmcy5oZWFkZXIsRk9DVVNfU0VMRUNUT1IpKSksZXx8KGU9dC4kcmVmcy5jb250ZW50KSxlJiZlLmZvY3VzJiZlLmZvY3VzKCl9fSl9LHJldHVybkZvY3VzVG86ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJldHVybkZvY3VzfHx0aGlzLnJldHVybl9mb2N1c3x8bnVsbDt0JiYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkpLHQmJnQuJGVsJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LiRlbC5mb2N1cz90LiRlbC5mb2N1cygpOnQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZm9jdXMmJnQuZm9jdXMoKSl9LGVuZm9yY2VGb2N1czpmdW5jdGlvbih0KXt0aGlzLmlzX3Zpc2libGUmJmRvY3VtZW50IT09dC50YXJnZXQmJnRoaXMuJHJlZnMuY29udGVudCYmdGhpcy4kcmVmcy5jb250ZW50IT09dC50YXJnZXQmJiF0aGlzLiRyZWZzLmNvbnRlbnQuY29udGFpbnModC50YXJnZXQpJiZ0aGlzLiRyZWZzLmNvbnRlbnQuZm9jdXMoKX19LGNyZWF0ZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuJHJvb3QuJG9uKFwic2hvdzo6bW9kYWxcIixmdW5jdGlvbihlLG4pe2U9PT10LmlkJiYodC5yZXR1cm5fZm9jdXM9bnx8bnVsbCx0LnNob3coKSl9KSx0aGlzLiRyb290LiRvbihcImhpZGU6Om1vZGFsXCIsZnVuY3Rpb24oZSl7ZT09PXQuaWQmJnQuaGlkZSgpfSl9LG1vdW50ZWQ6ZnVuY3Rpb24oKXshMD09PXRoaXMudmlzaWJsZSYmdGhpcy5zaG93KCl9LGRlc3Ryb3llZDpmdW5jdGlvbigpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIix0aGlzLmVuZm9yY2VGb2N1cywhMSl9fSxuYXY9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKSh0LnR5cGUse3RhZzpcImNvbXBvbmVudFwiLGNsYXNzOnQuY2xhc3NPYmplY3R9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm57bmF2OiEwLFwibmF2YmFyLW5hdlwiOnRoaXMuaXNOYXZCYXIsXCJuYXYtdGFic1wiOnRoaXMudGFicyxcIm5hdi1waWxsc1wiOnRoaXMucGlsbHMsXCJmbGV4LWNvbHVtblwiOnRoaXMudmVydGljYWwsXCJuYXYtZmlsbFwiOnRoaXMuZmlsbCxcIm5hdi1qdXN0aWZpZWRcIjp0aGlzLmp1c3RpZmllZH19fSxwcm9wczp7dHlwZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInVsXCJ9LGZpbGw6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxqdXN0aWZpZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSx0YWJzOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0scGlsbHM6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSx2ZXJ0aWNhbDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGlzTmF2QmFyOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19fSxuYXZJdGVtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJsaVwiLHtzdGF0aWNDbGFzczpcIm5hdi1pdGVtXCJ9LFtuKFwiYi1saW5rXCIsdC5fYih7c3RhdGljQ2xhc3M6XCJuYXYtbGlua1wiLG9uOntjbGljazpmdW5jdGlvbihlKXt0LiRlbWl0KFwiY2xpY2tcIixlKX19fSxcImItbGlua1wiLHQubGlua1Byb3BzKSxbdC5fdChcImRlZmF1bHRcIildLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXBvbmVudHM6e2JMaW5rOmJMaW5rfSxwcm9wczpwcm9wcyxjb21wdXRlZDp7bGlua1Byb3BzOmNvbXB1dGVkLmxpbmtQcm9wc319LG5hdkl0ZW1Ecm9wZG93bj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwibGlcIix7Y2xhc3M6W1wibmF2LWl0ZW1cIixcImRyb3Bkb3duXCIse2Ryb3B1cDp0LmRyb3B1cCxzaG93OnQudmlzaWJsZX1dLGF0dHJzOntpZDp0LmlkfHxudWxsfX0sW24oXCJhXCIse3JlZjpcImJ1dHRvblwiLGNsYXNzOltcIm5hdi1saW5rXCIsdC5kcm9wZG93blRvZ2dsZSx7ZGlzYWJsZWQ6dC5kaXNhYmxlZH1dLGF0dHJzOntocmVmOlwiI1wiLGlkOnQuaWQ/dC5pZCtcIl9fQlZfYnV0dG9uX1wiOm51bGwsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCIsXCJhcmlhLWV4cGFuZGVkXCI6dC52aXNpYmxlP1widHJ1ZVwiOlwiZmFsc2VcIixkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC50b2dnbGUoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQudG9nZ2xlKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LnRvZ2dsZShlKX1dfX0sW3QuX3QoXCJ0ZXh0XCIsW24oXCJzcGFuXCIse2RvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnRleHQpfX0pXSldLDIpLG4oXCJkaXZcIix7cmVmOlwibWVudVwiLGNsYXNzOltcImRyb3Bkb3duLW1lbnVcIix7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6dC5yaWdodH1dLGF0dHJzOntyb2xlOlwibWVudVwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6dC5pZD90LmlkK1wiX19CVl9idXR0b25fXCI6bnVsbH0sb246e2tleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ0YWJcIiw5KSlyZXR1cm4gbnVsbDt0Lm9uVGFiKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCEwKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX1dLG1vdXNlb3ZlcjpmdW5jdGlvbihlKXt0LmZvY3VzSG92ZXJlZChlKX19fSxbdC5fdChcImRlZmF1bHRcIildLDIpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxtaXhpbnM6W2NsaWNrT3V0LGRyb3Bkb3duXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3Zpc2libGU6ITF9fSxjb21wdXRlZDp7ZHJvcGRvd25Ub2dnbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYXJldD9cImRyb3Bkb3duLXRvZ2dsZVwiOlwiXCJ9fSxwcm9wczp7aWQ6e3R5cGU6U3RyaW5nfSxjYXJldDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITB9fSxtZXRob2RzOntjbGlja091dExpc3RlbmVyOmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlPSExfX19LG5hdlRvZ2dsZT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiYnV0dG9uXCIse2NsYXNzOnQuY2xhc3NPYmplY3QsYXR0cnM6e3R5cGU6XCJidXR0b25cIixcImFyaWEtbGFiZWxcIjp0LmxhYmVsLFwiYXJpYS1jb250cm9sc1wiOnQudGFyZ2V0LmlkP3QudGFyZ2V0LmlkOnQudGFyZ2V0LFwiYXJpYS1leHBhbmRlZFwiOnQudG9nZ2xlU3RhdGU/XCJ0cnVlXCI6XCJmYWxzZVwifSxvbjp7Y2xpY2s6dC5vbmNsaWNrfX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwibmF2YmFyLXRvZ2dsZXItaWNvblwifSldKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybltcIm5hdmJhci10b2dnbGVyXCIsXCJuYXZiYXItdG9nZ2xlci1cIit0aGlzLnBvc2l0aW9uXX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dG9nZ2xlU3RhdGU6ITF9fSxwcm9wczp7bGFiZWw6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJUb2dnbGUgbmF2aWdhdGlvblwifSxwb3NpdGlvbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInJpZ2h0XCJ9LHRhcmdldDp7cmVxdWlyZWQ6ITB9fSxtZXRob2RzOntvbmNsaWNrOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50YXJnZXQ7dC50b2dnbGUmJnQudG9nZ2xlKCksdGhpcy4kcm9vdC4kZW1pdChcImNvbGxhcHNlOjp0b2dnbGVcIix0aGlzLnRhcmdldCl9fSxjcmVhdGVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLiRyb290LiRvbihcImNvbGxhcHNlOjp0b2dnbGU6OnN0YXRlXCIsZnVuY3Rpb24oZSxuKXtlIT09dC50YXJnZXQmJmUhPT10LnRhcmdldC5pZHx8KHQudG9nZ2xlU3RhdGU9bil9KX19LG5hdmJhcj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKFwibmF2XCIse2NsYXNzOnQuY2xhc3NPYmplY3R9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm5bXCJuYXZiYXJcIix0aGlzLnR5cGU/XCJuYXZiYXItXCIrdGhpcy50eXBlOm51bGwsdGhpcy52YXJpYW50P1wiYmctXCIrdGhpcy52YXJpYW50Om51bGwsdGhpcy5maXhlZD9cImZpeGVkLVwiK3RoaXMuZml4ZWQ6bnVsbCx0aGlzLnN0aWNreT9cInN0aWNreS10b3BcIjpudWxsLHRoaXMudG9nZ2xlYWJsZT90aGlzLnRvZ2dsZWFibGVDbGFzczpudWxsXX0sdG9nZ2xlYWJsZUNsYXNzOmZ1bmN0aW9uKCl7dmFyIHQ9XCJuYXZiYXItdG9nZ2xlYWJsZVwiO3JldHVybiB0aGlzLnRvZ2dsZUJyZWFrcG9pbnQmJih0Kz1cIi1cIit0aGlzLnRvZ2dsZUJyZWFrcG9pbnQpLHR9fSxwcm9wczp7dHlwZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImxpZ2h0XCJ9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nfSx0b2dnbGVhYmxlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdG9nZ2xlQnJlYWtwb2ludDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxmaXhlZDp7dHlwZTpTdHJpbmd9LHN0aWNreTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sbmF2VGV4dD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKFwic3BhblwiLHtzdGF0aWNDbGFzczpcIm5hdmJhci10ZXh0XCJ9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxwcm9wczp7fX0sbmF2Rm9ybT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKFwiYi1mb3JtXCIse2F0dHJzOntpZDp0LmlkfHxudWxsLGlubGluZTpcIlwifX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXBvbmVudHM6W2JGb3JtXSxwcm9wczp7aWQ6e3R5cGU6U3RyaW5nfX19LEVMTElQU0lTX1RIUkVTSE9MRD0zLHBhZ2luYXRpb249e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcInVsXCIse2NsYXNzOltcInBhZ2luYXRpb25cIix0LmJ0blNpemVdLGF0dHJzOntyb2xlOnQucm9sZSxcImFyaWEtZGlzYWJsZWRcIjp0LmRpc2FibGVkP1widHJ1ZVwiOlwiZmFsc2VcIixcImFyaWEtbGFiZWxcIjp0LmFyaWFMYWJlbD90LmFyaWFMYWJlbDpudWxsfSxvbjp7Zm9jdXNpbjpmdW5jdGlvbihlKXtpZihlLnRhcmdldCE9PWUuY3VycmVudFRhcmdldClyZXR1cm4gbnVsbDt0LmZvY3VzQ3VycmVudChlKX0sa2V5ZG93bjpbZnVuY3Rpb24oZSl7cmV0dXJuXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcImxlZnRcIiwzNyk/XCJidXR0b25cImluIGUmJjAhPT1lLmJ1dHRvbj9udWxsOihlLnByZXZlbnREZWZhdWx0KCksdm9pZCB0LmZvY3VzUHJldihlKSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcInJpZ2h0XCIsMzkpP1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDooZS5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5mb2N1c05leHQoZSkpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwibGVmdFwiLDM3KSkmJmUuc2hpZnRLZXk/XCJidXR0b25cImluIGUmJjAhPT1lLmJ1dHRvbj9udWxsOihlLnByZXZlbnREZWZhdWx0KCksdm9pZCB0LmZvY3VzRmlyc3QoZSkpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwicmlnaHRcIiwzOSkpJiZlLnNoaWZ0S2V5P1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDooZS5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5mb2N1c0xhc3QoZSkpOm51bGx9XX19LFt0LmhpZGVHb3RvRW5kQnV0dG9ucz90Ll9lKCk6W3QuaXNBY3RpdmUoMSl8fHQuZGlzYWJsZWQ/bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtIGRpc2FibGVkXCIsYXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmZpcnN0VGV4dCl9fSldKTpuKFwibGlcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWl0ZW1cIn0sW24oXCJhXCIse3N0YXRpY0NsYXNzOlwicGFnZS1saW5rXCIsYXR0cnM6e3JvbGU6dC5idXR0b25Sb2xlLFwiYXJpYS1sYWJlbFwiOnQubGFiZWxGaXJzdFBhZ2UsdGFiaW5kZXg6XCItMVwiLGhyZWY6XCIjXCJ9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsMSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSwxKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLDEpfV19fSxbbihcInNwYW5cIix7YXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZmlyc3RUZXh0KX19KV0pXSldLHQuaXNBY3RpdmUoMSl8fHQuZGlzYWJsZWQ/bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtIGRpc2FibGVkXCIsYXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnByZXZUZXh0KX19KV0pOm4oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbVwifSxbbihcImFcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixhdHRyczp7cm9sZTp0LmJ1dHRvblJvbGUsXCJhcmlhLWxhYmVsXCI6dC5sYWJlbFByZXZQYWdlLHRhYmluZGV4OlwiLTFcIixocmVmOlwiI1wifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLHQuY3VycmVudFBhZ2UtMSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSx0LmN1cnJlbnRQYWdlLTEpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsdC5jdXJyZW50UGFnZS0xKX1dfX0sW24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnByZXZUZXh0KX19KV0pXSksdC5zaG93Rmlyc3REb3RzP24oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbSBkaXNhYmxlZCBoaWRkZW4teHMtZG93blwiLGF0dHJzOntyb2xlOlwic2VwZXJhdG9yXCJ9fSxbbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5lbGxpcHNpc1RleHQpfX0pXSk6dC5fZSgpLHQuX2wodC5wYWdlTGlzdCxmdW5jdGlvbihlKXtyZXR1cm4gbihcImxpXCIse2tleTplLm51bWJlcixjbGFzczp0LnBhZ2VJdGVtQ2xhc3NlcyhlKX0sW24oXCJhXCIse2NsYXNzOnQucGFnZUxpbmtDbGFzc2VzKGUpLGF0dHJzOntyb2xlOnQuYnV0dG9uUm9sZSxkaXNhYmxlZDp0LmRpc2FibGVkLFwiYXJpYS1kaXNhYmxlZFwiOnQuZGlzYWJsZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiLFwiYXJpYS1sYWJlbFwiOnQubGFiZWxQYWdlK1wiIFwiK2UubnVtYmVyLFwiYXJpYS1jdXJyZW50XCI6dC5pc0FjdGl2ZShlKT9cInRydWVcIjpcImZhbHNlXCIsXCJhcmlhLXBvc2luc2V0XCI6ZS5udW1iZXIsXCJhcmlhLXNldHNpemVcIjp0Lm51bWJlck9mUGFnZXMsdGFiaW5kZXg6XCItMVwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24obil7bi5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShuLGUubnVtYmVyKX0sa2V5ZG93bjpbZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwiZW50ZXJcIiwxMykpcmV0dXJuIG51bGw7bi5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShuLGUubnVtYmVyKX0sZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7bi5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShuLGUubnVtYmVyKX1dfX0sW3QuX3YodC5fcyhlLm51bWJlcikpXSldKX0pLHQuc2hvd0xhc3REb3RzP24oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbSBkaXNhYmxlZCBoaWRkZW4teHMtZG93blwiLGF0dHJzOntyb2xlOlwic2VwZXJhdG9yXCJ9fSxbbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5lbGxpcHNpc1RleHQpfX0pXSk6dC5fZSgpLHQuaXNBY3RpdmUodC5udW1iZXJPZlBhZ2VzKXx8dC5kaXNhYmxlZD9uKFwibGlcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWl0ZW0gZGlzYWJsZWRcIixhdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwicGFnZS1saW5rXCIsZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQubmV4dFRleHQpfX0pXSk6bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtXCJ9LFtuKFwiYVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGF0dHJzOntyb2xlOnQuYnV0dG9uUm9sZSxcImFyaWEtbGFiZWxcIjp0LmxhYmVsTmV4dFBhZ2UsdGFiaW5kZXg6XCItMVwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLHQuY3VycmVudFBhZ2UrMSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSx0LmN1cnJlbnRQYWdlKzEpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsdC5jdXJyZW50UGFnZSsxKX1dfX0sW24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0Lm5leHRUZXh0KX19KV0pXSksdC5oaWRlR290b0VuZEJ1dHRvbnM/dC5fZSgpOlt0LmlzQWN0aXZlKHQubnVtYmVyT2ZQYWdlcyl8fHQuZGlzYWJsZWQ/bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtIGRpc2FibGVkXCIsYXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0Lmxhc3RUZXh0KX19KV0pOm4oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbVwifSxbbihcImFcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixhdHRyczp7cm9sZTp0LmJ1dHRvblJvbGUsXCJhcmlhLWxhYmVsXCI6dC5sYWJlbExhc3RQYWdlLHRhYmluZGV4OlwiLTFcIn0sb246e2NsaWNrOmZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSx0Lm51bWJlck9mUGFnZXMpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsdC5udW1iZXJPZlBhZ2VzKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLHQubnVtYmVyT2ZQYWdlcyl9XX19LFtuKFwic3BhblwiLHthdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSxkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5sYXN0VGV4dCl9fSldKV0pXV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxfc2NvcGVJZDpcImRhdGEtdi0yNzkyOTYwYlwiLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57c2hvd0ZpcnN0RG90czohMSxzaG93TGFzdERvdHM6ITEsY3VycmVudFBhZ2U6dGhpcy52YWx1ZX19LGNvbXB1dGVkOntudW1iZXJPZlBhZ2VzOmZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5jZWlsKHRoaXMudG90YWxSb3dzL3RoaXMucGVyUGFnZSk7cmV0dXJuIHQ8MT8xOnR9LGJ0blNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplP1wicGFnaW5hdGlvbi1cIit0aGlzLnNpemU6XCJcIn0scGFnZUxpc3Q6ZnVuY3Rpb24oKXt0aGlzLmN1cnJlbnRQYWdlPnRoaXMubnVtYmVyT2ZQYWdlcz90aGlzLmN1cnJlbnRQYWdlPXRoaXMubnVtYmVyT2ZQYWdlczp0aGlzLmN1cnJlbnRQYWdlPDEmJih0aGlzLmN1cnJlbnRQYWdlPTEpLHRoaXMuc2hvd0ZpcnN0RG90cz0hMSx0aGlzLnNob3dMYXN0RG90cz0hMTt2YXIgdD10aGlzLmxpbWl0LGU9MTt0aGlzLm51bWJlck9mUGFnZXM8PXRoaXMubGltaXQ/dD10aGlzLm51bWJlck9mUGFnZXM6dGhpcy5jdXJyZW50UGFnZTx0aGlzLmxpbWl0LTEmJnRoaXMubGltaXQ+RUxMSVBTSVNfVEhSRVNIT0xEP3RoaXMuaGlkZUVsbGlwc2lzfHwodD10aGlzLmxpbWl0LTEsdGhpcy5zaG93TGFzdERvdHM9ITApOnRoaXMubnVtYmVyT2ZQYWdlcy10aGlzLmN1cnJlbnRQYWdlKzI8dGhpcy5saW1pdCYmdGhpcy5saW1pdD5FTExJUFNJU19USFJFU0hPTEQ/KHRoaXMuaGlkZUVsbGlwc2lzfHwodGhpcy5zaG93Rmlyc3REb3RzPSEwLHQ9dGhpcy5saW1pdC0xKSxlPXRoaXMubnVtYmVyT2ZQYWdlcy10KzEpOih0aGlzLmxpbWl0PkVMTElQU0lTX1RIUkVTSE9MRCYmIXRoaXMuaGlkZUVsbGlwc2lzJiYodGhpcy5zaG93Rmlyc3REb3RzPSEwLHRoaXMuc2hvd0xhc3REb3RzPSEwLHQ9dGhpcy5saW1pdC0yKSxlPXRoaXMuY3VycmVudFBhZ2UtTWF0aC5mbG9vcih0LzIpKSxlPDE/ZT0xOmU+dGhpcy5udW1iZXJPZlBhZ2VzLXQmJihlPXRoaXMubnVtYmVyT2ZQYWdlcy10KzEpO3ZhciBuPW1ha2VQYWdlQXJyYXkoZSx0KTtpZihuLmxlbmd0aD4zKXt2YXIgaT10aGlzLmN1cnJlbnRQYWdlLWU7aWYoMD09PWkpZm9yKHZhciBvPTM7bzxuLmxlbmd0aDtvKyspbltvXS5jbGFzc05hbWU9XCJoaWRkZW4teHMtZG93blwiO2Vsc2UgaWYoaT09PW4ubGVuZ3RoLTEpZm9yKHZhciByPTA7cjxuLmxlbmd0aC0zO3IrKyluW3JdLmNsYXNzTmFtZT1cImhpZGRlbi14cy1kb3duXCI7ZWxzZXtmb3IodmFyIHM9MDtzPGktMTtzKyspbltzXS5jbGFzc05hbWU9XCJoaWRkZW4teHMtZG93blwiO2Zvcih2YXIgYT1uLmxlbmd0aC0xO2E+aSsxO2EtLSluW2FdLmNsYXNzTmFtZT1cImhpZGRlbi14cy1kb3duXCJ9fXJldHVybiBufX0sbWV0aG9kczp7aXNBY3RpdmU6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLmN1cnJlbnRQYWdlfSxwYWdlSXRlbUNsYXNzZXM6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pc0FjdGl2ZSh0Lm51bWJlcik7cmV0dXJuW1wicGFnZS1pdGVtXCIsdGhpcy5kaXNhYmxlZD9cImRpc2FibGVkXCI6XCJcIixlP1wiYWN0aXZlXCI6XCJcIix0LmNsYXNzTmFtZV19LHBhZ2VMaW5rQ2xhc3NlczpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmlzQWN0aXZlKHQubnVtYmVyKTtyZXR1cm5bXCJwYWdlLWxpbmtcIix0aGlzLmRpc2FibGVkP1wiZGlzYWJsZWRcIjpcIlwiLGU/XCJhY3RpdmVcIjpcIlwiXX0sc2V0UGFnZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7aWYodGhpcy5kaXNhYmxlZClyZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5zdG9wUHJvcGFnYXRpb24oKTtlPnRoaXMubnVtYmVyT2ZQYWdlcz90aGlzLmN1cnJlbnRQYWdlPXRoaXMubnVtYmVyT2ZQYWdlczplPDE/dGhpcy5jdXJyZW50cGFnZT0xOnRoaXMuY3VycmVudFBhZ2U9ZSx0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpe2lzVmlzaWJsZSQxKHQudGFyZ2V0KSYmdC50YXJnZXQuZm9jdXM/dC50YXJnZXQuZm9jdXMoKTpuLmZvY3VzQ3VycmVudCgpfSksdGhpcy4kZW1pdChcImNoYW5nZVwiLHRoaXMuY3VycmVudFBhZ2UpfSxnZXRCdXR0b25zOmZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhLnBhZ2UtbGlua1wiKSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBpc1Zpc2libGUkMSh0KX0pfSxzZXRCdG5Gb2N1czpmdW5jdGlvbih0KXt0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpe3QuZm9jdXMoKX0pfSxmb2N1c0ZpcnN0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRCdXR0b25zKCkuZmluZChmdW5jdGlvbih0KXtyZXR1cm4hdC5kaXNhYmxlZH0pO3QmJnQuZm9jdXMmJnQhPT1kb2N1bWVudC5hY3RpdmVFbGVtZW50JiZ0aGlzLnNldEJ0bkZvY3VzKHQpfSxmb2N1c0xhc3Q6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldEJ1dHRvbnMoKS5yZXZlcnNlKCkuZmluZChmdW5jdGlvbih0KXtyZXR1cm4hdC5kaXNhYmxlZH0pO3QmJnQuZm9jdXMmJnQhPT1kb2N1bWVudC5hY3RpdmVFbGVtZW50JiZ0aGlzLnNldEJ0bkZvY3VzKHQpfSxmb2N1c0N1cnJlbnQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5nZXRCdXR0b25zKCkuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLXBvc2luc2V0XCIpLDEwKT09PXQuY3VycmVudFBhZ2V9KTtlJiZlLmZvY3VzP3RoaXMuc2V0QnRuRm9jdXMoZSk6dGhpcy5mb2N1c0ZpcnN0KCl9LGZvY3VzUHJldjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0QnV0dG9ucygpLGU9dC5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO2U+MCYmIXRbZS0xXS5kaXNhYmxlZCYmdFtlLTFdLmZvY3VzJiZ0aGlzLnNldEJ0bkZvY3VzKHRbZS0xXSl9LGZvY3VzTmV4dDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0QnV0dG9ucygpLGU9dC5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO2U8dC5sZW5ndGgtMSYmIXRbZSsxXS5kaXNhYmxlZCYmdFtlKzFdLmZvY3VzJiZ0aGlzLnNldEJ0bkZvY3VzKHRbZSsxXSl9fSx3YXRjaDp7Y3VycmVudFBhZ2U6ZnVuY3Rpb24odCxlKXt0IT09ZSYmdGhpcy4kZW1pdChcImlucHV0XCIsdCl9LHZhbHVlOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJih0aGlzLmN1cnJlbnRQYWdlPXQpfX0scHJvcHM6e2Rpc2FibGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdmFsdWU6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MX0sbGltaXQ6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6NX0scGVyUGFnZTp7dHlwZTpOdW1iZXIsZGVmYXVsdDoyMH0sdG90YWxSb3dzOnt0eXBlOk51bWJlcixkZWZhdWx0OjIwfSxzaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwibWRcIn0saGlkZUdvdG9FbmRCdXR0b25zOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYXJpYUxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiUGFnaW5hdGlvblwifSxsYWJlbEZpcnN0UGFnZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkdvdG8gZmlyc3QgcGFnZVwifSxmaXJzdFRleHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCImbGFxdW9cIn0sbGFiZWxQcmV2UGFnZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkdvdG8gcHJldmlvdXMgcGFnZVwifSxwcmV2VGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZsc2FxdW87XCJ9LGxhYmVsTmV4dFBhZ2U6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJHb3RvIG5leHQgcGFnZVwifSxuZXh0VGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZyc2FxdW87XCJ9LGxhYmVsTGFzdFBhZ2U6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJHb3RvIGxhc3QgcGFnZVwifSxsYXN0VGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZyYXF1bztcIn0sbGFiZWxQYWdlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiR290byBwYWdlXCJ9LGhpZGVFbGxpcHNpczp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGVsbGlwc2lzVGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZoZWxsaXA7XCJ9LHJvbGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJncm91cFwifSxidXR0b25Sb2xlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiYnV0dG9uXCJ9fX0sVFJJR0dFUl9MSVNURU5FUlM9e2NsaWNrOntjbGljazpcInRvZ2dsZVwifSxob3Zlcjp7bW91c2VlbnRlcjpcInNob3dcIixtb3VzZWxlYXZlOlwiaGlkZVwifSxmb2N1czp7Zm9jdXM6XCJzaG93XCIsYmx1cjpcImhpZGVcIn19LFBMQUNFTUVOVF9QQVJBTVM9e3RvcDpcImJvdHRvbSBjZW50ZXJcIixib3R0b206XCJ0b3AgY2VudGVyXCIsbGVmdDpcIm1pZGRsZSByaWdodFwiLHJpZ2h0OlwibWlkZGxlIGxlZnRcIn0sVEVUSEVSX0NMQVNTX1BSRUZJWD1cImJzLXRldGhlclwiLFRFVEhFUl9DTEFTU0VTPXtlbGVtZW50OiExLGVuYWJsZWQ6ITF9LFRSQU5TSVRJT05fRFVSQVRJT049MTUwLHBvcG92ZXIkMT17cHJvcHM6e2NvbnN0cmFpbnRzOnt0eXBlOkFycmF5LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19LGRlYm91bmNlOnt0eXBlOltOdW1iZXJdLGRlZmF1bHQ6MzAwLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4gdD49MH19LGRlbGF5Ont0eXBlOltOdW1iZXIsT2JqZWN0XSxkZWZhdWx0OjAsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P3Q+PTA6bnVsbCE9PXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiYoXCJudW1iZXJcIj09dHlwZW9mIHQuc2hvdyYmXCJudW1iZXJcIj09dHlwZW9mIHQuaGlkZSYmdC5zaG93Pj0wJiZ0LmhpZGU+PTApfX0sb2Zmc2V0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiMCAwXCIsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybi9eKCgwXFxzPyl8KFsrLV0/WzAtOV0rKHB4fCUpXFxzPykpezJ9JC8udGVzdCh0KX19LHBsYWNlbWVudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInRvcFwiLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4tMSE9PU9iamVjdC5rZXlzKFBMQUNFTUVOVF9QQVJBTVMpLmluZGV4T2YodCl9fSxwb3BvdmVyU3R5bGU6e3R5cGU6T2JqZWN0LGRlZmF1bHQ6bnVsbH0sc2hvdzp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6bnVsbH0sdGFyZ2V0T2Zmc2V0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiMCAwXCIsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybi9eKCgwXFxzPyl8KFsrLV0/WzAtOV0rKHB4fCUpXFxzPykpezJ9JC8udGVzdCh0KX19LHRyaWdnZXJzOnt0eXBlOltCb29sZWFuLFN0cmluZyxBcnJheV0sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybltcImNsaWNrXCIsXCJmb2N1c1wiXX0sdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe2lmKCExPT09dHx8XCJcIj09PXQpcmV0dXJuITA7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuLTEhPT1PYmplY3Qua2V5cyhUUklHR0VSX0xJU1RFTkVSUykuaW5kZXhPZih0KTtpZihBcnJheS5pc0FycmF5KHQpKXt2YXIgZT1PYmplY3Qua2V5cyhUUklHR0VSX0xJU1RFTkVSUyk7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtpZigtMT09PWUuaW5kZXhPZih0KSlyZXR1cm4hMX0pLCEwfXJldHVybiExfX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dHJpZ2dlclN0YXRlOnRoaXMuc2hvdyxjbGFzc1N0YXRlOnRoaXMuc2hvdyxsYXN0RXZlbnQ6bnVsbH19LGNvbXB1dGVkOntub3JtYWxpemVkVHJpZ2dlcnM6ZnVuY3Rpb24oKXtyZXR1cm4hMT09PXRoaXMudHJpZ2dlcnM/W106XCJzdHJpbmdcIj09dHlwZW9mIHRoaXMudHJpZ2dlcnM/W3RoaXMudHJpZ2dlcnNdOnRoaXMudHJpZ2dlcnN9LHBvcG92ZXJBbGlnbm1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGFjZW1lbnQmJlwiZGVmYXVsdFwiIT09dGhpcy5wbGFjZW1lbnQ/XCJwb3BvdmVyLVwiK3RoaXMucGxhY2VtZW50OlwicG9wb3Zlci10b3BcIn0sc2hvd1N0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITEhPT10aGlzLnNob3cmJih0aGlzLnRyaWdnZXJTdGF0ZXx8dGhpcy5zaG93KX19LHdhdGNoOntjb25zdHJhaW50czpmdW5jdGlvbigpe3RoaXMuc2V0T3B0aW9ucygpfSxub3JtYWxpemVkVHJpZ2dlcnM6ZnVuY3Rpb24odCxlKXt0aGlzLnVwZGF0ZUxpc3RlbmVycyh0LGUpfSxvZmZzZXQ6ZnVuY3Rpb24oKXt0aGlzLnNldE9wdGlvbnMoKX0scGxhY2VtZW50OmZ1bmN0aW9uKCl7dGhpcy5zZXRPcHRpb25zKCl9LHNob3dTdGF0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy5nZXREZWxheSh0KTtjbGVhclRpbWVvdXQodGhpcy4kZGF0YS5fdGltZW91dCksbj90aGlzLiRkYXRhLl90aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZS50b2dnbGVQb3BvdmVyKHQpfSxuKTp0aGlzLnRvZ2dsZVBvcG92ZXIodCl9fSxtZXRob2RzOnthZGRMaXN0ZW5lcjpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2Zvcih2YXIgbiBpbiBUUklHR0VSX0xJU1RFTkVSU1t0XSllLiRkYXRhLl90cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIobixmdW5jdGlvbih0KXtyZXR1cm4gZS5ldmVudEhhbmRsZXIodCl9KX0sZGVzdHJveVRldGhlcjpmdW5jdGlvbigpe2lmKHRoaXMuJGRhdGEuX3RldGhlciYmIXRoaXMuc2hvd1N0YXRlKXt0aGlzLiRkYXRhLl90ZXRoZXIuZGVzdHJveSgpLHRoaXMuJGRhdGEuX3RldGhlcj1udWxsO3ZhciB0PW5ldyBSZWdFeHAoXCIoXnxbXi1dXFxcXGIpKFwiK1RFVEhFUl9DTEFTU19QUkVGSVgrXCJcXFxcUyopXCIsXCJnXCIpO3RoaXMuJGRhdGEuX3RyaWdnZXIuY2xhc3NOYW1lPXRoaXMuJGRhdGEuX3RyaWdnZXIuY2xhc3NOYW1lLnJlcGxhY2UodCxcIlwiKX19LGV2ZW50SGFuZGxlcjpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCEodGhpcy5ub3JtYWxpemVkVHJpZ2dlcnMubGVuZ3RoPjEmJnRoaXMuZGVib3VuY2U+MCYmbnVsbCE9PXRoaXMubGFzdEV2ZW50JiZ0LnRpbWVTdGFtcDw9dGhpcy5sYXN0RXZlbnQrdGhpcy5kZWJvdW5jZSkpZm9yKHZhciBuIGluIFRSSUdHRVJfTElTVEVORVJTKWZvcih2YXIgaSBpbiBUUklHR0VSX0xJU1RFTkVSU1tuXSlpZihpPT09dC50eXBlKXt2YXIgbz1UUklHR0VSX0xJU1RFTkVSU1tuXVtpXTtyZXR1cm4gdm9pZCgoXCJ0b2dnbGVcIj09PW98fGUudHJpZ2dlclN0YXRlJiZcImhpZGVcIj09PW98fCFlLnRyaWdnZXJTdGF0ZSYmXCJzaG93XCI9PT1vKSYmKGUudHJpZ2dlclN0YXRlPSFlLnRyaWdnZXJTdGF0ZSxlLmxhc3RFdmVudD10LnRpbWVTdGFtcCkpfX0sZ2V0RGVsYXk6ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHRoaXMuZGVsYXk/dD90aGlzLmRlbGF5LnNob3c6dGhpcy5kZWxheS5oaWRlOnRoaXMuZGVsYXl9LGdldFRldGhlck9wdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm57YXR0YWNobWVudDpQTEFDRU1FTlRfUEFSQU1TW3RoaXMucGxhY2VtZW50XSxlbGVtZW50OnRoaXMuJGRhdGEuX3BvcG92ZXIsdGFyZ2V0OnRoaXMuJGRhdGEuX3RyaWdnZXIsY2xhc3NlczpURVRIRVJfQ0xBU1NFUyxjbGFzc1ByZWZpeDpURVRIRVJfQ0xBU1NfUFJFRklYLG9mZnNldDp0aGlzLm9mZnNldCxjb25zdHJhaW50czp0aGlzLmNvbnN0cmFpbnRzLHRhcmdldE9mZnNldDp0aGlzLnRhcmdldE9mZnNldH19LGhpZGVQb3BvdmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmNsYXNzU3RhdGU9ITEsY2xlYXJUaW1lb3V0KHRoaXMuJGRhdGEuX3RpbWVvdXQpLHRoaXMuJGRhdGEuX3RpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe3QuJGRhdGEuX3BvcG92ZXIuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0LmRlc3Ryb3lUZXRoZXIoKX0sVFJBTlNJVElPTl9EVVJBVElPTil9LHJlZnJlc2hQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy4kZGF0YS5fdGV0aGVyJiZ0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpe3QuJGRhdGEuX3RldGhlci5wb3NpdGlvbigpfSl9LHJlbW92ZUxpc3RlbmVyOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7Zm9yKHZhciBuIGluIFRSSUdHRVJfTElTVEVORVJTW3RdKWUuJGRhdGEuX3RyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuLGZ1bmN0aW9uKHQpe3JldHVybiBlLmV2ZW50SGFuZGxlcih0KX0pfSxzZXRPcHRpb25zOmZ1bmN0aW9uKCl7dGhpcy4kZGF0YS5fdGV0aGVyJiZ0aGlzLiRkYXRhLl90ZXRoZXIuc2V0T3B0aW9ucyh0aGlzLmdldFRldGhlck9wdGlvbnMoKSl9LHNob3dQb3BvdmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztjbGVhclRpbWVvdXQodGhpcy4kZGF0YS5fdGltZW91dCksdGhpcy4kZGF0YS5fdGV0aGVyfHwodGhpcy4kZGF0YS5fdGV0aGVyPW5ldyBUZXRoZXIodGhpcy5nZXRUZXRoZXJPcHRpb25zKCkpKSx0aGlzLiRkYXRhLl9wb3BvdmVyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMucmVmcmVzaFBvc2l0aW9uKCksdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKXt0LmNsYXNzU3RhdGU9ITB9KX0sdG9nZ2xlUG9wb3ZlcjpmdW5jdGlvbih0KXt0aGlzLiRlbWl0KFwic2hvd0NoYW5nZVwiLHQpLHQ/KHRoaXMuc2hvd1BvcG92ZXIoKSx0aGlzLiRyb290LiRlbWl0KFwic2hvd246OnBvcG92ZXJcIikpOih0aGlzLmhpZGVQb3BvdmVyKCksdGhpcy4kcm9vdC4kZW1pdChcImhpZGRlbjo6cG9wb3ZlclwiKSl9LHVwZGF0ZUxpc3RlbmVyczpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dm9pZCAwPT09ZSYmKGU9W10pO3ZhciBpPVtdLG89W107dC5mb3JFYWNoKGZ1bmN0aW9uKHQpey0xPT09ZS5pbmRleE9mKHQpJiZpLnB1c2godCl9KSxlLmZvckVhY2goZnVuY3Rpb24oZSl7LTE9PT10LmluZGV4T2YoZSkmJm8ucHVzaChlKX0pLGkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gbi5hZGRMaXN0ZW5lcih0KX0pLG8uZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gbi5yZW1vdmVMaXN0ZW5lcih0KX0pfX0sY3JlYXRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy4kcm9vdC4kb24oXCJoaWRlOjpwb3BvdmVyXCIsZnVuY3Rpb24oKXt0LnRyaWdnZXJTdGF0ZT0hMX0pfSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy4kZGF0YS5fdHJpZ2dlcj10aGlzLiRyZWZzLnRyaWdnZXIuY2hpbGRyZW5bMF18fHRoaXMuJHJlZnMudHJpZ2dlcix0aGlzLiRkYXRhLl9wb3BvdmVyPXRoaXMuJHJlZnMucG9wb3Zlcix0aGlzLiRkYXRhLl9wb3BvdmVyLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy4kZGF0YS5fdGV0aGVyPW5ldyBUZXRoZXIodGhpcy5nZXRUZXRoZXJPcHRpb25zKCkpLHRoaXMuJGRhdGEuX3RpbWVvdXQ9MCx0aGlzLnVwZGF0ZUxpc3RlbmVycyh0aGlzLm5vcm1hbGl6ZWRUcmlnZ2VycyksdGhpcy5zaG93U3RhdGUmJnRoaXMuc2hvd1BvcG92ZXIoKX0sdXBkYXRlZDpmdW5jdGlvbigpe3RoaXMucmVmcmVzaFBvc2l0aW9uKCl9LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMubm9ybWFsaXplZFRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQucmVtb3ZlTGlzdGVuZXIoZSl9KSxjbGVhclRpbWVvdXQodGhpcy4kZGF0YS5fdGltZW91dCksdGhpcy5kZXN0cm95VGV0aGVyKCl9LGRlc3Ryb3llZDpmdW5jdGlvbigpe3RoaXMuJGRhdGEuX3BvcG92ZXIucGFyZW50RWxlbWVudD09PWRvY3VtZW50LmJvZHkmJmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy4kZGF0YS5fcG9wb3Zlcil9fSxwb3BvdmVyPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIixbbihcInNwYW5cIix7cmVmOlwidHJpZ2dlclwifSxbdC5fdChcImRlZmF1bHRcIildLDIpLG4oXCJkaXZcIix7cmVmOlwicG9wb3ZlclwiLGNsYXNzOltcInBvcG92ZXJcIixcImZhZGVcIix0LmNsYXNzU3RhdGU/XCJzaG93XCI6XCJcIix0LnBvcG92ZXJBbGlnbm1lbnRdLHN0eWxlOnQucG9wb3ZlclN0eWxlLGF0dHJzOnt0YWJpbmRleDpcIi0xXCJ9LG9uOntmb2N1czpmdW5jdGlvbihlKXt0LiRlbWl0KFwiZm9jdXNcIil9LGJsdXI6ZnVuY3Rpb24oZSl7dC4kZW1pdChcImJsdXJcIil9fX0sW24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJwb3BvdmVyLWFycm93XCJ9KSx0LnRpdGxlP24oXCJoM1wiLHtzdGF0aWNDbGFzczpcInBvcG92ZXItdGl0bGVcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC50aXRsZSl9fSk6dC5fZSgpLG4oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJwb3BvdmVyLWNvbnRlbnRcIn0sW24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJwb3BvdmVyLWNvbnRlbnQtd3JhcHBlclwifSxbdC5fdChcImNvbnRlbnRcIixbbihcInNwYW5cIix7ZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuY29udGVudCl9fSldKV0sMildKV0pXSl9LHN0YXRpY1JlbmRlckZuczpbXSxtaXhpbnM6W3BvcG92ZXIkMV0scHJvcHM6e3RpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LGNvbnRlbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJcIn0scG9wb3ZlclN0eWxlOnt0eXBlOk9iamVjdCxkZWZhdWx0Om51bGx9fX0scHJvZ3Jlc3M9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtzdGF0aWNDbGFzczpcInByb2dyZXNzXCJ9LFtuKFwidHJhbnNpdGlvblwiLFtuKFwiZGl2XCIse2NsYXNzOnQuY2xhc3NPYmplY3Qsc3R5bGU6dC5zdHlsZU9iamVjdCxhdHRyczp7cm9sZTpcInByb2dyZXNzYmFyXCIsXCJhcmlhLXZhbHVlbm93XCI6dC52YWx1ZSxcImFyaWEtdmFsdWVtaW5cIjowLFwiYXJpYS12YWx1ZW1heFwiOnQubWF4fX0sW3QuX3QoXCJkZWZhdWx0XCIsW3Quc2hvd1Byb2dyZXNzP1t0Ll92KHQuX3ModC5wcm9ncmVzcykrXCIlXCIpXTp0LnNob3dWYWx1ZT9bdC5fdih0Ll9zKHQudmFsdWUpKV06dC5fZSgpXSldLDIpXSldLDEpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcHV0ZWQ6e2NsYXNzT2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuW1wicHJvZ3Jlc3MtYmFyXCIsdGhpcy5wcm9ncmVzc1ZhcmlhbnQsdGhpcy5zdHJpcGVkfHx0aGlzLmFuaW1hdGVkP1wicHJvZ3Jlc3MtYmFyLXN0cmlwZWRcIjpcIlwiLHRoaXMuYW5pbWF0ZWQ/XCJwcm9ncmVzcy1iYXItYW5pbWF0ZWRcIjpcIlwiXX0sc3R5bGVPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm57d2lkdGg6dGhpcy5wcm9ncmVzcytcIiVcIn19LHByb2dyZXNzVmFyaWFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhcmlhbnQ/XCJiZy1cIit0aGlzLnZhcmlhbnQ6bnVsbH0scHJvZ3Jlc3M6ZnVuY3Rpb24oKXt2YXIgdD1NYXRoLnBvdygxMCx0aGlzLnByZWNpc2lvbik7cmV0dXJuIE1hdGgucm91bmQoMTAwKnQqdGhpcy52YWx1ZS90aGlzLm1heCkvdH19LHByb3BzOntzdHJpcGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYW5pbWF0ZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxwcmVjaXNpb246e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MH0sdmFsdWU6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MH0sbWF4Ont0eXBlOk51bWJlcixkZWZhdWx0OjEwMH0sdmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxzaG93UHJvZ3Jlc3M6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzaG93VmFsdWU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LHRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0P3QgaW5zdGFuY2VvZiBPYmplY3Q/T2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0b1N0cmluZyh0W2VdKX0pLmpvaW4oXCIgXCIpOlN0cmluZyh0KTpcIlwifSxyZWNUb1N0cmluZz1mdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBPYmplY3QpKXJldHVyblwiXCI7dmFyIGU9e3N0YXRlOiEwLF9yb3dWYXJpYW50OiEwfTtyZXR1cm4gdG9TdHJpbmcoT2JqZWN0LmtleXModCkucmVkdWNlKGZ1bmN0aW9uKG4saSl7cmV0dXJuIGVbaV18fChuW2ldPXRbaV0pLG59LHt9KSl9LGRlZmF1bHRTb3J0Q29tcGFyZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHRbbl0mJlwibnVtYmVyXCI9PXR5cGVvZiBlW25dP3Rbbl08ZVtuXT8tMTp0W25dPmVbbl0/MTowOnRvU3RyaW5nKHRbbl0pLmxvY2FsZUNvbXBhcmUodG9TdHJpbmcoZVtuXSksdm9pZCAwLHtudW1lcmljOiEwfSl9LHRhYmxlPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJ0YWJsZVwiLHtjbGFzczp0LnRhYmxlQ2xhc3MsYXR0cnM6e2lkOnQuaWR8fG51bGwscm9sZTpcImdyaWRcIixcImFyaWEtYnVzeVwiOnQuYnVzeT9cInRydWVcIjpcImZhbHNlXCJ9fSxbbihcInRoZWFkXCIse2NsYXNzOnQuaGVhZENsYXNzfSxbbihcInRyXCIse2F0dHJzOntyb2xlOlwicm93XCJ9fSx0Ll9sKHQuZmllbGRzLGZ1bmN0aW9uKGUsaSl7cmV0dXJuIG4oXCJ0aFwiLHtrZXk6aSxjbGFzczp0LmZpZWxkQ2xhc3MoZSxpKSxzdHlsZTplLnRoU3R5bGV8fHt9LGF0dHJzOntcImFyaWEtbGFiZWxcIjplLnNvcnRhYmxlP3Quc29ydERlc2MmJnQuc29ydEJ5PT09aT90LmxhYmVsU29ydEFzYzp0LmxhYmVsU29ydERlc2M6bnVsbCxcImFyaWEtc29ydFwiOmUuc29ydGFibGUmJnQuc29ydEJ5PT09aT90LnNvcnREZXNjP1wiZGVzY2VuZGluZ1wiOlwiYXNjZW5kaW5nXCI6bnVsbCx0YWJpbmRleDplLnNvcnRhYmxlP1wiMFwiOm51bGx9LG9uOntjbGljazpmdW5jdGlvbihuKXtuLnN0b3BQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSx0LmhlYWRDbGlja2VkKG4sZSxpKX0sa2V5ZG93bjpbZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwiZW50ZXJcIiwxMykpcmV0dXJuIG51bGw7bi5zdG9wUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCksdC5oZWFkQ2xpY2tlZChuLGUsaSl9LGZ1bmN0aW9uKG4pe2lmKCEoXCJidXR0b25cImluIG4pJiZ0Ll9rKG4ua2V5Q29kZSxcInNwYWNlXCIsMzIpKXJldHVybiBudWxsO24uc3RvcFByb3BhZ2F0aW9uKCksbi5wcmV2ZW50RGVmYXVsdCgpLHQuaGVhZENsaWNrZWQobixlLGkpfV19fSxbdC5fdChcIkhFQURfXCIraSxbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS5sYWJlbCl9fSldLHtsYWJlbDplLmxhYmVsLGNvbHVtbjppLGZpZWxkOmV9KV0sMil9KSldKSx0LmZvb3RDbG9uZT9uKFwidGZvb3RcIix7Y2xhc3M6dC5mb290Q2xhc3N9LFtuKFwidHJcIix7YXR0cnM6e3JvbGU6XCJyb3dcIn19LHQuX2wodC5maWVsZHMsZnVuY3Rpb24oZSxpKXtyZXR1cm4gbihcInRoXCIse2tleTppLGNsYXNzOnQuZmllbGRDbGFzcyhlLGkpLHN0eWxlOmUudGhTdHlsZXx8e30sYXR0cnM6e1wiYXJpYS1sYWJlbFwiOmUuc29ydGFibGU/dC5zb3J0RGVzYyYmdC5zb3J0Qnk9PT1pP3QubGFiZWxTb3J0QXNjOnQubGFiZWxTb3J0RGVzYzpudWxsLFwiYXJpYS1zb3J0XCI6ZS5zb3J0YWJsZSYmdC5zb3J0Qnk9PT1pP3Quc29ydERlc2M/XCJkZXNjZW5kaW5nXCI6XCJhc2NlbmRpbmdcIjpudWxsLHRhYmluZGV4OmUuc29ydGFibGU/XCIwXCI6bnVsbH0sb246e2NsaWNrOmZ1bmN0aW9uKG4pe24uc3RvcFByb3BhZ2F0aW9uKCksbi5wcmV2ZW50RGVmYXVsdCgpLHQuaGVhZENsaWNrZWQobixlLGkpfSxrZXlkb3duOltmdW5jdGlvbihuKXtpZighKFwiYnV0dG9uXCJpbiBuKSYmdC5fayhuLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtuLnN0b3BQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSx0LmhlYWRDbGlja2VkKG4sZSxpKX0sZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7bi5zdG9wUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCksdC5oZWFkQ2xpY2tlZChuLGUsaSl9XX19LFt0LiRzY29wZWRTbG90c1tcIkZPT1RfXCIraV0/dC5fdChcIkZPT1RfXCIraSxbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS5sYWJlbCl9fSldLHtsYWJlbDplLmxhYmVsLGNvbHVtbjppLGZpZWxkOmV9KTp0Ll90KFwiSEVBRF9cIitpLFtuKFwiZGl2XCIse2RvbVByb3BzOntpbm5lckhUTUw6dC5fcyhlLmxhYmVsKX19KV0se2xhYmVsOmUubGFiZWwsY29sdW1uOmksZmllbGQ6ZX0pXSwyKX0pKV0pOnQuX2UoKSxuKFwidGJvZHlcIixbdC5fbCh0Ll9pdGVtcyxmdW5jdGlvbihlLGkpe3JldHVybiBuKFwidHJcIix7a2V5OmksY2xhc3M6dC5yb3dDbGFzcyhlKSxhdHRyczp7cm9sZTpcInJvd1wifSxvbjp7Y2xpY2s6ZnVuY3Rpb24obil7dC5yb3dDbGlja2VkKG4sZSxpKX0saG92ZXI6ZnVuY3Rpb24obil7dC5yb3dIb3ZlcmVkKG4sZSxpKX19fSx0Ll9sKHQuZmllbGRzLGZ1bmN0aW9uKG8scil7cmV0dXJuIG4oXCJ0ZFwiLHtrZXk6cixjbGFzczp0LnRkQ2xhc3MobyxlLHIpfSxbdC5fdChyLFt0Ll92KHQuX3MoZVtyXSkpXSx7dmFsdWU6ZVtyXSxpdGVtOmUsaW5kZXg6aX0pXSwyKX0pKX0pLCF0LnNob3dFbXB0eXx8dC5faXRlbXMmJjAhPT10Ll9pdGVtcy5sZW5ndGg/dC5fZSgpOm4oXCJ0clwiLHthdHRyczp7cm9sZTpcInJvd1wifX0sW24oXCJ0ZFwiLHthdHRyczp7Y29sc3BhbjpPYmplY3Qua2V5cyh0LmZpZWxkcykubGVuZ3RofX0sW3QuZmlsdGVyP24oXCJkaXZcIix7YXR0cnM6e3JvbGU6XCJhbGVydFwiLFwiYXJpYS1saXZlXCI6XCJwb2xpdGVcIn19LFt0Ll90KFwiZW1wdHlmaWx0ZXJlZFwiLFtuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidGV4dC1jZW50ZXIgbXktMlwiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmVtcHR5RmlsdGVyZWRUZXh0KX19KV0pXSwyKTpuKFwiZGl2XCIse2F0dHJzOntyb2xlOlwiYWxlcnRcIixcImFyaWEtbGl2ZVwiOlwicG9saXRlXCJ9fSxbdC5fdChcImVtcHR5XCIsW24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ0ZXh0LWNlbnRlciBteS0yXCIsZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZW1wdHlUZXh0KX19KV0pXSwyKV0pXSldLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57c29ydEJ5Om51bGwsc29ydERlc2M6ITAsbG9jYWxJdGVtczpbXX19LHByb3BzOntpZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxpdGVtczp7dHlwZTpbQXJyYXksRnVuY3Rpb25dLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcyYmdGhpcy5pdGVtc1Byb3ZpZGVyPyh3YXJuKFwiYi10YWJsZTogcHJvcCBpdGVtcy1wcm92aWRlciBoYXMgYmVlbiBkZXByZWNhdGVkLiBQYXNzIGEgZnVuY3Rpb24gdG8gaXRlbXMgaW5zdGVhZFwiKSx0aGlzLml0ZW1zUHJvdmlkZXIpOltdfX0sZmllbGRzOnt0eXBlOk9iamVjdCxkZWZhdWx0Ont9fSxzdHJpcGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYm9yZGVyZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxpbnZlcnNlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0saG92ZXI6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzbWFsbDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHJlc3BvbnNpdmU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxoZWFkVmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxmb290VmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxwZXJQYWdlOnt0eXBlOk51bWJlcixkZWZhdWx0Om51bGx9LGN1cnJlbnRQYWdlOnt0eXBlOk51bWJlcixkZWZhdWx0OjF9LGZpbHRlcjp7dHlwZTpbU3RyaW5nLFJlZ0V4cCxGdW5jdGlvbl0sZGVmYXVsdDpudWxsfSxzb3J0Q29tcGFyZTp7dHlwZTpGdW5jdGlvbixkZWZhdWx0Om51bGx9LGl0ZW1zUHJvdmlkZXI6e3R5cGU6RnVuY3Rpb24sZGVmYXVsdDpudWxsfSxub1Byb3ZpZGVyUGFnaW5nOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbm9Qcm92aWRlclNvcnRpbmc6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxub1Byb3ZpZGVyRmlsdGVyaW5nOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYnVzeTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHZhbHVlOnt0eXBlOkFycmF5LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19LGZvb3RDbG9uZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGxhYmVsU29ydEFzYzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkNsaWNrIHRvIHNvcnQgQXNjZW5kaW5nXCJ9LGxhYmVsU29ydERlc2M6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJDbGljayB0byBzb3J0IERlc2NlbmRpbmdcIn0sc2hvd0VtcHR5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZW1wdHlUZXh0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiVGhlcmUgYXJlIG5vIHJlY29yZHMgdG8gc2hvd1wifSxlbXB0eUZpbHRlcmVkVGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlRoZXJlIGFyZSBubyByZWNvcmRzIG1hdGNoaW5nIHlvdXIgcmVxdWVzdFwifX0sd2F0Y2g6e2l0ZW1zOmZ1bmN0aW9uKHQsZSl7ZSE9PXQmJnRoaXMuX3Byb3ZpZGVyVXBkYXRlKCl9LHNvcnREZXNjOmZ1bmN0aW9uKHQsZSl7ZT09PXR8fHRoaXMubm9Qcm92aWRlclNvcnRpbmd8fHRoaXMuX3Byb3ZpZGVyVXBkYXRlKCl9LHNvcnRCeTpmdW5jdGlvbih0LGUpe2U9PT10fHx0aGlzLm5vUHJvdmlkZXJTb3J0aW5nfHx0aGlzLl9wcm92aWRlclVwZGF0ZSgpfSxwZXJQYWdlOmZ1bmN0aW9uKHQsZSl7ZT09PXR8fHRoaXMubm9Qcm92aWRlclBhZ2luZ3x8dGhpcy5fcHJvdmlkZXJVcGRhdGUoKX0sY3VycmVudFBhZ2U6ZnVuY3Rpb24odCxlKXtlPT09dHx8dGhpcy5ub1Byb3ZpZGVyUGFnaW5nfHx0aGlzLl9wcm92aWRlclVwZGF0ZSgpfSxmaWx0ZXI6ZnVuY3Rpb24odCxlKXtlPT09dHx8dGhpcy5ub1Byb3ZpZGVyRmlsdGVyaW5nfHx0aGlzLl9wcm92aWRlclVwZGF0ZSgpfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5oYXNQcm92aWRlciYmdGhpcy5fcHJvdmlkZXJVcGRhdGUoKSx0aGlzLiRyb290LiRvbihcInRhYmxlOjpyZWZyZXNoXCIsZnVuY3Rpb24oZSl7ZT09PXQuaWQmJnQuX3Byb3ZpZGVyVXBkYXRlKCl9KX0sY29tcHV0ZWQ6e3RhYmxlQ2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm5bXCJ0YWJsZVwiLFwiYi10YWJsZVwiLHRoaXMuc3RyaXBlZD9cInRhYmxlLXN0cmlwZWRcIjpcIlwiLHRoaXMuaG92ZXI/XCJ0YWJsZS1ob3ZlclwiOlwiXCIsdGhpcy5pbnZlcnNlP1widGFibGUtaW52ZXJzZVwiOlwiXCIsdGhpcy5ib3JkZXJlZD9cInRhYmxlLWJvcmRlcmVkXCI6XCJcIix0aGlzLnJlc3BvbnNpdmU/XCJ0YWJsZS1yZXNwb25zaXZlXCI6XCJcIix0aGlzLnNtYWxsP1widGFibGUtc21cIjpcIlwiXX0saGVhZENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZFZhcmlhbnQ/XCJ0aGVhZC1cIit0aGlzLmhlYWRWYXJpYW50OlwiXCJ9LGZvb3RDbGFzczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZm9vdFZhcmlhbnR8fHRoaXMuaGVhZFZhcmlhbnR8fG51bGw7cmV0dXJuIHQ/XCJ0aGVhZC1cIit0OlwiXCJ9LGhhc1Byb3ZpZGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXMgaW5zdGFuY2VvZiBGdW5jdGlvbn0scHJvdmlkZXJGaWx0ZXJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbih0aGlzLmhhc1Byb3ZpZGVyJiYhdGhpcy5ub1Byb3ZpZGVyRmlsdGVyaW5nKX0scHJvdmlkZXJTb3J0aW5nOmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy5oYXNQcm92aWRlciYmIXRoaXMubm9Qcm92aWRlclNvcnRpbmcpfSxwcm92aWRlclBhZ2luZzpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKHRoaXMuaGFzUHJvdmlkZXImJiF0aGlzLm5vUHJvdmlkZXJQYWdpbmcpfSxjb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJue3BlclBhZ2U6dGhpcy5wZXJQYWdlLGN1cnJlbnRQYWdlOnRoaXMuY3VycmVudFBhZ2UsZmlsdGVyOnRoaXMuZmlsdGVyLHNvcnRCeTp0aGlzLnNvcnRCeSxzb3J0RGVzYzp0aGlzLnNvcnREZXNjfX0sX2l0ZW1zOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMucGVyUGFnZSxuPXRoaXMuY3VycmVudFBhZ2UsaT10aGlzLmZpbHRlcixvPSh0aGlzLnNvcnRCeSx0aGlzLnNvcnREZXNjLHRoaXMuc29ydENvbXBhcmV8fGRlZmF1bHRTb3J0Q29tcGFyZSkscj10aGlzLmhhc1Byb3ZpZGVyP3RoaXMubG9jYWxJdGVtczp0aGlzLml0ZW1zO2lmKCFyKXJldHVybiB0aGlzLiRuZXh0VGljayh0aGlzLl9wcm92aWRlclVwZGF0ZSksW107aWYocj1yLnNsaWNlKCksaSYmIXRoaXMucHJvdmlkZXJGaWx0ZXJpbmcpaWYoaSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXI9ci5maWx0ZXIoaSk7ZWxzZXt2YXIgcztzPWkgaW5zdGFuY2VvZiBSZWdFeHA/aTpuZXcgUmVnRXhwKFwiLipcIitpK1wiLipcIixcImlnXCIpLHI9ci5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIGU9cy50ZXN0KHJlY1RvU3RyaW5nKHQpKTtyZXR1cm4gcy5sYXN0SW5kZXg9MCxlfSl9cmV0dXJuIHRoaXMuc29ydEJ5JiYhdGhpcy5wcm92aWRlclNvcnRpbmcmJihyPXIuc29ydChmdW5jdGlvbihlLG4pe3ZhciBpPW8oZSxuLHQuc29ydEJ5KTtyZXR1cm4gdC5zb3J0RGVzYz9pOi0xKml9KSksZSYmIXRoaXMucHJvdmlkZXJQYWdpbmcmJihyPXIuc2xpY2UoKG4tMSkqZSxuKmUpKSx0aGlzLiRlbWl0KFwiaW5wdXRcIixyKSxyfX0sbWV0aG9kczp7ZmllbGRDbGFzczpmdW5jdGlvbih0LGUpe3JldHVyblt0LnNvcnRhYmxlP1wic29ydGluZ1wiOlwiXCIsdC5zb3J0YWJsZSYmdGhpcy5zb3J0Qnk9PT1lP1wic29ydGluZ19cIisodGhpcy5zb3J0RGVzYz9cImRlc2NcIjpcImFzY1wiKTpcIlwiLHQudmFyaWFudD9cInRhYmxlLVwiK3QudmFyaWFudDpcIlwiLHQuY2xhc3M/dC5jbGFzczpcIlwiLHQudGhDbGFzcz90LnRoQ2xhc3M6XCJcIl19LHRkQ2xhc3M6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPVwiXCI7cmV0dXJuIGUuX2NlbGxWYXJpYW50cyYmZS5fY2VsbFZhcmlhbnRzW25dJiYoaT0odGhpcy5pbnZlcnNlP1wiYmctXCI6XCJ0YWJsZS1cIikrZS5fY2VsbFZhcmlhbnRzW25dKSxbdC52YXJpYW50JiYhaT8odGhpcy5pbnZlcnNlP1wiYmctXCI6XCJ0YWJsZS1cIikrdC52YXJpYW50OlwiXCIsaSx0LmNsYXNzP3QuY2xhc3M6XCJcIix0LnRkQ2xhc3M/dC50ZENsYXNzOlwiXCJdfSxyb3dDbGFzczpmdW5jdGlvbih0KXt2YXIgZT10Ll9yb3dWYXJpYW50fHx0LnN0YXRlfHxudWxsO3JldHVybltlPyh0aGlzLmludmVyc2U/XCJiZy1cIjpcInRhYmxlLVwiKStlOlwiXCJdfSxyb3dDbGlja2VkOmZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmJ1c3kpcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSx2b2lkIHQuc3RvcFByb3BhZ2F0aW9uKCk7dGhpcy4kZW1pdChcInJvdy1jbGlja2VkXCIsZSxuKX0scm93SG92ZXJlZDpmdW5jdGlvbih0LGUsbil7aWYodGhpcy5idXN5KXJldHVybiB0LnByZXZlbnREZWZhdWx0KCksdm9pZCB0LnN0b3BQcm9wYWdhdGlvbigpO3RoaXMuJGVtaXQoXCJyb3ctaG92ZXJlZFwiLGUsbil9LGhlYWRDbGlja2VkOmZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmJ1c3kpcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSx2b2lkIHQuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIGk9ITE7ZS5zb3J0YWJsZT8obj09PXRoaXMuc29ydEJ5P3RoaXMuc29ydERlc2M9IXRoaXMuc29ydERlc2M6KHRoaXMuc29ydEJ5PW4sdGhpcy5zb3J0RGVzYz0hMCksaT0hMCk6dGhpcy5zb3J0QnkmJih0aGlzLnNvcnRCeT1udWxsLGk9ITApLHRoaXMuJGVtaXQoXCJoZWFkLWNsaWNrZWRcIixuLGUpLGkmJnRoaXMuJGVtaXQoXCJzb3J0LWNoYW5nZWRcIix0aGlzLmNvbnRleHQpfSxyZWZyZXNoOmZ1bmN0aW9uKCl7dGhpcy5oYXNQcm92aWRlciYmdGhpcy5fcHJvdmlkZXJVcGRhdGUoKX0sX3Byb3ZpZGVyU2V0TG9jYWw6ZnVuY3Rpb24odCl7dGhpcy5sb2NhbEl0ZW1zPXQmJnQubGVuZ3RoPjA/dC5zbGljZSgpOltdLHRoaXMuJGVtaXQoXCJyZWZyZXNoZWRcIiksdGhpcy4kcm9vdC4kZW1pdChcInRhYmxlOjpyZWZyZXNoZWRcIix0aGlzLmlkKX0sX3Byb3ZpZGVyVXBkYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdGhpcy5idXN5JiZ0aGlzLmhhc1Byb3ZpZGVyKXt2YXIgZT10aGlzLml0ZW1zKHRoaXMuY29udGV4dCx0aGlzLl9wcm92aWRlclNldExvY2FsKTtlJiYoZS50aGVuJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRoZW4/ZS50aGVuKGZ1bmN0aW9uKGUpe3QuX3Byb3ZpZGVyU2V0TG9jYWwoZSl9KTp0aGlzLl9wcm92aWRlclNldExvY2FsKGUpKX19fX0sdGFicz17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKHQudGFnLHt0YWc6XCJjb21wb25lbnRcIixzdGF0aWNDbGFzczpcInRhYnNcIixhdHRyczp7aWQ6dC5pZHx8bnVsbH19LFt0LmJvdHRvbT9uKFwiZGl2XCIse3JlZjpcInRhYnNDb250YWluZXJcIixjbGFzczpbXCJ0YWItY29udGVudFwiLHtcImNhcmQtYmxvY2tcIjp0LmNhcmR9XX0sW3QuX3QoXCJkZWZhdWx0XCIpLHQudGFicyYmdC50YWJzLmxlbmd0aD90Ll9lKCk6dC5fdChcImVtcHR5XCIpXSwyKTp0Ll9lKCksbihcImRpdlwiLHtjbGFzczp7XCJjYXJkLWhlYWRlclwiOnQuY2FyZH19LFtuKFwidWxcIix7Y2xhc3M6W1wibmF2XCIsXCJuYXYtXCIrdC5uYXZTdHlsZSx0LmNhcmQ/XCJjYXJkLWhlYWRlci1cIit0Lm5hdlN0eWxlOm51bGxdLGF0dHJzOntyb2xlOlwidGFibGlzdFwiLHRhYmluZGV4OlwiMFwiLFwiYXJpYS1zZXRzaXplXCI6dC50YWJzLmxlbmd0aCxcImFyaWEtcG9zaW5zZXRcIjp0LmN1cnJlbnRUYWIrMX0sb246e2tleWRvd246W2Z1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpP1wiYnV0dG9uXCJpbiBlJiYwIT09ZS5idXR0b24/bnVsbDp2b2lkIHQucHJldmlvdXNUYWIoZSk6bnVsbH0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwidXBcIiwzOCkpcmV0dXJuIG51bGw7dC5wcmV2aW91c1RhYihlKX0sZnVuY3Rpb24oZSl7cmV0dXJuXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcInJpZ2h0XCIsMzkpP1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDp2b2lkIHQubmV4dFRhYihlKTpudWxsfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJkb3duXCIsNDApKXJldHVybiBudWxsO3QubmV4dFRhYihlKX0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpKSYmZS5zaGlmdEtleT9cImJ1dHRvblwiaW4gZSYmMCE9PWUuYnV0dG9uP251bGw6dm9pZCB0LnNldFRhYigtMSwhMSwxKTpudWxsfSxmdW5jdGlvbihlKXtyZXR1cm4oXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcInVwXCIsMzgpKSYmZS5zaGlmdEtleT92b2lkIHQuc2V0VGFiKC0xLCExLDEpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwicmlnaHRcIiwzOSkpJiZlLnNoaWZ0S2V5P1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDp2b2lkIHQuc2V0VGFiKHQudGFicy5sZW5ndGgsITEsLTEpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSkmJmUuc2hpZnRLZXk/dm9pZCB0LnNldFRhYih0LnRhYnMubGVuZ3RoLCExLC0xKTpudWxsfV19fSxbdC5fbCh0LnRhYnMsZnVuY3Rpb24oZSxpKXtyZXR1cm4gbihcImxpXCIse3N0YXRpY0NsYXNzOlwibmF2LWl0ZW1cIixhdHRyczp7cm9sZTpcInByZXNlbnRhdGlvblwifX0sW2UuaGVhZEh0bWw/bihcImRpdlwiLHtjbGFzczpbXCJ0YWItaGVhZFwiLHtzbWFsbDp0LnNtYWxsLGFjdGl2ZTplLmxvY2FsQWN0aXZlLGRpc2FibGVkOmUuZGlzYWJsZWR9XSxhdHRyczp7cm9sZTpcImhlYWRpbmdcIix0YWJpbmRleDpcIi0xXCJ9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyhlLmhlYWRIdG1sKX19KTpuKFwiYVwiLHtjbGFzczpbXCJuYXYtbGlua1wiLHtzbWFsbDp0LnNtYWxsLGFjdGl2ZTplLmxvY2FsQWN0aXZlLGRpc2FibGVkOmUuZGlzYWJsZWR9XSxhdHRyczp7aHJlZjplLmhyZWYscm9sZTpcInRhYlwiLFwiYXJpYS1zZWxlY3RlZFwiOmUubG9jYWxBY3RpdmU/XCJ0cnVlXCI6XCJmYWxzZVwiLFwiYXJpYS1jb250cm9sc1wiOmUuaWR8fG51bGwsaWQ6ZS5jb250cm9sbGVkQnl8fG51bGwsdGFiaW5kZXg6XCItMVwifSxkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS50aXRsZSl9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSx0LnNldFRhYihpKX0sa2V5ZG93bjpbZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksdC5zZXRUYWIoaSl9LGZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLHQuc2V0VGFiKGkpfV19fSldKX0pLHQuX3QoXCJ0YWJzXCIpXSwyKV0pLHQuYm90dG9tP3QuX2UoKTpuKFwiZGl2XCIse3JlZjpcInRhYnNDb250YWluZXJcIixjbGFzczpbXCJ0YWItY29udGVudFwiLHtcImNhcmQtYmxvY2tcIjp0LmNhcmR9XX0sW3QuX3QoXCJkZWZhdWx0XCIpLHQudGFicyYmdC50YWJzLmxlbmd0aD90Ll9lKCk6dC5fdChcImVtcHR5XCIpXSwyKV0pfSxzdGF0aWNSZW5kZXJGbnM6W10sZGF0YTpmdW5jdGlvbigpe3JldHVybntjdXJyZW50VGFiOnRoaXMudmFsdWUsdGFiczpbXX19LHByb3BzOntpZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSx0YWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJkaXZcIn0sbm9GYWRlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sY2FyZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHNtYWxsOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdmFsdWU6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MH0scGlsbHM6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxsYXp5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYm90dG9tOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LHdhdGNoOntjdXJyZW50VGFiOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJih0aGlzLiRyb290LiRlbWl0KFwiY2hhbmdlZDo6dGFiXCIsdGhpcyx0LHRoaXMudGFic1t0XSksdGhpcy4kZW1pdChcImlucHV0XCIsdCksdGhpcy50YWJzW3RdLiRlbWl0KFwiY2xpY2tcIikpfSx2YWx1ZTpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0aGlzLnNldFRhYih0KX0sZmFkZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dCE9PWUmJnRoaXMudGFicy5mb3JFYWNoKGZ1bmN0aW9uKGUpe24uJHNldChlLFwiZmFkZVwiLHQpfSl9fSxjb21wdXRlZDp7ZmFkZTpmdW5jdGlvbigpe3JldHVybiF0aGlzLm5vRmFkZX0sbmF2U3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5waWxscz9cInBpbGxzXCI6XCJ0YWJzXCJ9fSxtZXRob2RzOntzaWduOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dD8wOnQ+MD8xOi0xfSxuZXh0VGFiOmZ1bmN0aW9uKCl7dGhpcy5zZXRUYWIodGhpcy5jdXJyZW50VGFiLCExLDEpfSxwcmV2aW91c1RhYjpmdW5jdGlvbigpe3RoaXMuc2V0VGFiKHRoaXMuY3VycmVudFRhYiwhMSwtMSl9LHNldFRhYjpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcztpZihuPW58fDAsZXx8dCtuIT09dGhpcy5jdXJyZW50VGFiKXt2YXIgbz10aGlzLnRhYnNbdCtuXTtvJiYoby5kaXNhYmxlZD9uJiZ0aGlzLnNldFRhYih0LGUsbit0aGlzLnNpZ24obikpOih0aGlzLnRhYnMuZm9yRWFjaChmdW5jdGlvbih0KXt0IT09byYmdC5sb2NhbEFjdGl2ZSYmaS4kc2V0KHQsXCJsb2NhbEFjdGl2ZVwiLCExKX0pLHRoaXMuJHNldChvLFwibG9jYWxBY3RpdmVcIiwhMCksdGhpcy5jdXJyZW50VGFiPXQrbikpfX0sdXBkYXRlVGFiczpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy4kc2xvdHMuZGVmYXVsdD90aGlzLnRhYnM9dGhpcy4kc2xvdHMuZGVmYXVsdC5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29tcG9uZW50SW5zdGFuY2V8fCExfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbXBvbmVudEluc3RhbmNlfSk6dGhpcy50YWJzPVtdLHRoaXMudGFicy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuJHNldChlLFwiZmFkZVwiLHQuZmFkZSksdC4kc2V0KGUsXCJsYXp5XCIsdC5sYXp5KX0pO3ZhciBlPXRoaXMuY3VycmVudFRhYjtudWxsIT09ZSYmdm9pZCAwIT09ZXx8dGhpcy50YWJzLmZvckVhY2goZnVuY3Rpb24odCxuKXt0LmFjdGl2ZSYmKGU9bil9KTt2YXIgbj0wO2U+dGhpcy50YWJzLmxlbmd0aC0xJiYobj0tMSksdGhpcy5zZXRUYWIoZXx8MCwhMCxuKX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZVRhYnMoKSxvYnNlcnZlRE9NKHRoaXMuJHJlZnMudGFic0NvbnRhaW5lcix0aGlzLnVwZGF0ZVRhYnMuYmluZCh0aGlzKSx7c3VidHJlZTohMX0pfX0sdGFiPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJ0cmFuc2l0aW9uXCIse2F0dHJzOnttb2RlOlwib3V0LWluXCJ9LG9uOntlbnRlcjp0LmVudGVyLFwiYmVmb3JlLWxlYXZlXCI6dC5iZWZvcmVMZWF2ZX19LFt0LmxvY2FsQWN0aXZlfHwhdC5sYXp5P24odC50YWcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTp0LmxvY2FsQWN0aXZlfHx0LmxhenksZXhwcmVzc2lvbjpcImxvY2FsQWN0aXZlIHx8IGxhenlcIn1dLHJlZjpcInBhbmVsXCIsdGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1widGFiLXBhbmVcIix7c2hvdzp0LnNob3csZmFkZTp0LmZhZGUsZGlzYWJsZWQ6dC5kaXNhYmxlZCxhY3RpdmU6dC5sb2NhbEFjdGl2ZX1dLGF0dHJzOntpZDp0LmlkfHxudWxsLHJvbGU6XCJ0YWJwYW5lbFwiLFwiYXJpYS1oaWRkZW5cIjp0LmxvY2FsQWN0aXZlP1wiZmFsc2VcIjpcInRydWVcIixcImFyaWEtZXhwYW5kZWRcIjp0LmxvY2FsQWN0aXZlP1widHJ1ZVwiOlwiZmFsc2VcIixcImFyaWEtbGFibGVsbGVkYnlcIjp0LmNvbnRyb2xsZWRCeXx8bnVsbH19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMik6dC5fZSgpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLG1ldGhvZHM6e2VudGVyOmZ1bmN0aW9uKCl7dGhpcy5zaG93PSEwfSxiZWZvcmVMZWF2ZTpmdW5jdGlvbigpe3RoaXMuc2hvdz0hMX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57ZmFkZTohMSxsb2NhbEFjdGl2ZTohMSxsYXp5OiEwLHNob3c6ITF9fSxjb21wdXRlZDp7Y29udHJvbGxlZEJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnV0dG9uSWR8fCh0aGlzLmlkP3RoaXMuaWQrXCJfX0JWX3RhYl9idXR0b25fX1wiOm51bGwpfX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHRhZzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImRpdlwifSxidXR0b25JZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSx0aXRsZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxoZWFkSHRtbDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGFjdGl2ZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhyZWY6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCIjXCJ9fX0sdG9vbHRpcD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZC1pbmxpbmUtYmxvY2tcIn0sW24oXCJzcGFuXCIse3JlZjpcInRyaWdnZXJcIixzdGF0aWNDbGFzczpcImQtaW5saW5lLWJsb2NrXCJ9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMiksbihcImRpdlwiLHtyZWY6XCJwb3BvdmVyXCIsY2xhc3M6W1widG9vbHRpcFwiLFwidG9vbHRpcC1cIit0aGlzLnBsYWNlbWVudF0sc3R5bGU6e29wYWNpdHk6dC5zaG93U3RhdGU/MTowfSxhdHRyczp7dGFiaW5kZXg6XCItMVwifSxvbjp7Zm9jdXM6ZnVuY3Rpb24oZSl7dC4kZW1pdChcImZvY3VzXCIpfSxibHVyOmZ1bmN0aW9uKGUpe3QuJGVtaXQoXCJibHVyXCIpfX19LFtuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidG9vbHRpcC1pbm5lclwifSxbdC5fdChcImNvbnRlbnRcIixbbihcInNwYW5cIix7ZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuY29udGVudCl9fSldKV0sMildKV0pfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltwb3BvdmVyJDFdLHByb3BzOntjb250ZW50Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHRyaWdnZXJzOnt0eXBlOltCb29sZWFuLFN0cmluZyxBcnJheV0sZGVmYXVsdDpcImhvdmVyXCJ9fX0sY29tcG9uZW50cz1PYmplY3QuZnJlZXplKHtiQWxlcnQ6YWxlcnQsYkJyZWFkY3J1bWI6YnJlYWRjcnVtYixiQnV0dG9uOmJCdG4sYkJ0bjpiQnRuLGJCdXR0b25Ub29sYmFyOmJ1dHRvblRvb2xiYXIsYkJ0blRvb2xiYXI6YnV0dG9uVG9vbGJhcixiQnV0dG9uR3JvdXA6YnV0dG9uR3JvdXAsYkJ0bkdyb3VwOmJ1dHRvbkdyb3VwLGJCdXR0b25Hcm91cERyb3Bkb3duOmJ1dHRvbkdyb3VwRHJvcGRvd24sYkJ0bkdyb3VwRHJvcGRvd246YnV0dG9uR3JvdXBEcm9wZG93bixiSW5wdXRHcm91cDppbnB1dEdyb3VwLGJJbnB1dEdyb3VwQWRkb246aW5wdXRHcm91cEFkZG9uLGJJbnB1dEdyb3VwQnV0dG9uOmlucHV0R3JvdXBCdXR0b24sYklucHV0R3JvdXBCdG46aW5wdXRHcm91cEJ1dHRvbixiQ2FyZDpjYXJkLGJDYXJkR3JvdXA6Y2FyZEdyb3VwLGJEcm9wZG93bjpkcm9wZG93biQxLGJEcm9wZG93bkl0ZW06ZHJvcGRvd25JdGVtLGJEcm9wZG93bkl0ZW1CdXR0b246ZHJvcGRvd25JdGVtQnV0dG9uLGJEcm9wZG93bkl0ZW1CdG46ZHJvcGRvd25JdGVtQnV0dG9uLGJEcm9wZG93bkRpdmlkZXI6ZHJvcGRvd25EaXZpZGVyLGJEcm9wZG93bkhlYWRlcjpkcm9wZG93bkhlYWRlcixiRHJvcGRvd25TZWxlY3Q6ZHJvcGRvd25TZWxlY3QsYkZvcm06YkZvcm0sYkZvcm1DaGVja2JveDpmb3JtQ2hlY2tib3gsYkZvcm1GaWVsZHNldDpmb3JtRmllbGRzZXQsYkZvcm1GaWxlOmZvcm1GaWxlLGJGb3JtUmFkaW86Zm9ybVJhZGlvLGJGb3JtSW5wdXQ6Zm9ybUlucHV0LGJGb3JtSW5wdXRTdGF0aWM6YkZvcm1JbnB1dFN0YXRpYyxiRm9ybVNlbGVjdDpmb3JtU2VsZWN0LGJKdW1ib3Ryb246anVtYm90cm9uLGJCYWRnZTpiYWRnZSxiTWVkaWE6bWVkaWEsYk1vZGFsOm1vZGFsLGJOYXZiYXI6bmF2YmFyLGJOYXZUZXh0Om5hdlRleHQsYk5hdkZvcm06bmF2Rm9ybSxiUGFnaW5hdGlvbjpwYWdpbmF0aW9uLGJQb3BvdmVyOnBvcG92ZXIsYlByb2dyZXNzOnByb2dyZXNzLGJUYWJsZTp0YWJsZSxiVG9vbHRpcDp0b29sdGlwLGJUYWI6dGFiLGJUYWJzOnRhYnMsYk5hdjpuYXYsYk5hdkl0ZW06bmF2SXRlbSxiTmF2SXRlbURyb3Bkb3duOm5hdkl0ZW1Ecm9wZG93bixiTmF2VG9nZ2xlOm5hdlRvZ2dsZSxiTGlzdEdyb3VwSXRlbTpsaXN0R3JvdXBJdGVtLGJMaXN0R3JvdXA6bGlzdEdyb3VwLGJDYXJvdXNlbFNsaWRlOmNhcm91c2VsU2xpZGUsYkNhcm91c2VsOmNhcm91c2VsLGJDb2xsYXBzZTpjb2xsYXBzZSxiTGluazpiTGlua30pLGFsbF9saXN0ZW5fdHlwZXM9e2hvdmVyOiEwLGNsaWNrOiEwLGZvY3VzOiEwfSxpbkJyb3dzZXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyxsaXN0ZW5fdHlwZXM9e2NsaWNrOiEwfSx0b2dnbGU9e2JpbmQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10YXJnZXRzKHQsZSxsaXN0ZW5fdHlwZXMsZnVuY3Rpb24odCl7dmFyIGU9dC50YXJnZXRzLG49dC52bTtlLmZvckVhY2goZnVuY3Rpb24odCl7bi4kcm9vdC4kZW1pdChcImNvbGxhcHNlOjp0b2dnbGVcIix0KX0pfSk7aW5Ccm93c2VyJiZ0Ll9fdnVlX18mJm4ubGVuZ3RoPjAmJih0LnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIixuLmpvaW4oXCIgXCIpKSx0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIixcImZhbHNlXCIpLHQuX192dWVfXy4kcm9vdC4kb24oXCJjb2xsYXBzZTo6dG9nZ2xlOjpzdGF0ZVwiLGZ1bmN0aW9uKGUsaSl7LTEhPT1uLmluZGV4T2YoZSkmJnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLGk/XCJ0cnVlXCI6XCJmYWxzZVwiKX0pKX19LGxpc3Rlbl90eXBlcyQxPXtjbGljazohMH0sbW9kYWwkMT17YmluZDpmdW5jdGlvbih0LGUpe3RhcmdldHModCxlLGxpc3Rlbl90eXBlcyQxLGZ1bmN0aW9uKGUpe3ZhciBuPWUudGFyZ2V0cyxpPWUudm07bi5mb3JFYWNoKGZ1bmN0aW9uKGUpe2kuJHJvb3QuJGVtaXQoXCJzaG93Ojptb2RhbFwiLGUsdCl9KX0pfX0saW5Ccm93c2VyJDE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyxpc1NlcnZlcj0haW5Ccm93c2VyJDE7aW5Ccm93c2VyJDEmJndpbmRvdy5FbGVtZW50JiYhRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCYmKEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3Q9ZnVuY3Rpb24odCl7dmFyIGUsbj0odGhpcy5kb2N1bWVudHx8dGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHQpLGk9dGhpcztkb3tmb3IoZT1uLmxlbmd0aDstLWU+PTAmJm4uaXRlbShlKSE9PWk7KTt9d2hpbGUoZTwwJiYoaT1pLnBhcmVudEVsZW1lbnQpKTtyZXR1cm4gaX0pO3ZhciBOQU1FPVwidi1iLXNjcm9sbHNweVwiLEVWRU5UPVwic2Nyb2xsc3B5OjphY3RpdmF0ZVwiLEJWU1M9XCJfX0JWX1Njcm9sbFNweV9fXCIsRGVmYXVsdD17ZWxlbWVudDpcImJvZHlcIixvZmZzZXQ6MTAsbWV0aG9kOlwiYXV0b1wiLHRocm90dGxlOjIwMH0sRGVmYXVsdFR5cGU9e2VsZW1lbnQ6XCIoc3RyaW5nfGVsZW1lbnQpXCIsb2Zmc2V0OlwibnVtYmVyXCIsbWV0aG9kOlwic3RyaW5nXCIsdGhyb3R0bGU6XCJudW1iZXJcIn0sQ2xhc3NOYW1lPXtEUk9QRE9XTl9JVEVNOlwiZHJvcGRvd24taXRlbVwiLERST1BET1dOX01FTlU6XCJkcm9wZG93bi1tZW51XCIsRFJPUERPV05fVE9HR0xFOlwiZHJvcGRvd24tdG9nZ2xlXCIsTkFWX0xJTks6XCJuYXYtbGlua1wiLExJU1RfSVRFTTpcImxpc3QtZ3JvdXAtaXRlbVwiLEFDVElWRTpcImFjdGl2ZVwifSxTZWxlY3Rvcj17QUNUSVZFOlwiLmFjdGl2ZVwiLE5BVl9MSVNUX0dST1VQOlwiLm5hdiwgLmxpc3QtZ3JvdXBcIixOQVY6XCIubmF2XCIsTElTVF9HUk9VUDpcIi5saXN0LWdyb3VwXCIsTkFWX0xJTktTOlwiLm5hdi1saW5rXCIsTElTVF9JVEVNUzpcIi5saXN0LWdyb3VwLWl0ZW1cIixEUk9QRE9XTjpcIi5kcm9wZG93blwiLERST1BET1dOX0lURU1TOlwiLmRyb3Bkb3duLWl0ZW1cIixEUk9QRE9XTl9UT0dHTEU6XCIuZHJvcGRvd24tdG9nZ2xlXCJ9LE9mZnNldE1ldGhvZD17T0ZGU0VUOlwib2Zmc2V0XCIsUE9TSVRJT046XCJwb3NpdGlvblwifTtTY3JvbGxTcHkucHJvdG90eXBlLnVwZGF0ZUNvbmZpZz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3QuYXJnJiYodGhpcy5fY29uZmlnLmVsZW1lbnQ9XCIjXCIrdC5hcmcpLE9iamVjdC5rZXlzKHQubW9kaWZpZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHQpey9eXFxkKyQvLnRlc3QodCk/ZS5fY29uZmlnLm9mZnNldD1wYXJzZUludCh0LDEwKTovXihhdXRvfHBvc2l0aW9ufG9mZnNldCkkLy50ZXN0KHQpJiYoZS5fY29uZmlnLm1ldGhvZD10KX0pLFwic3RyaW5nXCI9PXR5cGVvZiB0LnZhbHVlP3RoaXMuX2NvbmZpZy5lbGVtZW50PXQudmFsdWU6XCJudW1iZXJcIj09dHlwZW9mIHQudmFsdWU/dGhpcy5fY29uZmlnLm9mZnNldD1NYXRoLnJvdW5kKHQudmFsdWUpOlwib2JqZWN0XCI9PXR5cGVvZiB0LnZhbHVlJiZPYmplY3Qua2V5cyh0LnZhbHVlKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIEJvb2xlYW4oRGVmYXVsdFR5cGVbdF0pfSkuZm9yRWFjaChmdW5jdGlvbihuKXtlLl9jb25maWdbbl09dC52YWx1ZVtuXX0pLHR5cGVDaGVja0NvbmZpZyhOQU1FLHRoaXMuX2NvbmZpZyxEZWZhdWx0VHlwZSk7dmFyIG49Z2V0Vm0odGhpcy5fJGVsKTtyZXR1cm4gbiYmbi4kcm9vdCYmKHRoaXMuXyRyb290PW4uJHJvb3QpLHRoaXN9LFNjcm9sbFNweS5wcm90b3R5cGUubGlzdGVuPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdCYmKFwiQk9EWVwiIT09dC50YWdOYW1lJiZ0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMsITEpKSx0aGlzfSxTY3JvbGxTcHkucHJvdG90eXBlLnVuTGlzdGVuPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdCYmKFwiQk9EWVwiIT09dC50YWdOYW1lJiZ0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLCExKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMsITEpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLCExKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMsITEpKSx0aGlzfSxTY3JvbGxTcHkucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtpZighZSlyZXR1cm4gdGhpczt2YXIgbj1cIkJPRFlcIj09PWUudGFnTmFtZT9PZmZzZXRNZXRob2QuT0ZGU0VUOk9mZnNldE1ldGhvZC5QT1NJVElPTixpPVwiYXV0b1wiPT09dGhpcy5fY29uZmlnLm1ldGhvZD9uOnRoaXMuX2NvbmZpZy5tZXRob2Qsbz1pPT09T2Zmc2V0TWV0aG9kLk9GRlNFVD8wOnRoaXMuX2dldFNjcm9sbFRvcCgpO3JldHVybiB0aGlzLl9vZmZzZXRzPVtdLHRoaXMuX3RhcmdldHM9W10sdGhpcy5fc2Nyb2xsSGVpZ2h0PXRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCRRU0EodGhpcy5fc2VsZWN0b3IsdGhpcy5fJGVsKS5tYXAoZnVuY3Rpb24odCl7dmFyIG49dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO2lmKG4mJlwiI1wiPT09bi5jaGFyQXQoMCkmJlwiI1wiIT09biYmLTE9PT1uLmluZGV4T2YoXCIjL1wiKSl7dmFyIHI9JFFTKG4sZSk7aWYoIXIpcmV0dXJuIG51bGw7dmFyIHM9ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihzLndpZHRofHxzLmhlaWdodClyZXR1cm57b2Zmc2V0OihpPT09T2Zmc2V0TWV0aG9kLk9GRlNFVD9zLnRvcDpyLm9mZnNldFRvcCkrbyxocmVmOm59fXJldHVybiBudWxsfSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkuc29ydChmdW5jdGlvbih0LGUpe3JldHVybiB0Lm9mZnNldC1lLm9mZnNldH0pLmZvckVhY2goZnVuY3Rpb24oZSl7dC5fb2Zmc2V0cy5wdXNoKGUub2Zmc2V0KSx0Ll90YXJnZXRzLnB1c2goZS5ocmVmKX0pLHRoaXN9LFNjcm9sbFNweS5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuX2dldFNjcm9sbGVyKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuX2dldFNjcm9sbFRvcCgpK3RoaXMuX2NvbmZpZy5vZmZzZXQsbj10aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSxpPXRoaXMuX2NvbmZpZy5vZmZzZXQrbi10aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtpZih0aGlzLl9zY3JvbGxIZWlnaHQhPT1uJiZ0aGlzLnJlZnJlc2goKSxlPj1pKXt2YXIgbz10aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoLTFdO3JldHVybiB0aGlzLl9hY3RpdmVUYXJnZXQhPT1vJiZ0aGlzLl9hY3RpdmF0ZShvKSx0aGlzfWlmKHRoaXMuX2FjdGl2ZVRhcmdldCYmZTx0aGlzLl9vZmZzZXRzWzBdJiZ0aGlzLl9vZmZzZXRzWzBdPjApcmV0dXJuIHRoaXMuX2FjdGl2ZVRhcmdldD1udWxsLHRoaXMuX2NsZWFyKCksdGhpcztmb3IodmFyIHI9dGhpcy5fb2Zmc2V0cy5sZW5ndGg7ci0tOyl0Ll9hY3RpdmVUYXJnZXQhPT10Ll90YXJnZXRzW3JdJiZlPj10Ll9vZmZzZXRzW3JdJiYodm9pZCAwPT09dC5fb2Zmc2V0c1tyKzFdfHxlPHQuX29mZnNldHNbcisxXSkmJnQuX2FjdGl2YXRlKHQuX3RhcmdldHNbcl0pO3JldHVybiB0aGlzfSxTY3JvbGxTcHkucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLnVuTGlzdGVuKCksY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2l6ZVRpbWVvdXQpLHRoaXMuX3Jlc2l6ZVRpbWVvdXQ9bnVsbCx0aGlzLl8kZWw9bnVsbCx0aGlzLl9jb25maWc9bnVsbCx0aGlzLl9zZWxlY3Rvcj1udWxsLHRoaXMuX29mZnNldHM9bnVsbCx0aGlzLl90YXJnZXRzPW51bGwsdGhpcy5fYWN0aXZlVGFyZ2V0PW51bGwsdGhpcy5fc2Nyb2xsSGVpZ2h0PW51bGwsdGhpcy5fJHJvb3Q9bnVsbH0sU2Nyb2xsU3B5LnByb3RvdHlwZS5oYW5kbGVFdmVudD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO1wic2Nyb2xsXCI9PT10LnR5cGU/dGhpcy5wcm9jZXNzKCk6XCJvcmllbnRhdGlvbmNoYW5nZVwiPT09dC50eXBlP3RoaXMucmVmcmVzaCgpLnByb2Nlc3MoKTpcInJlc2l6ZVwiPT09dC50eXBlJiZmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLl9yZXNpemVUaW1lb3V0KSx0aGlzLl9yZXNpemVUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLnJlZnJlc2goKS5wcm9jZXNzKCl9LGUuX2NvbmZpZy50aHJvdHRsZXx8RGVmYXVsdC50aHJvdHRsZSl9KCl9LFNjcm9sbFNweS5wcm90b3R5cGUuX2dldFNjcm9sbGVyPWZ1bmN0aW9uKCl7aWYoaXNTZXJ2ZXIpcmV0dXJuIG51bGw7dmFyIHQ9dGhpcy5fY29uZmlnLmVsZW1lbnQ7cmV0dXJuIHQ/dCYmaXNFbGVtZW50KHQpP3Q6XCJzdHJpbmdcIj09dHlwZW9mIHQ/XCJib2R5XCI9PT10P2RvY3VtZW50LmJvZHk6JFFTKHQpOm51bGw6bnVsbH0sU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0U2Nyb2xsVG9wPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdD9cIkJPRFlcIj09PXQudGFnTmFtZT93aW5kb3cucGFnZVlPZmZzZXQ6dC5zY3JvbGxUb3A6MH0sU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0U2Nyb2xsSGVpZ2h0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdD9cIkJPRFlcIj09PXQudGFnTmFtZT9NYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KTp0LnNjcm9sbEhlaWdodDowfSxTY3JvbGxTcHkucHJvdG90eXBlLl9nZXRPZmZzZXRIZWlnaHQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9nZXRTY3JvbGxlcigpO3JldHVybiB0P1wiQk9EWVwiPT09dC50YWdOYW1lP3dpbmRvdy5pbm5lckhlaWdodDp0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDowfSxTY3JvbGxTcHkucHJvdG90eXBlLl9hY3RpdmF0ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuX2FjdGl2ZVRhcmdldD10LHRoaXMuX2NsZWFyKCk7dmFyIG49dGhpcy5fc2VsZWN0b3Iuc3BsaXQoXCIsXCIpLGk9JFFTQSgobj1uLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZSsnW2hyZWY9XCInK3QrJ1wiXSd9KSkuam9pbihcIixcIiksdGhpcy5fJGVsKTtpLmZvckVhY2goZnVuY3Rpb24odCl7aWYodC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkRST1BET1dOX0lURU0pKXt2YXIgbj1jbG9zZXN0KHQsU2VsZWN0b3IuRFJPUERPV04pO2lmKG4pe3ZhciBpPSRRUyhTZWxlY3Rvci5EUk9QRE9XTl9UT0dHTEUsbik7aSYmZS5fc2V0QWN0aXZlU3RhdGUoaSwhMCl9ZS5fc2V0QWN0aXZlU3RhdGUodCwhMCl9ZWxzZSBlLl9zZXRBY3RpdmVTdGF0ZSh0LCEwKSxlLl9zZXRQYXJlbnRzU2libGluZ0FjdGl2ZVN0YXRlKHQsU2VsZWN0b3IuTkFWX0xJU1RfR1JPVVAsW0NsYXNzTmFtZS5OQVZfTElOSyxDbGFzc05hbWUuTElTVF9JVEVNXSwhMCl9KSxpJiZpLmxlbmd0aD4wJiZ0aGlzLl8kcm9vdCYmdGhpcy5fJHJvb3QuJGVtaXQmJnRoaXMuXyRyb290LiRlbWl0KEVWRU5ULHQpfSxTY3JvbGxTcHkucHJvdG90eXBlLl9jbGVhcj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7JFFTQSh0aGlzLl9zZWxlY3Rvcix0aGlzLl8kZWwpLmZpbHRlcihmdW5jdGlvbih0KXtpZih0LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuQUNUSVZFKSl7dmFyIGU9dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO3JldHVyblwiI1wiPT09ZS5jaGFyQXQoMCkmJjAhPT1lLmluZGV4T2YoXCIjL1wiKX1yZXR1cm4hMX0pLmZvckVhY2goZnVuY3Rpb24oZSl7dC5fc2V0QWN0aXZlU3RhdGUoZSwhMSl9KX0sU2Nyb2xsU3B5LnByb3RvdHlwZS5fc2V0QWN0aXZlU3RhdGU9ZnVuY3Rpb24odCxlKXtpZih0KXt0LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuTkFWX0xJTkspJiYhdC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkRST1BET1dOX1RPR0dMRSkmJih0PXQucGFyZW50RWxlbWVudCk7dmFyIG49Z2V0Vm0odCk7biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4uJHByb3BzLFwiYWN0aXZlXCIpP24uJHByb3BzLmFjdGl2ZT1lOnQuY2xhc3NMaXN0W2U/XCJhZGRcIjpcInJlbW92ZVwiXShDbGFzc05hbWUuQUNUSVZFKX19LFNjcm9sbFNweS5wcm90b3R5cGUuX3NldFBhcmVudHNTaWJsaW5nQWN0aXZlU3RhdGU9ZnVuY3Rpb24odCxlLG4saSl7dmFyIG89dGhpcztpZihuKXtBcnJheS5pc0FycmF5KG4pfHwobj1bbl0pO2Zvcih2YXIgcj10O3I7KWlmKChyPWNsb3Nlc3QocixlKSkmJnIucHJldmlvdXNFbGVtZW50U2libGluZylmb3IodmFyIHM9MDtzPG4ubGVuZ3RoLTE7cysrKXIucHJldmlvdXNFbGVtZW50U2libGluZy5jbGFzc0xpc3QuY29udGFpbnMobltzXSkmJm8uX3NldEFjdGl2ZVN0YXRlKHIsaSl9fTt2YXIgc2Nyb2xsc3B5PXtiaW5kOmZ1bmN0aW9uKHQsZSl7aXNTZXJ2ZXJ8fHRbQlZTU118fCh0W0JWU1NdPW5ldyBTY3JvbGxTcHkodCxlKSl9LGluc2VydGVkOmZ1bmN0aW9uKHQsZSl7IWlzU2VydmVyJiZ0W0JWU1NdJiZ0W0JWU1NdLnVwZGF0ZUNvbmZpZyhlKS5saXN0ZW4oKS5yZWZyZXNoKCkucHJvY2VzcygpfSx1cGRhdGU6ZnVuY3Rpb24odCxlKXshaXNTZXJ2ZXImJnRbQlZTU10mJnRbQlZTU10udXBkYXRlQ29uZmlnKGUpLnJlZnJlc2goKS5wcm9jZXNzKCl9LGNvbXBvbmVudFVwZGF0ZWQ6ZnVuY3Rpb24odCxlKXshaXNTZXJ2ZXImJnRbQlZTU10mJnRbQlZTU10udXBkYXRlQ29uZmlnKGUpLnJlZnJlc2goKS5wcm9jZXNzKCl9LHVuYmluZDpmdW5jdGlvbih0KXshaXNTZXJ2ZXImJnRbQlZTU10mJih0W0JWU1NdLnVuTGlzdGVuKCkuZGlzcG9zZSgpLHRbQlZTU109bnVsbCl9fSxkaXJlY3RpdmVzPU9iamVjdC5mcmVlemUoe2JUb2dnbGU6dG9nZ2xlLGJNb2RhbDptb2RhbCQxLGJTY3JvbGxzcHk6c2Nyb2xsc3B5fSksVnVlUGx1Z2luPXtpbnN0YWxsOmZ1bmN0aW9uKHQpe2lmKCF0Ll9ib290c3RyYXBfdnVlX2luc3RhbGxlZCl7dC5fYm9vdHN0cmFwX3Z1ZV9pbnN0YWxsZWQ9ITA7Zm9yKHZhciBlIGluIGNvbXBvbmVudHMpdC5jb21wb25lbnQoZSxjb21wb25lbnRzW2VdKTtmb3IodmFyIG4gaW4gZGlyZWN0aXZlcyl0LmRpcmVjdGl2ZShuLGRpcmVjdGl2ZXNbbl0pfX19O1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5WdWUmJndpbmRvdy5WdWUudXNlKFZ1ZVBsdWdpbik7ZXhwb3J0IGRlZmF1bHQgVnVlUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLXZ1ZS5lc20uanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L19ib290c3RyYXAtdnVlQDAuMTcuMUBib290c3RyYXAtdnVlL2Rpc3QvYm9vdHN0cmFwLXZ1ZS5lc20uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ })

},[543]);